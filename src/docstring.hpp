#include <string>
#include <unordered_map>

namespace xfift {
    static inline std::string get_docstring(const std::string& word) {
        static std::unordered_map<std::string, std::string> docs = {
            {"!", "! ( x p — )\nStores new value x into Box p, cf. p:variables."},
            {"\"", "\"❬string❭\" ( — S )\nPushes a String literal into the stack, cf. p:string.lit and p:string.ops."},
            {"#", "# ( x S — x' S' )\nPerforms one step of the conversion of Integer x into its decimal representation by appending to String S one decimal digit representing x mod10. The quotient x':= ⌊x/10⌋ is returned as well."},
            {"#>", "#> ( S — S' )\nFinishes the conversion of an Integer into its human-readable representation (decimal or otherwise) started with <# by reversing String S. Equivalent to $reverse."},
            {"#s", "#s ( x S — x' S' )\nPerforms # one or more times until the quotient x' becomes non-positive. Equivalent to {#over 0<= } until."},
            {"$#", "$# ( — x )\nPushes the total number of command-line arguments passed to the Fift program, cf. p:cmdline.ops. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$(", "$(❬string❭) ( — … )\nLooks up the word $❬string❭ during execution time and executes its current definition. Typically used to access the current values of command-line arguments, e.g., $(2) is essentially equivalent to @' $2."},
            {"$()", "$() ( x — S )\nPushes the x -th command-line argument similarly to $n, but with Integer x≥0 taken from the stack, cf. p:cmdline.ops. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$+", "$+ ( S S' — S.S' )\nConcatenates two strings, cf. p:string.ops."},
            {"$,", "$, ( b S — b' )\nAppends String S to Builder b, cf. p:builder.ops. The string is interpreted as a binary string of length 8n, where n is the number of bytes in the UTF-8 representation of S."},
            {"$n", "$n ( — S )\nPushes the n -th command-line argument as a String S, cf. p:cmdline.ops. For instance, $0 pushes the name of the script being executed, $1 the first command line argument, and so on. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$=", "$= ( S S' — ? )\nReturns -1 if strings S and S' are equal, 0 otherwise, cf. p:string.cmp.ops. Equivalent to $cmp 0=."},
            {"$>s", "$>s ( S — s )\nTransforms the String S into a Slice, cf. p:slice.ops. Equivalent to <b swap $, b> <s."},
            {"$>smca", "$>smca ( S — x y z -1 or 0 )\nUnpacks a standard TON smart-contract address from its human-readable string representation S, cf. p:smc.addr.ops. On success, returns the signed 32-bit workchain x, the unsigned 256-bit in-workchain address y, the flags z (where +1 means that the address is non-bounceable, +2 that the address is testnet-only), and -1. On failure, pushes 0."},
            {"$@", "$@ ( s x — S )\nFetches the first x bytes (i.e., 8x bits) from Slice s, and returns them as a UTF-8 String S, cf. p:slice.ops. If there are not enough data bits in s, throws an exception."},
            {"$@+", "$@+ ( s x — S s' )\nSimilar to $@, but returns the remainder of Slice s as well, cf. p:slice.ops."},
            {"$@?", "$@? ( s x — S -1 or 0 )\nSimilar to $@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"$@?+", "$@?+ ( s x — S s' -1 or s 0 )\nSimilar to $@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"$cmp", "$cmp ( S S' — x )\nReturns 0 if strings S and S' are equal, -1 if S is lexicographically less than S', and 1 if S is lexicographically greater than S', cf. p:string.cmp.ops."},
            {"$len", "$len ( S — x )\nComputes the byte length (not the UTF-8 character length!) of a string, cf. p:string.ops."},
            {"$reverse", "$reverse ( S — S' )\nReverses the order of UTF-8 characters in String S. If S is not a valid UTF-8 string, the return value is undefined and may be also invalid."},
            {"%1<<", "%1<< ( x y — z )\nComputes z:=x mod 2ʸ =x&(2ʸ -1) for two Integer s x and 0≤ y≤ 256."},
            {"'❬word-name❭", "'❬word-name❭ ( — e )\nReturns the execution token equal to the current (compile-time) definition of ❬word-name❭, cf. p:blocks. If the specified word is not found, throws an exception."},
            {"'nop", "'nop ( — e )\nPushes the default definition of nop —-an execution token that does nothing when executed, cf. p:dict.lookup."},
            {"(')❬word-name❭", "(')❬word-name❭ ( — e )\nSimilar to ', but returns the definition of the specified word at execution time, performing a dictionary lookup each time it is invoked, cf. p:dict.lookup. May be used to recover the current values of constants inside word definitions and other blocks by using the phrase (')❬word-name❭execute."},
            {"(-trailing)", "(-trailing) ( S x — S' )\nRemoves from String S all trailing characters with UTF-8 codepoint x."},
            {"(.)", "(.) ( x — S )\nReturns the String with the decimal representation of Integer x. Equivalent to dup abs <##srot sign#> nip."},
            {"(atom)", "(atom) ( S x — a -1 or 0 )\nReturns the only Atom a with the name given by String S, cf. p:atoms. If there is no such Atom yet, either creates it (if Integer x is non-zero) or returns a single zero to indicate failure (if x is zero)."},
            {"(b.)", "(b.) ( x — S )\nReturns the String with the binary representation of Integer x."},
            {"(compile)", "(compile) ( l x₁ … xₙ n e — l' )\nExtends WordList l so that it would push 0≤ n≤ 255 values x₁, …, xₙ into the stack and execute the execution token e when invoked, where 0≤ n≤ 255 is an Integer, cf. p:wordlist.ops. If e is equal to the special value 'nop, the last step is omitted."},
            {"(create)", "(create) ( e S x — )\nCreates a new word with the name equal to String S and definition equal to WordDef e, using flags passed in Integer 0≤ x≤ 3, cf. p:dict.create. If bit +1 is set in x, creates an active word; if bit +2 is set in x, creates a prefix word."},
            {"(def?)", "(def?) ( S — ? )\nChecks whether the word S is defined."},
            {"(dump)", "(dump) ( x — S )\nReturns a String with a dump of the topmost stack value x, in the same format as employed by.dump."},
            {"(execute)", "(execute) ( x₁ … xₙ n e — … )\nExecutes execution token e, but first checks that there are at least 0≤ n≤ 255 values in the stack apart from n and e themselves. It is a counterpart of (compile) that may be used to immediately “execute” (perform the intended runtime action of) an active word after its immediate execution, as explained in p:active.words."},
            {"(forget)", "(forget) ( S — )\nForgets the word with the name specified in String S, cf. p:dict.create. If the word is not found, throws an exception."},
            {"(number)", "(number) ( S — 0 or x 1 or x y 2 )\nAttempts to parse the String S as an integer or fractional literal, cf. p:string.ops and p:int.lit. On failure, returns a single 0. On success, returns x 1 if S is a valid integer literal with value x, or x y 2 if S is a valid fractional literal with value x/y."},
            {"(x.)", "(x.) ( x — S )\nReturns the String with the hexadecimal representation of Integer x."},
            {"({)", "({) ( — l )\nPushes an empty WordList into the stack, cf. p:wordlist.ops"},
            {"(})", "(}) ( l — e )\nTransforms a WordList into an execution token ( WordDef ), making all further modifications impossible, cf. p:wordlist.ops."},
            {"*", "* ( x y — xy )\nComputes the product xy of two Integer s x and y, cf. p:arith.op."},
            {"*/", "*/ ( x y z — ⌊xy/z⌋ ), “multiply-then-divide”: multiplies two integers x and y producing a 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/c", "*/c ( x y z — ⌈xy/z⌉ ), “multiply-then-divide” with ceiling rounding: multiplies two integers x and y producing a 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/cmod", "*/cmod ( x y z — q r )\nSimilar to */c, but computes both the quotient q:= ⌈xy/z⌉ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*/mod", "*/mod ( x y z — q r )\nSimilar to */, but computes both the quotient q:= ⌊xy/z⌋ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*/r", "*/r ( x y z — q:= ⌊xy/z+½⌋ ), “multiply-then-divide” with nearest-integer rounding: multiplies two integers x and y with 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/rmod", "*/rmod ( x y z — q r )\nSimilar to */r, but computes both the quotient q:= ⌊xy/z+½⌋ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*>>", "*>> ( x y z — q )\nSimilar to */, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌊xy/2ᶻ ⌋ for 0≤ z≤ 256. Equivalent to 1<< */."},
            {"*>>c", "*>>c ( x y z — q )\nSimilar to */c, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌈xy/2ᶻ ⌉ for 0≤ z≤ 256. Equivalent to 1<< */c."},
            {"*>>r", "*>>r ( x y z — q )\nSimilar to */r, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌊xy/2ᶻ +½⌋ for 0≤ z≤ 256. Equivalent to 1<< */r."},
            {"*mod", "*mod ( x y z — r )\nSimilar to */mod, but computes only the remainder r:=xy-qz, where q:= ⌊xy/z⌋ . Equivalent to */mod nip."},
            {"+", "+ ( x y — x+y )\nComputes the sum x+y of two Integer s x and y, cf. p:arith.op."},
            {"+!", "+! ( x p — )\nIncreases the integer value stored in Box p by Integer x, cf. p:variables. Equivalent to tuck @ + swap !."},
            {"+\"", "+\"❬string❭\" ( S — S' )\nConcatenates String S with a string literal, cf. p:string.ops. Equivalent to \"❬string❭\" $+."},
            {",", ", ( t x — t' )\nAppends x to the end of Tuple t, and returns the resulting Tuple t', cf. p:tuples."},
            {"-", "- ( x y — x-y )\nComputes the difference x-y of two Integer s x and y, cf. p:arith.op."},
            {"-!", "-! ( x p — )\nDecreases the integer value stored in Box p by Integer x. Equivalent to swap negate swap +!."},
            {"-1", "-1 ( — -1 )\nPushes Integer -1."},
            {"-1<<", "-1<< ( x — -2ˣ )\nComputes -2ˣ for 0≤ x≤ 256. Approximately equivalent to 1<< negate or -1 swap <<, but works for x=256 as well."},
            {"-roll", "-roll ( xₙ … x₀ n — x₀ xₙ … x₁ )\nRotates the top n stack entries in the opposite direction, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 1 -roll is equivalent to swap, and 2 -roll to -rot."},
            {"-rot", "-rot ( x y z — z x y )\nRotates the three topmost stack entries in the opposite direction, cf. p:stack.ops. Equivalent to rot rot."},
            {"-trailing", "-trailing ( S — S' )\nRemoves from String S all trailing spaces. Equivalent to bl (-trailing)."},
            {"-trailing0", "-trailing0 ( S — S' )\nRemoves from String S all trailing ` 0 ' characters. Equivalent to char 0 (-trailing)."},
            {".", ". ( x — )\nPrints the decimal representation of Integer x, followed by a single space, cf. p:arith.op. Equivalent to._space."},
            {".\"", ".\"❬string❭\" ( — )\nPrints a constant string into the standard output, cf. p:string.ops."},
            {"._", "._ ( x — )\nPrints the decimal representation of Integer x without any spaces. Equivalent to (.) type."},
            {".dump", ".dump ( x — )\nDumps the topmost stack entry in the same way as.s dumps all stack elements, cf. p:tuples. Equivalent to (dump) type space."},
            {".l", ".l ( l — )\nPrints a Lisp-style list l, cf. p:lists."},
            {".s", ".s ( — )\nDumps all stack entries starting from the deepest, leaving them intact, cf. p:stack.ops. Human-readable representations of stack entries are output separated by spaces, followed by an end-of-line character."},
            {".sl", ".sl ( — )\nDumps all stack entries leaving them intact similarly to.s, but showing each entry as a List-style list l as.l does."},
            {".tc", ".tc ( — )\nOutputs the total number of allocated cells into the standard error stream."},
            {"/", "/ ( x y — q:= ⌊x/y⌋ )\nComputes the floor-rounded quotient ⌊x/y⌋ of two Integer s, cf. p:arith.op."},
            {"/*❬multiline-comment❭*/", "/*❬multiline-comment❭*/ ( — )\nSkips a multi-line comment delimited by word “ */ ” (followed by a blank or an end-of-line character), cf. p:comments."},
            {"//❬comment-to-eol❭", "//❬comment-to-eol❭ ( — )\nSkips a single-line comment until the end of the current line, cf. p:comments."},
            {"/c", "/c ( x y — q:= ⌈x/y⌉ )\nComputes the ceiling-rounded quotient ⌈x/y⌉ of two Integer s, cf. p:arith.op."},
            {"/cmod", "/cmod ( x y — q r )\nComputes both the ceiling-rounded quotient q:= ⌈x/y⌉ and the remainder r:=x-qy, cf. p:arith.op."},
            {"/mod", "/mod ( x y — q r )\nComputes both the floor-rounded quotient q:= ⌊x/y⌋ and the remainder r:=x-qy, cf. p:arith.op."},
            {"/r", "/r ( x y — q )\nComputes the nearest-integer-rounded quotient ⌊x/y+½⌋ of two Integer s, cf. p:arith.op."},
            {"/rmod", "/rmod ( x y — q r )\nComputes both the nearest-integer-rounded quotient q:= ⌊x/y+½⌋ and the remainder r:=x-qy, cf. p:arith.op."},
            {"0", "0 ( — 0 )\nPushes Integer 0."},
            {"0!", "0! ( p — )\nStores Integer 0 into Box p, cf. p:variables. Equivalent to 0 swap !."},
            {"0<", "0< ( x — ? )\nChecks whether x<0 (i.e., pushes -1 if x is negative, 0 otherwise), cf. p:int.comp. Equivalent to 0 <."},
            {"0<=", "0<= ( x — ? )\nChecks whether x≤0 (i.e., pushes -1 if x is non-positive, 0 otherwise), cf. p:int.comp. Equivalent to 0 <=."},
            {"0<>", "0<> ( x — ? )\nChecks whether x≠0 (i.e., pushes -1 if x is non-zero, 0 otherwise), cf. p:int.comp. Equivalent to 0 <>."},
            {"0=", "0= ( x — ? )\nChecks whether x=0 (i.e., pushes -1 if x is zero, 0 otherwise), cf. p:int.comp. Equivalent to 0 =."},
            {"0>", "0> ( x — ? )\nChecks whether x>0 (i.e., pushes -1 if x is positive, 0 otherwise), cf. p:int.comp. Equivalent to 0 >."},
            {"0>=", "0>= ( x — ? )\nChecks whether x≥0 (i.e., pushes -1 if x is non-negative, 0 otherwise), cf. p:int.comp. Equivalent to 0 >=."},
            {"1", "1 ( — 1 )\nPushes Integer 1."},
            {"1+", "1+ ( x — x+1 )\nComputes x+1. Equivalent to 1 +."},
            {"1+!", "1+! ( p — )\nIncreases the integer value stored in Box p by one, cf. p:variables. Equivalent to 1 swap +!."},
            {"1-", "1- ( x — x-1 )\nComputes x-1. Equivalent to 1 -."},
            {"1-!", "1-! ( p — )\nDecreases the integer value stored in Box p by one. Equivalent to -1 swap +!."},
            {"1<<", "1<< ( x — 2ˣ )\nComputes 2ˣ for 0≤ x≤ 255. Equivalent to 1 swap <<."},
            {"1<<1-", "1<<1- ( x — 2ˣ -1 )\nComputes 2ˣ -1 for 0≤ x≤ 256. Almost equivalent to 1<< 1-, but works for x=256."},
            {"2", "2 ( — 2 )\nPushes Integer 2."},
            {"2*", "2* ( x — 2x )\nComputes 2x. Equivalent to 2 *."},
            {"2+", "2+ ( x — x+2 )\nComputes x+2. Equivalent to 2 +."},
            {"2-", "2- ( x — x-2 )\nComputes x-2. Equivalent to 2 -."},
            {"2/", "2/ ( x — ⌊x/2⌋ )\nComputes ⌊x/2⌋ . Equivalent to 2 / or to 1 >>."},
            {"2=:❬word-name❭", "2=:❬word-name❭ ( x y — )\nAn active variant of 2constant: defines a new ordinary word ❬word-name❭ that would push the given values x and y when invoked, cf. p:constants."},
            {"2constant", "2constant ( x y — )\nScans a blank-delimited word name S from the remainder of the input, and defines a new ordinary word S as a double constant, which will push the given values x and y (of arbitrary types) when invoked, cf. p:dict.create."},
            {"2drop", "2drop ( x y — )\nRemoves the two topmost stack entries, cf. p:stack.ops. Equivalent to drop drop."},
            {"2dup", "2dup ( x y — x y x y )\nDuplicates the topmost pair of stack entries, cf. p:stack.ops. Equivalent to over over."},
            {"2over", "2over ( x y z w — x y z w x y )\nDuplicates the second topmost pair of stack entries."},
            {"2swap", "2swap ( a b c d — c d a b )\nInterchanges the two topmost pairs of stack entries, cf. p:stack.ops."},
            {":❬word-name❭", ":❬word-name❭ ( e — )\nDefines a new ordinary word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"::❬word-name❭", "::❬word-name❭ ( e — )\nDefines a new active word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"::_❬word-name❭", "::_❬word-name❭ ( e — )\nDefines a new active prefix word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {":_❬word-name❭", ":_❬word-name❭ ( e — )\nDefines a new ordinary prefix word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"<", "< ( x y — ? )\nChecks whether x<y (i.e., pushes -1 if Integer x is less than Integer y, 0 otherwise), cf. p:int.comp."},
            {"<#", "<# ( — S )\nPushes an empty String. Typically used for starting the conversion of an Integer into its human-readable representation, decimal or in another base. Equivalent to \"\"."},
            {"<<", "<< ( x y — x⋅ 2ʸ )\nComputes an arithmetic left shift of binary number x by y≥0 positions, yielding x⋅ 2ʸ , cf. p:arith.op."},
            {"<</", "<</ ( x y z — q )\nComputes q:= ⌊2ᶻ x/y⌋ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */, cf. p:arith.op. Equivalent to 1<< swap */."},
            {"<</c", "<</c ( x y z — q )\nComputes q:= ⌈2ᶻ x/y⌉ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */c, cf. p:arith.op. Equivalent to 1<< swap */c."},
            {"<</r", "<</r ( x y z — q )\nComputes q:= ⌊2ᶻ x/y+½⌋ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */r, cf. p:arith.op. Equivalent to 1<< swap */r."},
            {"<=", "<= ( x y — ? )\nChecks whether x≤ y (i.e., pushes -1 if Integer x is less than or equal to Integer y, 0 otherwise), cf. p:int.comp."},
            {"<>", "<> ( x y — ? )\nChecks whether x≠ y (i.e., pushes -1 if Integer s x and y are not equal, 0 otherwise), cf. p:int.comp."},
            {"<b", "<b ( — b )\nCreates a new empty Builder, cf. p:builder.ops."},
            {"<s", "<s ( c — s )\nTransforms a Cell c into a Slice s containing the same data, cf. p:slice.ops. It usually marks the start of the deserialization of a cell."},
            {"=", "= ( x y — ? )\nChecks whether x=y (i.e., pushes -1 if Integer s x and y are equal, 0 otherwise), cf. p:int.comp."},
            {"=:❬word-name❭", "=:❬word-name❭ ( x — )\nAn active variant of constant: defines a new ordinary word ❬word-name❭ that would push the given value x when invoked, cf. p:constants."},
            {">", "> ( x y — ? )\nChecks whether x>y (i.e., pushes -1 if Integer x is greater than Integer y, 0 otherwise), cf. p:int.comp."},
            {">=", ">= ( x y — ? )\nChecks whether x≥ y (i.e., pushes -1 if Integer x is greater than or equal to Integer y, 0 otherwise), cf. p:int.comp."},
            {">>", ">> ( x y — q:= ⌊x⋅ 2⁻ʸ ⌋ )\nComputes an arithmetic right shift of binary number x by 0≤ y≤ 256 positions, cf. p:arith.op. Equivalent to 1<< /."},
            {">>c", ">>c ( x y — q:= ⌈x⋅ 2⁻ʸ ⌉ )\nComputes the ceiling-rounded quotient q of x by 2ʸ for 0≤ y≤ 256, cf. p:arith.op. Equivalent to 1<< /c."},
            {">>r", ">>r ( x y — q:= ⌊x⋅ 2⁻ʸ +½⌋ )\nComputes the nearest-integer-rounded quotient q of x by 2ʸ for 0≤ y≤ 256, cf. p:arith.op. Equivalent to 1<< /r."},
            {"?dup", "?dup ( x — x x or 0 )\nDuplicates an Integer x, but only if it is non-zero, cf. p:stack.ops. Otherwise leaves it intact."},
            {"@", "@ ( p — x )\nFetches the value currently stored in Box p, cf. p:variables."},
            {"@'❬word-name❭", "@'❬word-name❭ ( — e )\nRecovers the definition of the specified word at execution time, performing a dictionary lookup each time it is invoked, and then executes this definition, cf. p:constants and p:dict.lookup. May be used to recover current values of constants inside word definitions and other blocks by using the phrase @'❬word-name❭, equivalent to (')❬word-name❭execute."},
            {"B+", "B+ ( B' B” — B )\nConcatenates two Bytes values, cf. p:bytes.ops."},
            {"B,", "B, ( b B — b' )\nAppends Bytes B to Builder b, cf. p:builder.ops. If there is no room in b for B, throws an exception."},
            {"B=", "B= ( B B' — ? )\nChecks whether two Bytes sequences are equal, and returns -1 or 0 depending on the comparison outcome, cf. p:bytes.ops."},
            {"B>Li@", "B>Li@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as a signed little-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>Li@+", "B>Li@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as a signed little-endian x -bit Integer y similarly to B>Li@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>Lu@", "B>Lu@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as an unsigned little-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>Lu@+", "B>Lu@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as an unsigned little-endian x -bit Integer y similarly to B>Lu@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>boc", "B>boc ( B — c )\nDeserializes a “standard” bag of cells (i.e., a bag of cells with exactly one root cell) represented by Bytes B, and returns the root Cell c, cf. p:boc.ops."},
            {"B>file", "B>file ( B S — )\nCreates a new (binary) file with the name specified in String S and writes data from Bytes B into the new file, cf. p:bytes.ops. If the specified file already exists, it is overwritten."},
            {"B>i@", "B>i@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as a signed big-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>i@+", "B>i@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as a signed big-endian x -bit Integer y similarly to B>i@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>u@", "B>u@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as an unsigned big-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>u@+", "B>u@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as an unsigned big-endian x -bit Integer y similarly to B>u@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B@", "B@ ( s x — B )\nFetches the first x bytes (i.e., 8x bits) from Slice s, and returns them as a Bytes value B, cf. p:slice.ops. If there are not enough data bits in s, throws an exception."},
            {"B@+", "B@+ ( s x — B s' )\nSimilar to B@, but returns the remainder of Slice s as well, cf. p:slice.ops."},
            {"B@?", "B@? ( s x — B -1 or 0 )\nSimilar to B@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"B@?+", "B@?+ ( s x — B s' -1 or s 0 )\nSimilar to B@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"Bcmp", "Bcmp ( B B' — x )\nLexicographically compares two Bytes sequences, and returns -1, 0, or 1, depending on the comparison result, cf. p:bytes.ops."},
            {"Bhash", "Bhash ( B — x )\nDeprecated version of Bhashu. Use Bhashu or BhashB instead."},
            {"BhashB", "BhashB ( B — B' )\nComputes the SHA256 hash of a Bytes value, cf. p:bytes.ops. The hash is returned as a 32-byte Bytes value."},
            {"Bhashu", "Bhashu ( B — x )\nComputes the SHA256 hash of a Bytes value, cf. p:bytes.ops. The hash is returned as a big-endian unsigned 256-bit Integer value."},
            {"Blen", "Blen ( B — x )\nReturns the length of a Bytes value B in bytes, cf. p:bytes.ops."},
            {"Bx.", "Bx. ( B — )\nPrints the hexadecimal representation of a Bytes value, cf. p:bytes.ops. Each byte is represented by exactly two uppercase hexadecimal digits."},
            {"B{❬{hex-digits}❭}", "B{❬{hex-digits}❭} ( — B )\nPushes a Bytes literal containing data represented by an even number of hexadecimal digits, cf. p:bytes.ops."},
            {"B|", "B| ( B x — B' B” )\nCuts the first x bytes from a Bytes value B, and returns both the first x bytes ( B' ) and the remainder ( B” ) as new Bytes values, cf. p:bytes.ops."},
            {"Li>B", "Li>B ( x y — B )\nStores a signed little-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"Lu>B", "Lu>B ( x y — B )\nStores an unsigned little-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"[", "[ ( — )\nOpens an internal interpreter session even if state is greater than zero, i.e., all subsequent words are executed immediately instead of being compiled."},
            {"[]", "[] ( t i — x )\nReturns the (i+1) -st component t_{i+1} of Tuple t, where 0≤ i<|t|, cf. p:tuples."},
            {"[compile]❬word-name❭", "[compile]❬word-name❭ ( — )\nCompiles ❬word-name❭ as if it were an ordinary word, even if it is active, cf. p:dict.lookup. Essentially equivalent to '❬word-name❭execute."},
            {"]", "] ( x₁ … xₙ n — )\nCloses an internal interpreter session opened by [ and invokes (compile) or (execute) afterwards depending on whether state is greater than zero. For instance, {[2 3 + 1]* } is equivalent to { 5 * }."},
            {"`❬word❭", "`❬word❭ ( — a )\nIntroduces an Atom literal, equal to the only Atom with the name equal to ❬word❭, cf. p:atoms. Equivalent to \"❬word❭\" atom."},
            {"abort", "abort ( S — )\nThrows an exception with an error message taken from String S, cf. p:exception.ops."},
            {"abort\"❬message❭\"", "abort\"❬message❭\" ( x — )\nThrows an exception with the error message ❬message❭ if the Integer x is non-zero, cf. p:exception.ops."},
            {"abs", "abs ( x — |x| )\nComputes the absolute value |x|=max(x,-x) of Integer x. Equivalent to dup negate max."},
            {"allot", "allot ( n — t )\nCreates a new array, i.e., a Tuple that consists of n new empty Box es, cf. p:tuples. Equivalent to | { hole, } rot times."},
            {"and", "and ( x y — x& y )\nComputes the bitwise AND of two Integer s, cf. p:arith.op."},
            {"anon", "anon ( — a )\nCreates a new unique anonymous Atom, cf. p:atoms."},
            {"atom", "atom ( S — a )\nReturns the only Atom a with the name S, creating such an atom if necessary, cf. p:atoms. Equivalent to true (atom) drop."},
            {"atom?", "atom? ( u — ? )\nChecks whether u is an Atom, cf. p:atoms."},
            {"b+", "b+ ( b b' — b” )\nConcatenates two Builders b and b', cf. p:builder.ops."},
            {"b.", "b. ( x — )\nPrints the binary representation of an Integer x, followed by a single space. Equivalent to b._space."},
            {"b._", "b._ ( x — )\nPrints the binary representation of an Integer x without any spaces. Equivalent to (b.) type."},
            {"b>", "b> ( b — c )\nTransforms a Builder b into a new Cell c containing the same data as b, cf. p:builder.ops."},
            {"b>idict!", "b>idict! ( v x s n — s' -1 or s 0 )\nAdds a new value v (represented by a Builder ) with key given by signed big-endian n -bit integer x into dictionary s with n -bit keys, and returns the new dictionary s' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary s and 0 are returned."},
            {"b>idict!+", "b>idict!+ ( v x s n — s' -1 or s 0 )\nAdds a new key-value pair (x,v) into dictionary s similarly to b>idict!, but fails if the key already exists by returning the unchanged dictionary s and 0, cf. p:hashmap.ops."},
            {"b>udict!", "b>udict! ( v x s n — s' -1 or s 0 )\nAdds a new value v (represented by a Builder ) with key given by unsigned big-endian n -bit integer x into dictionary s with n -bit keys, and returns the new dictionary s' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary s and 0 are returned."},
            {"b>udict!+", "b>udict!+ ( v x s n — s' -1 or s 0 )\nAdds a new key-value pair (x,v) into dictionary s similarly to b>udict!, but fails if the key already exists by returning the unchanged dictionary s and 0, cf. p:hashmap.ops."},
            {"bbitrefs", "bbitrefs ( b — x y )\nReturns both the number of data bits x and the number of references y already stored in Builder b, cf. p:builder.ops."},
            {"bbits", "bbits ( b — x )\nReturns the number of data bits already stored in Builder b. The result x is an Integer in the range 0…1023, cf. p:builder.ops."},
            {"bl", "bl ( — x )\nPushes the Unicode codepoint of a space, i.e., 32, cf. p:string.ops."},
            {"boc+>B", "boc+>B ( c x — B )\nCreates and serializes a “standard” bag of cells, containing one root Cell c along with all its descendants, cf. p:boc.ops. An Integer parameter 0≤ x≤ 31 is used to pass flags indicating the additional options for bag-of-cells serialization, with individual bits having the following effect: +1enables bag-of-cells index creation (useful for lazy deserialization of large bags of cells).+2includes the CRC32-C of all data into the serialization (useful for checking data integrity).+4explicitly stores the hash of the root cell into the serialization (so that it can be quickly recovered afterwards without a complete deserialization).+8stores hashes of some intermediate (non-leaf) cells (useful for lazy deserialization of large bags of cells).+16stores cell cache bits to control caching of deserialized cells. Typical values of x are x=0 or x=2 for very small bags of cells (e.g., TON Blockchain external messages) and x=31 for large bags of cells (e.g., TON Blockchain blocks)."},
            {"boc>B", "boc>B ( c — B )\nSerializes a small “standard” bag of cells with root Cell c and all its descendants, cf. p:boc.ops. Equivalent to 0 boc+>B."},
            {"box", "box ( x — p )\nCreates a new Box containing specified value x, cf. p:variables. Equivalent to hole tuck !."},
            {"brefs", "brefs ( b — x )\nReturns the number of references already stored in Builder b, cf. p:builder.ops. The result x is an Integer in the range 0…4."},
            {"brembitrefs", "brembitrefs ( b — x y )\nReturns both the maximum number of additional data bits 0≤ x≤ 1023 and the maximum number of additional cell references 0≤ y≤ 4 that can be stored in Builder b, cf. p:builder.ops."},
            {"brembits", "brembits ( b — x )\nReturns the maximum number of additional data bits that can be stored in Builder b, cf. p:builder.ops. Equivalent to bbits 1023 swap -."},
            {"bremrefs", "bremrefs ( b — x )\nReturns the maximum number of additional cell references that can be stored in Builder b, cf. p:builder.ops."},
            {"bye", "bye ( — )\nQuits the Fift interpreter to the operating system with a zero exit code, cf. p:exit.fift. Equivalent to 0 halt."},
            {"b{❬binary-data❭}", "b{❬binary-data❭} ( — s )\nCreates a Slice s that contains no references and up to 1023 data bits specified in ❬binary-data❭, which must be a string consisting only of the characters ` 0 ' and ` 1 ', cf. p:slice.lit."},
            {"caddr", "caddr ( l — h” )\nReturns the third element of a list. Equivalent to cddr car."},
            {"cadr", "cadr ( l — h' )\nReturns the second element of a list, cf. p:lists. Equivalent to cdr car."},
            {"car", "car ( l — h )\nReturns the head of a list, cf. p:lists. Equivalent to first."},
            {"cddr", "cddr ( l — t' )\nReturns the tail of the tail of a list. Equivalent to cdr cdr."},
            {"cdr", "cdr ( l — t )\nReturns the tail of a list, cf. p:lists. Equivalent to second."},
            {"char❬string❭", "char❬string❭ ( — x )\nPushes an Integer with the Unicode codepoint of the first character of ❬string❭, cf. p:string.ops. For instance, char * is equivalent to 42."},
            {"chr", "chr ( x — S )\nReturns a new String S consisting of one UTF-8 encoded character with Unicode codepoint x."},
            {"cmp", "cmp ( x y — z )\nCompares two Integer s x and y, and pushes 1 if x>y, -1 if x<y, and 0 if x=y, cf. p:int.comp. Approximately equivalent to - sgn."},
            {"cond", "cond ( x e e' — )\nIf Integer x is non-zero, executes e, otherwise executes e', cf. p:cond.ops."},
            {"cons", "cons ( h t — l )\nConstructs a list from its head (first element) h and its tail (the list consisting of all remaining elements) t, cf. p:lists. Equivalent to pair."},
            {"constant", "constant ( x — )\nScans a blank-delimited word name S from the remainder of the input, and defines a new ordinary word S as a constant, which will push the given value x (of arbitrary type) when invoked, cf. p:dict.create and p:constants."},
            {"count", "count ( t — n )\nReturns the length n=|t| of Tuple t, cf. p:tuples."},
            {"cr", "cr ( — )\nOutputs a carriage return (or a newline character) into the standard output, cf. p:string.ops."},
            {"create", "create ( e — )\nDefines a new ordinary word with the name equal to the next word scanned from the input, using WordDef e as its definition, cf. p:dict.create. If the word already exists, it is tacitly redefined."},
            {"csr.", "csr. ( s — )\nRecursively prints a Slice s, cf. p:slice.ops. On the first line, the data bits of s are displayed in hexadecimal form embedded into an x{…} construct similar to the one used for Slice literals (cf. p:slice.lit ). On the next lines, the cells referred to by s are printed with larger indentation."},
            {"def?❬word-name❭", "def?❬word-name❭ ( — ? )\nChecks whether the word ❬word-name❭ is defined at execution time, and returns -1 or 0 accordingly."},
            {"depth", "depth ( — n )\nReturns the current depth (the total number of entries) of the Fift stack as an Integer n≥0."},
            {"dictmap", "dictmap ( D n e — D' )\nApplies execution token e (i.e., an anonymous function) to each of the key-value pairs stored in a dictionary D with n -bit keys, cf. p:hashmap.ops. The execution token is executed once for each key-value pair, with a Builder b and a Slice v (containing the value) pushed into the stack before executing e. After the execution e must leave in the stack either a modified Builder b' (containing all data from b along with the new value v' ) and -1, or 0 indicating failure. In the latter case, the corresponding key is omitted from the new dictionary."},
            {"dictmerge", "dictmerge ( D D' n e — D” )\nCombines two dictionaries D and D' with n -bit keys into one dictionary D” with the same keys, cf. p:hashmap.ops. If a key is present in only one of the dictionaries D and D', this key and the corresponding value are copied verbatim to the new dictionary D”. Otherwise the execution token (anonymous function) e is invoked to merge the two values v and v' corresponding to the same key k in D and D', respectively. Before e is invoked, a Builder b and two Slice s v and v' representing the two values to be merged are pushed. After the execution e leaves either a modified Builder b' (containing the original data from b along with the combined value) and -1, or 0 on failure. In the latter case, the corresponding key is omitted from the new dictionary."},
            {"dictnew", "dictnew ( — D )\nPushes the Null value that represents a new empty dictionary, cf. p:hashmap.ops. Equivalent to null."},
            {"does", "does ( x₁ … xₙ n e — e' )\nCreates a new execution token e' that would push n values x₁, …, xₙ into the stack and then execute e when invoked, cf. p:wordlist.ops. It is roughly equivalent to a combination of ({), (compile), and (})."},
            {"drop", "drop ( x — )\nRemoves the top-of-stack entry, cf. p:stack.ops."},
            {"dup", "dup ( x — x x )\nDuplicates the top-of-stack entry, cf. p:stack.ops. If the stack is empty, throws an exception."},
            {"ed25519_chksign", "ed25519_chksign ( B B' B” — ? )\nChecks whether B' is a valid Ed25519-signature of data B with the public key B”, cf. p:ed25519.ops."},
            {"ed25519_sign", "ed25519_sign ( B B' — B” )\nSigns data B with the Ed25519 private key B' (a 32-byte Bytes value) and returns the signature as a 64-byte Bytes value B”, cf. p:ed25519.ops."},
            {"ed25519_sign_uint", "ed25519_sign_uint ( x B' — B” )\nConverts a big-endian unsigned 256-bit integer x into a 32-byte sequence and signs it using the Ed25519 private key B' similarly to ed25519_sign, cf. p:ed25519.ops. Equivalent to swap 256 u>B swap ed25519_sign. The integer x to be signed is typically computed as the hash of some data."},
            {"emit", "emit ( x — )\nPrints a UTF-8 encoded character with Unicode codepoint given by Integer x into the standard output, cf. p:string.ops. For instance, 42 emit prints an asterisk “ * ”, and 916 emit prints a Greek Delta “ Δ ”. Equivalent to chr type."},
            {"empty?", "empty? ( s — ? )\nChecks whether a Slice is empty (i.e., has no data bits and no references left), and returns -1 or 0 accordingly, cf. p:slice.ops."},
            {"eq?", "eq? ( u v — ? )\nChecks whether u and v are equal Integer s, Atom s, or Null s, cf. p:atoms. If they are not equal, or if they are of different types, or not of one of the types listed, returns zero."},
            {"exch", "exch ( xₙ … x₀ n — x₀ … xₙ )\nInterchanges the top of the stack with the n -th stack entry from the top, where n≥0 is also taken from the stack, cf. p:stack.ops. In particular, 1 exch is equivalent to swap, and 2 exch to swap rot."},
            {"exch2", "exch2 ( … n m — … )\nInterchanges the n -th stack entry from the top with the m -th stack entry from the top, where n≥0, m≥0 are taken from the stack, cf. p:stack.ops."},
            {"execute", "execute ( e — … )\nExecutes the execution token ( WordDef ) e, cf. p:blocks."},
            {"explode", "explode ( t — x₁ … xₙ n )\nUnpacks a Tuple t=(x₁,…,xₙ) of unknown length n, and returns that length, cf. p:tuples."},
            {"false", "false ( — 0 )\nPushes 0 into the stack, cf. p:bool. Equivalent to 0."},
            {"file-exists?", "file-exists? ( S — ? )\nChecks whether the file with the name specified in String S exists, cf. p:bytes.ops."},
            {"file>B", "file>B ( S — B )\nReads the (binary) file with the name specified in String S and returns its contents as a Bytes value, cf. p:bytes.ops. If the file does not exist, an exception is thrown."},
            {"find", "find ( S — e -1 or e 1 or 0 )\nLooks up String S in the dictionary and returns its definition as a WordDef e if found, followed by -1 for ordinary words or 1 for active words, cf. p:dict.lookup. Otherwise pushes 0."},
            {"first", "first ( t — x )\nReturns the first component of a Tuple, cf. p:tuples. Equivalent to 0[]."},
            {"fits", "fits ( x y — ? )\nChecks whether Integer x is a signed y -bit integer (i.e., whether -2ʸ⁻¹ ≤ x<2ʸ⁻¹ for 0≤ y≤ 1023 ), and returns -1 or 0 accordingly."},
            {"forget", "forget ( — )\nForgets (removes from the dictionary) the definition of the next word scanned from the input, cf. p:dict.create."},
            {"gasrunvm", "gasrunvm ( … s c z — … x c' z' )\nA gas-aware version of runvm, cf. p:tvm.ops: invokes a new instance of TVM with both the current continuation cc and the special register c3 initialized from Slice s, and initializes special register c4 (the “root of persistent data”, cf. [ 1.4 ] ) with Cell c. Then starts the new TVM instance with the gas limit set to z. The actually consumed gas z' is returned at the top of the final Fift stack, and the final value of c4 is returned immediately below the top of the final Fift stack as another Cell c'."},
            {"gasrunvmcode", "gasrunvmcode ( … s z — … x z' )\nA gas-aware version of runvmcode, cf. p:tvm.ops: invokes a new instance of TVM with the current continuation cc initialized from Slice s and with the gas limit set to z, thus executing code s in TVM. The original Fift stack (without s ) is passed in its entirety as the initial stack of the new TVM instance. When TVM terminates, its resulting stack is used as the new Fift stack, with the exit code x and the actually consumed gas z' pushed at its top. If x is non-zero, indicating that TVM has been terminated by an unhandled exception, the next stack entry from the top contains the parameter of this exception, and x is the exception code. All other entries are removed from the stack in this case."},
            {"gasrunvmctx", "gasrunvmctx ( … s c t z — … x c' z' )\nA gas-aware version of runvmctx, cf. p:tvm.ops. Differs from gasrunmv in that it initializes c7 with Tuple t."},
            {"gasrunvmdict", "gasrunvmdict ( … s z — … x z' )\nA gas-aware version of runvmdict, cf. p:tvm.ops: invokes a new instance of TVM with the current continuation cc initialized from Slice s and sets the gas limit to z similarly to gasrunvmcode, but also initializes the special register c3 with the same value, and pushes a zero into the initial TVM stack before the TVM execution begins. The actually consumed gas is returned as an Integer z'. In a typical application Slice s consists of a subroutine selection code that uses the top-of-stack Integer to select the subroutine to be executed, thus enabling the definition and execution of several mutually-recursive subroutines (cf. [ 4.6 ] and p:asm.prog ). The selector equal to zero corresponds to the main() subroutine in a large TVM program."},
            {"halt", "halt ( x — )\nQuits to the operating system similarly to bye, but uses Integer x as the exit code, cf. p:exit.fift."},
            {"hash", "hash ( c — x )\nA deprecated version of hashu. Use hashu or hashB instead."},
            {"hashB", "hashB ( c — B )\nComputes the SHA256 -based representation hash of Cell c (cf. [ 3.1 ] ), which unambiguously defines c and all its descendants (provided there are no collisions for SHA256 ), cf. p:hash.ops. The result is returned as a Bytes value consisting of exactly 32 bytes."},
            {"hashu", "hashu ( c — x )\nComputes the SHA256 -based representation hash of Cell c similarly to hashB, but returns the result as a big-endian unsigned 256-bit Integer."},
            {"hold", "hold ( S x — S' )\nAppends to String S one UTF-8 encoded character with Unicode codepoint x. Equivalent to chr $+."},
            {"hole", "hole ( — p )\nCreates a new Box p that does not hold any value, cf. p:variables. Equivalent to null box."},
            {"i,", "i, ( b x y — b' )\nAppends the big-endian binary representation of a signed y -bit integer x to Builder b, where 0≤ y≤ 257, cf. p:builder.ops. If there is not enough room in b (i.e., if b already contains more than 1023-y data bits), or if Integer x does not fit into y bits, an exception is thrown."},
            {"i>B", "i>B ( x y — B )\nStores a signed big-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"i@", "i@ ( s x — y )\nFetches a signed big-endian x -bit integer from the first x bits of Slice s, cf. p:slice.ops. If s contains less than x data bits, an exception is thrown."},
            {"i@+", "i@+ ( s x — y s' )\nFetches a signed big-endian x -bit integer from the first x bits of Slice s similarly to i@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"i@?", "i@? ( s x — y -1 or 0 )\nFetches a signed big-endian integer from a Slice similarly to i@, but pushes integer -1 afterwards on success, cf. p:slice.ops. If there are less than x bits left in s, pushes integer 0 to indicate failure."},
            {"i@?+", "i@?+ ( s x — y s' -1 or s 0 )\nFetches a signed big-endian integer from Slice s and computes the remainder of this Slice similarly to i@+, but pushes -1 afterwards to indicate success, cf. p:slice.ops. On failure, pushes the unchanged Slice s and 0 to indicate failure."},
            {"idict!", "idict! ( v x D n — D' -1 or D 0 )\nAdds a new value v (represented by a Slice ) with key given by signed big-endian n -bit integer x into dictionary D with n -bit keys, and returns the new dictionary D' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary D and 0 are returned."},
            {"idict!+", "idict!+ ( v x D n — D' -1 or D 0 )\nAdds a new key-value pair (x,v) into dictionary D similarly to idict!, but fails if the key already exists by returning the unchanged dictionary D and 0, cf. p:hashmap.ops."},
            {"idict@", "idict@ ( x D n — v -1 or 0 )\nLooks up key represented by signed big-endian n -bit Integer x in the dictionary represented by Cell or Null D, cf. p:hashmap.ops. If the key is found, returns the corresponding value as a Slice v and -1. Otherwise returns 0."},
            {"if", "if ( x e — )\nExecutes execution token (i.e., a WordDef ) e, but only if Integer x is non-zero, cf. p:cond.ops."},
            {"ifnot", "ifnot ( x e — )\nExecutes execution token e, but only if Integer x is zero, cf. p:cond.ops."},
            {"include", "include ( S — )\nLoads and interprets a Fift source file from the path given by String S, cf. p:asm.load. If the filename S does not begin with a slash, the Fift include search path, typically taken from the FIFTPATH environment variable or the -I command-line argument of the Fift interpreter (and equal to /usr/lib/fift if both are absent), is used to locate S."},
            {"list", "list ( x₁ … xₙ n — l )\nConstructs a list l of length n with elements x₁, …, xₙ, in that order, cf. p:lists. Equivalent to null ' cons rot times."},
            {"max", "max ( x y — z )\nComputes the maximum z:=max(x,y) of two Integer s x and y. Equivalent to minmax nip."},
            {"min", "min ( x y — z )\nComputes the minimum z:=min(x,y) of two Integer s x and y. Equivalent to minmax drop."},
            {"minmax", "minmax ( x y — z t )\nComputes both the minimum z:=min(x,y) and the maximum t:=max(x,y) of two Integer s x and y."},
            {"mod", "mod ( x y — r:=x mod y )\nComputes the remainder x mod y=x-y⋅ ⌊x/y⌋ of division of x by y, cf. p:arith.op."},
            {"negate", "negate ( x — -x )\nChanges the sign of an Integer, cf. p:arith.op."},
            {"newkeypair", "newkeypair ( — B B' )\nGenerates a new Ed25519 private/public key pair, and returns both the private key B and the public key B' as 32-byte Bytes values, cf. p:ed25519.ops. The quality of the keys is good enough for testing purposes. Real applications must feed enough entropy into OpenSSL PRNG before generating Ed25519 keypairs."},
            {"nil", "nil ( — t )\nPushes the empty Tuple t=(). Equivalent to 0 tuple."},
            {"nip", "nip ( x y — y )\nRemoves the second stack entry from the top, cf. p:stack.ops. Equivalent to swap drop."},
            {"nop", "nop ( — )\nDoes nothing, cf. p:dict.lookup."},
            {"not", "not ( x — -1-x )\nComputes the bitwise complement of an Integer, cf. p:arith.op."},
            {"now", "now ( — x )\nReturns the current Unixtime as an Integer, cf. p:ed25519.ops."},
            {"null", "null ( — ot )\nPushes the Null value, cf. p:lists"},
            {"null!", "null! ( p — )\nStores a Null value into Box p. Equivalent to null swap !."},
            {"null?", "null? ( x — ? )\nChecks whether x is Null, cf. p:lists."},
            {"or", "or ( x y — x|y )\nComputes the bitwise OR of two Integer s, cf. p:arith.op."},
            {"over", "over ( x y — x y x )\nCreates a copy of the second stack entry from the top over the top-of-stack entry, cf. p:stack.ops."},
            {"pair", "pair ( x y — t )\nCreates new pair t=(x,y), cf. p:tuples. Equivalent to 2 tuple or to | rot, swap,."},
            {"pfxdict!", "pfxdict! ( v k s n — s' -1 or s 0 )\nAdds key-value pair (k,v), both represented by Slice s, into a prefix dictionary s with keys of length at most n, cf. p:hashmap.ops. On success, returns the modified dictionary s' and -1. On failure, returns the original dictionary s and 0."},
            {"pfxdict!+", "pfxdict!+ ( v k s n — s' -1 or s 0 )\nAdds key-value pair (k,v) into prefix dictionary s similarly to pfxdict!, but fails if the key already exists, cf. p:hashmap.ops."},
            {"pfxdict@", "pfxdict@ ( k s n — v -1 or 0 )\nLooks up key k (represented by a Slice ) in the prefix dictionary s with the length of keys limited by n bits, cf. p:hashmap.ops. On success, returns the value found as a Slice v and -1. On failure, returns 0."},
            {"pick", "pick ( xₙ … x₀ n — xₙ … x₀ xₙ )\nCreates a copy of the n -th entry from the top of the stack, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 0 pick is equivalent to dup, and 1 pick to over."},
            {"priv>pub", "priv>pub ( B — B' )\nComputes the public key corresponding to a private Ed25519 key, cf. p:ed25519.ops. Both the public key B' and the private key B are represented by 32-byte Bytes values."},
            {"quit", "quit ( … — )\nExits to the topmost level of the Fift interpreter (without printing an ok in interactive mode) and clears the stack, cf. p:exit.fift."},
            {"ref,", "ref, ( b c — b' )\nAppends to Builder b a reference to Cell c, cf. p:builder.ops. If b already contains four references, an exception is thrown."},
            {"ref@", "ref@ ( s — c )\nFetches the first reference from the Slice s and returns the Cell c referred to, cf. p:slice.ops. If there are no references left, throws an exception."},
            {"ref@+", "ref@+ ( s — s' c )\nFetches the first reference from the Slice s similarly to ref@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"ref@?", "ref@? ( s — c -1 or 0 )\nFetches the first reference from the Slice s similarly to ref@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"ref@?+", "ref@?+ ( s — s' c -1 or s 0 )\nSimilar to ref@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"remaining", "remaining ( s — x y )\nReturns both the number of data bits x and the number of cell references y remaining in the Slice s, cf. p:slice.ops."},
            {"reverse", "reverse ( x₁ … xₙ y₁ … yₘ n m — xₙ … x₁ y₁ … yₘ )\nReverses the order of n stack entries located immediately below the topmost m elements, where both 0≤ m,n≤ 255 are passed in the stack."},
            {"roll", "roll ( xₙ … x₀ n — x_{n-1} … x₀ xₙ )\nRotates the top n stack entries, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 1 roll is equivalent to swap, and 2 roll to rot."},
            {"rot", "rot ( x y z — y z x )\nRotates the three topmost stack entries."},
            {"runvm", "runvm ( … s c — … x c' )\nInvokes a new instance of TVM with both the current continuation cc and the special register c3 initialized from Slice s, and initializes special register c4 (the “root of persistent data”, cf. [ 1.4 ] ) with Cell c, cf. p:tvm.ops. In contrast with runvmdict, does not push an implicit zero into the initial TVM stack; if necessary, it can be explicitly passed under s. The final value of c4 is returned at the top of the final Fift stack as another Cell c'. In this way one can emulate the execution of smart contracts that inspect or modify their persistent storage."},
            {"runvmcode", "runvmcode ( … s — … x )\nInvokes a new instance of TVM with the current continuation cc initialized from Slice s, thus executing code s in TVM, cf. p:tvm.ops. The original Fift stack (without s ) is passed in its entirety as the initial stack of the new TVM instance. When TVM terminates, its resulting stack is used as the new Fift stack, with the exit code x pushed at its top. If x is non-zero, indicating that TVM has been terminated by an unhandled exception, the next stack entry from the top contains the parameter of this exception, and x is the exception code. All other entries are removed from the stack in this case."},
            {"runvmctx", "runvmctx ( … s c t — … x c' )\nA variant of runvm that also initializes c7 (the “context register” of TVM) with Tuple t, cf. p:tvm.ops."},
            {"runvmdict", "runvmdict ( … s — … x )\nInvokes a new instance of TVM with the current continuation cc initialized from Slice s similarly to runvmcode, but also initializes the special register c3 with the same value, and pushes a zero into the initial TVM stack before start, cf. p:tvm.ops. In a typical application Slice s consists of a subroutine selection code that uses the top-of-stack Integer to select the subroutine to be executed, thus enabling the definition and execution of several mutually-recursive subroutines (cf. [ 4.6 ] and p:asm.prog ). The selector equal to zero corresponds to the main() subroutine in a large TVM program."},
            {"s,", "s, ( b s — b' )\nAppends data bits and references taken from Slice s to Builder b, cf. p:builder.ops."},
            {"s>", "s> ( s — )\nThrows an exception if Slice s is non-empty, cf. p:slice.ops. It usually marks the end of the deserialization of a cell, checking whether there are any unprocessed data bits or references left."},
            {"s>c", "s>c ( s — c )\nCreates a Cell c directly from a Slice s, cf. p:slice.ops. Equivalent to <b swap s, b>."},
            {"sbitrefs", "sbitrefs ( s — x y )\nReturns both the number of data bits x and the number of cell references y remaining in Slice s, cf. p:slice.ops. Equivalent to remaining."},
            {"sbits", "sbits ( s — x )\nReturns the number of data bits x remaining in Slice s, cf. p:slice.ops."},
            {"second", "second ( t — x )\nReturns the second component of a Tuple, cf. p:tuples. Equivalent to 1[]."},
            {"sgn", "sgn ( x — y )\nComputes the sign of an Integer x (i.e., pushes 1 if x>0, -1 if x<0, and 0 if x=0 ), cf. p:int.comp. Equivalent to 0 cmp."},
            {"shash", "shash ( s — B )\nComputes the SHA256 -based representation hash of a Slice by first transforming it into a cell, cf. p:hash.ops. Equivalent to s>c hashB."},
            {"sign", "sign ( S x — S' )\nAppends a minus sign “ - ” to String S if Integer x is negative. Otherwise leaves S intact."},
            {"single", "single ( x — t )\nCreates new singleton t=(x), i.e., a one-element Tuple. Equivalent to 1 tuple."},
            {"skipspc", "skipspc ( — )\nSkips blank characters from the current input line until a non-blank or an end-of-line character is found."},
            {"smca>$", "smca>$ ( x y z — S )\nPacks a standard TON smart-contract address with workchain x (a signed 32-bit Integer ) and in-workchain address y (an unsigned 256-bit Integer ) into a 48-character string S (the human-readable representation of the address) according to flags z, cf. p:smc.addr.ops. Possible individual flags in z are: +1 for non-bounceable addresses, +2 for testnet-only addresses, and +4 for base64url output instead of base64."},
            {"space", "space ( — )\nOutputs a single space. Equivalent to bl emit or to.\" \"."},
            {"sr,", "sr, ( b s — b' )\nConstructs a new Cell containing all data and references from Slice s, and appends a reference to this cell to Builder b, cf. p:builder.ops. Equivalent to s>c ref,."},
            {"srefs", "srefs ( s — x )\nReturns the number of cell references x remaining in Slice s, cf. p:slice.ops."},
            {"swap", "swap ( x y — y x )\nInterchanges the two topmost stack entries, cf. p:stack.ops."},
            {"ten", "ten ( — 10 )\nPushes Integer constant 10."},
            {"third", "third ( t — x )\nReturns the third component of a Tuple, cf. p:tuples. Equivalent to 2[]."},
            {"times", "times ( e n — )\nExecutes execution token ( WordDef ) e exactly n times, if n≥0, cf. p:simple.loops. If n is negative, throws an exception."},
            {"triple", "triple ( x y z — t )\nCreates new triple t=(x,y,z), cf. p:tuples. Equivalent to 3 tuple."},
            {"true", "true ( — -1 )\nPushes -1 into the stack, cf. p:bool. Equivalent to -1."},
            {"tuck", "tuck ( x y — y x y )\nEquivalent to swap over, cf. p:stack.ops."},
            {"tuple", "tuple ( x₁ … xₙ n — t )\nCreates new Tuple t:=(x₁,…,xₙ) from n≥0 topmost stack values, cf. p:tuples. Equivalent to dup 1 reverse | { swap, } rot times, but more efficient."},
            {"tuple?", "tuple? ( t — ? )\nChecks whether t is a Tuple, and returns -1 or 0 accordingly."},
            {"type", "type ( s — )\nPrints a String s taken from the top of the stack into the standard output, cf. p:string.ops."},
            {"u,", "u, ( b x y — b' )\nAppends the big-endian binary representation of an unsigned y -bit integer x to Builder b, where 0≤ y≤ 256, cf. p:builder.ops. If the operation is impossible, an exception is thrown."},
            {"u>B", "u>B ( x y — B )\nStores an unsigned big-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"u@", "u@ ( s x — y )\nFetches an unsigned big-endian x -bit integer from the first x bits of Slice s, cf. p:slice.ops. If s contains less than x data bits, an exception is thrown."},
            {"u@+", "u@+ ( s x — y s' )\nFetches an unsigned big-endian x -bit integer from the first x bits of Slice s similarly to u@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"u@?", "u@? ( s x — y -1 or 0 )\nFetches an unsigned big-endian integer from a Slice similarly to u@, but pushes integer -1 afterwards on success, cf. p:slice.ops. If there are less than x bits left in s, pushes integer 0 to indicate failure."},
            {"u@?+", "u@?+ ( s x — y s' -1 or s 0 )\nFetches an unsigned big-endian integer from Slice s and computes the remainder of this Slice similarly to u@+, but pushes -1 afterwards to indicate success, cf. p:slice.ops. On failure, pushes the unchanged Slice s and 0 to indicate failure."},
            {"udict!", "udict! ( v x D n — D' -1 or D 0 )\nAdds a new value v (represented by a Slice ) with key given by big-endian unsigned n -bit integer x into dictionary D with n -bit keys, and returns the new dictionary D' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary D and 0 are returned."},
            {"udict!+", "udict!+ ( v x D n — D' -1 or D 0 )\nAdds a new key-value pair (x,v) into dictionary D similarly to udict!, but fails if the key already exists by returning the unchanged dictionary D and 0, cf. p:hashmap.ops."},
            {"udict@", "udict@ ( x D n — v -1 or 0 )\nLooks up key represented by unsigned big-endian n -bit Integer x in the dictionary represented by Cell or Null D, cf. p:hashmap.ops. If the key is found, returns the corresponding value as a Slice v and -1. Otherwise returns 0."},
            {"ufits", "ufits ( x y — ? )\nChecks whether Integer x is an unsigned y -bit integer (i.e., whether 0≤ x<2ʸ for 0≤ y≤ 1023 ), and returns -1 or 0 accordingly."},
            {"uncons", "uncons ( l — h t )\nDecomposes a non-empty list into its head and its tail, cf. p:lists. Equivalent to unpair."},
            {"undef?❬word-name❭", "undef?❬word-name❭ ( — ? )\nChecks whether the word ❬word-name❭ is undefined at execution time, and returns -1 or 0 accordingly."},
            {"unpair", "unpair ( t — x y )\nUnpacks a pair t=(x,y), cf. p:tuples. Equivalent to 2 untuple."},
            {"unsingle", "unsingle ( t — x )\nUnpacks a singleton t=(x). Equivalent to 1 untuple."},
            {"until", "until ( e — )\nAn until loop, cf. p:loops: executes WordDef e, then removes the top-of-stack integer and checks whether it is zero. If it is, then begins a new iteration of the loop by executing e. Otherwise exits the loop."},
            {"untriple", "untriple ( t — x y z )\nUnpacks a triple t=(x,y,z), cf. p:tuples. Equivalent to 3 untuple."},
            {"untuple", "untuple ( t n — x₁ … xₙ )\nReturns all components of a Tuple t=(x₁,…,xₙ), but only if its length is equal to n, cf. p:tuples. Otherwise throws an exception."},
            {"variable", "variable ( — )\nScans a blank-delimited word name S from the remainder of the input, allocates an empty Box, and defines a new ordinary word S as a constant, which will push the new Box when invoked, cf. p:variables. Equivalent to hole constant."},
            {"while", "while ( e e' — )\nA while loop, cf. p:loops: executes WordDef e, then removes and checks the top-of-stack integer. If it is zero, exits the loop. Otherwise executes WordDef e', then begins a new loop iteration by executing e and checking the exit condition afterwards."},
            {"word", "word ( x — s )\nParses a word delimited by the character with the Unicode codepoint x from the remainder of the current input line and pushes the result as a String, cf. p:string.ops. For instance, bl word abracadabra type will print the string “ abracadabra ”. If x=0, skips leading spaces, and then scans until the end of the current input line. If x=32, skips leading spaces before parsing the next word."},
            {"words", "words ( — )\nPrints the names of all words currently defined in the dictionary, cf. p:dict.lookup."},
            {"x.", "x. ( x — )\nPrints the hexadecimal representation (without the 0x prefix) of an Integer x, followed by a single space. Equivalent to x._space."},
            {"x._", "x._ ( x — )\nPrints the hexadecimal representation (without the 0x prefix) of an Integer x without any spaces. Equivalent to (x.) type."},
            {"xor", "xor ( x y — x⊕ y )\nComputes the bitwise eXclusive OR of two Integer s, cf. p:arith.op."},
            {"x{❬hex-data❭}", "x{❬hex-data❭} ( — s )\nCreates a Slice s that contains no references and up to 1023 data bits specified in ❬hex-data❭, cf. p:slice.lit. More precisely, each hex digit from ❬hex-data❭ is transformed into four binary digits in the usual fashion. After that, if the last character of ❬hex-data❭ is an underscore _, then all trailing binary zeroes and the binary one immediately preceding them are removed from the resulting binary string (cf. [ 1.0 ] for more details). For instance, x{6C_} is equivalent to b{01101}."},
            {"{", "{ ( — l )\nAn active word that increases internal variable state by one and pushes a new empty WordList into the stack, cf. p:wordlist.ops."},
            {"|", "| ( — t )\nCreates an empty Tuple t=(), cf. p:tuples. Equivalent to nil and to 0 tuple."},
            {"|+", "|+ ( s s' — s” )\nConcatenates two Slice s and s', cf. p:slice.lit. This means that the data bits of the new Slice s” are obtained by concatenating the data bits of s and s', and the list of Cell references of s” is constructed similarly by concatenating the corresponding lists for s and s'. Equivalent to <b rot s, swap s, b> <s."},
            {"|_", "|_ ( s s' — s” )\nGiven two Slice s s and s', creates a new Slice s”, which is obtained from s by appending a new reference to a Cell containing s', cf. p:slice.lit. Equivalent to <b rot s, swap s>c ref, b> <s."},
            {"}", "} ( l — e )\nAn active word that transforms a WordList l into a WordDef (an execution token) e, thus making all further modifications of l impossible, and decreases internal variable state by one; then pushes the integer 1, followed by a 'nop, cf. p:wordlist.ops. The net effect is to transform the constructed WordList into an execution token and push this execution token into the stack, either immediately or during the execution of an outer block."},
        };
        
        if (!word.empty()) {
            auto docstring = docs.find(word);
            if (docstring != docs.end()) {
                return docstring->second;
            }
        }
        return std::string(); 
    }
}