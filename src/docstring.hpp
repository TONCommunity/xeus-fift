#include <string>
#include <unordered_map>

namespace xfift {
    static inline std::string get_docstring(const std::string& word) {
        static std::unordered_map<std::string, std::string> docs = {
            {"!", "! ( x p — )\nStores new value x into Box p, cf. p:variables."},
            {"\"", "\"❬string❭\" ( — S )\nPushes a String literal into the stack, cf. p:string.lit and p:string.ops."},
            {"#", "# ( x S — x' S' )\nPerforms one step of the conversion of Integer x into its decimal representation by appending to String S one decimal digit representing x mod10. The quotient x':= ⌊x/10⌋ is returned as well."},
            {"#>", "#> ( S — S' )\nFinishes the conversion of an Integer into its human-readable representation (decimal or otherwise) started with <# by reversing String S. Equivalent to $reverse."},
            {"#s", "#s ( x S — x' S' )\nPerforms # one or more times until the quotient x' becomes non-positive. Equivalent to {#over 0<= } until."},
            {"$#", "$# ( — x )\nPushes the total number of command-line arguments passed to the Fift program, cf. p:cmdline.ops. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$(", "$(❬string❭) ( — … ), looks up the word $❬string❭ during execution time and executes its current definition. Typically used to access the current values of command-line arguments, e.g., $(2) is essentially equivalent to @' $2."},
            {"$()", "$() ( x — S ), pushes the x -th command-line argument similarly to $n, but with Integer x≥0 taken from the stack, cf. p:cmdline.ops. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$+", "$+ ( S S' — S.S' )\nConcatenates two strings, cf. p:string.ops."},
            {"$,", "$, ( b S — b' )\nAppends String S to Builder b, cf. p:builder.ops. The string is interpreted as a binary string of length 8n, where n is the number of bytes in the UTF-8 representation of S."},
            {"$n", "$n ( — S )\nPushes the n -th command-line argument as a String S, cf. p:cmdline.ops. For instance, $0 pushes the name of the script being executed, $1 the first command line argument, and so on. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$=", "$= ( S S' — ? )\nReturns -1 if strings S and S' are equal, 0 otherwise, cf. p:string.cmp.ops. Equivalent to $cmp 0=."},
            {"$>s", "$>s ( S — s )\nTransforms the String S into a Slice, cf. p:slice.ops. Equivalent to <b swap $, b> <s."},
            {"$>smca", "$>smca ( S — x y z -1 or 0 )\nUnpacks a standard TON smart-contract address from its human-readable string representation S, cf. p:smc.addr.ops. On success, returns the signed 32-bit workchain x, the unsigned 256-bit in-workchain address y, the flags z (where +1 means that the address is non-bounceable, +2 that the address is testnet-only), and -1. On failure, pushes 0."},
            {"$@", "$@ ( s x — S )\nFetches the first x bytes (i.e., 8x bits) from Slice s, and returns them as a UTF-8 String S, cf. p:slice.ops. If there are not enough data bits in s, throws an exception."},
            {"$@+", "$@+ ( s x — S s' )\nSimilar to $@, but returns the remainder of Slice s as well, cf. p:slice.ops."},
            {"$@?", "$@? ( s x — S -1 or 0 )\nSimilar to $@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"$@?+", "$@?+ ( s x — S s' -1 or s 0 )\nSimilar to $@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"$cmp", "$cmp ( S S' — x )\nReturns 0 if strings S and S' are equal, -1 if S is lexicographically less than S', and 1 if S is lexicographically greater than S', cf. p:string.cmp.ops."},
            {"$len", "$len ( S — x )\nComputes the byte length (not the UTF-8 character length!) of a string, cf. p:string.ops."},
            {"$reverse", "$reverse ( S — S' )\nReverses the order of UTF-8 characters in String S. If S is not a valid UTF-8 string, the return value is undefined and may be also invalid."},
            {"%1<<", "%1<< ( x y — z )\nComputes z:=x mod 2ʸ =x&(2ʸ -1) for two Integer s x and 0≤ y≤ 256."},
            {"'❬word-name❭", "'❬word-name❭ ( — e )\nReturns the execution token equal to the current (compile-time) definition of ❬word-name❭, cf. p:blocks. If the specified word is not found, throws an exception."},
            {"'nop", "'nop ( — e )\nPushes the default definition of nop —an execution token that does nothing when executed, cf. p:dict.lookup."},
            {"(')❬word-name❭", "(')❬word-name❭ ( — e ), similar to ', but returns the definition of the specified word at execution time, performing a dictionary lookup each time it is invoked, cf. p:dict.lookup. May be used to recover the current values of constants inside word definitions and other blocks by using the phrase (')❬word-name❭execute."},
            {"(-trailing)", "(-trailing) ( S x — S' ), removes from String S all trailing characters with UTF-8 codepoint x."},
            {"(.)", "(.) ( x — S ), returns the String with the decimal representation of Integer x. Equivalent to dup abs <##srot sign#> nip."},
            {"(atom)", "(atom) ( S x — a -1 or 0 ), returns the only Atom a with the name given by String S, cf. p:atoms. If there is no such Atom yet, either creates it (if Integer x is non-zero) or returns a single zero to indicate failure (if x is zero)."},
            {"(b.)", "(b.) ( x — S ), returns the String with the binary representation of Integer x."},
            {"(compile)", "(compile) ( l x₁ … xₙ n e — l' ), extends WordList l so that it would push 0≤ n≤ 255 values x₁, …, xₙ into the stack and execute the execution token e when invoked, where 0≤ n≤ 255 is an Integer, cf. p:wordlist.ops. If e is equal to the special value 'nop, the last step is omitted."},
            {"(create)", "(create) ( e S x — ), creates a new word with the name equal to String S and definition equal to WordDef e, using flags passed in Integer 0≤ x≤ 3, cf. p:dict.create. If bit +1 is set in x, creates an active word; if bit +2 is set in x, creates a prefix word."},
            {"(def?)", "(def?) ( S — ? ), checks whether the word S is defined."},
            {"(dump)", "(dump) ( x — S ), returns a String with a dump of the topmost stack value x, in the same format as employed by.dump."},
            {"(execute)", "(execute) ( x₁ … xₙ n e — … ), executes execution token e, but first checks that there are at least 0≤ n≤ 255 values in the stack apart from n and e themselves. It is a counterpart of (compile) that may be used to immediately “execute” (perform the intended runtime action of) an active word after its immediate execution, as explained in p:active.words."},
            {"(forget)", "(forget) ( S — ), forgets the word with the name specified in String S, cf. p:dict.create. If the word is not found, throws an exception."},
            {"(number)", "(number) ( S — 0 or x 1 or x y 2 ), attempts to parse the String S as an integer or fractional literal, cf. p:string.ops and p:int.lit. On failure, returns a single 0. On success, returns x 1 if S is a valid integer literal with value x, or x y 2 if S is a valid fractional literal with value x/y."},
            {"(x.)", "(x.) ( x — S ), returns the String with the hexadecimal representation of Integer x."},
            {"({)", "({) ( — l ), pushes an empty WordList into the stack, cf. p:wordlist.ops"},
            {"(})", "(}) ( l — e ), transforms a WordList into an execution token ( WordDef ), making all further modifications impossible, cf. p:wordlist.ops."},
            {"*", "* ( x y — xy )\nComputes the product xy of two Integer s x and y, cf. p:arith.op."},
            {"*/", "*/ ( x y z — ⌊xy/z⌋ ), “multiply-then-divide”: multiplies two integers x and y producing a 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/c", "*/c ( x y z — ⌈xy/z⌉ ), “multiply-then-divide” with ceiling rounding: multiplies two integers x and y producing a 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/cmod", "*/cmod ( x y z — q r )\nSimilar to */c, but computes both the quotient q:= ⌈xy/z⌉ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*/mod", "*/mod ( x y z — q r )\nSimilar to */, but computes both the quotient q:= ⌊xy/z⌋ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*/r", "*/r ( x y z — q:= ⌊xy/z+½⌋ ), “multiply-then-divide” with nearest-integer rounding: multiplies two integers x and y with 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/rmod", "*/rmod ( x y z — q r )\nSimilar to */r, but computes both the quotient q:= ⌊xy/z+½⌋ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*>>", "*>> ( x y z — q )\nSimilar to */, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌊xy/2ᶻ ⌋ for 0≤ z≤ 256. Equivalent to 1<< */."},
            {"*>>c", "*>>c ( x y z — q )\nSimilar to */c, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌈xy/2ᶻ ⌉ for 0≤ z≤ 256. Equivalent to 1<< */c."},
            {"*>>r", "*>>r ( x y z — q )\nSimilar to */r, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌊xy/2ᶻ +½⌋ for 0≤ z≤ 256. Equivalent to 1<< */r."},
            {"*mod", "*mod ( x y z — r )\nSimilar to */mod, but computes only the remainder r:=xy-qz, where q:= ⌊xy/z⌋ . Equivalent to */mod nip."},
            {"+", "+ ( x y — x+y )\nComputes the sum x+y of two Integer s x and y, cf. p:arith.op."},
            {"+!", "+! ( x p — )\nIncreases the integer value stored in Box p by Integer x, cf. p:variables. Equivalent to tuck @ + swap !."},
            {"+\"", "+\"❬string❭\" ( S — S' )\nConcatenates String S with a string literal, cf. p:string.ops. Equivalent to \"❬string❭\" $+."},
            {",", ", ( t x — t' )\nAppends x to the end of Tuple t, and returns the resulting Tuple t', cf. p:tuples."},
            {"-", "- ( x y — x-y )\nComputes the difference x-y of two Integer s x and y, cf. p:arith.op."},
            {"-!", "-! ( x p — )\nDecreases the integer value stored in Box p by Integer x. Equivalent to swap negate swap +!."},
            {"-1", "-1 ( — -1 )\nPushes Integer -1."},
            {"-1<<", "-1<< ( x — -2ˣ )\nComputes -2ˣ for 0≤ x≤ 256. Approximately equivalent to 1<< negate or -1 swap <<, but works for x=256 as well."},
            {"-roll", "-roll ( xₙ … x₀ n — x₀ xₙ … x₁ )\nRotates the top n stack entries in the opposite direction, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 1 -roll is equivalent to swap, and 2 -roll to -rot."},
            {"-rot", "-rot ( x y z — z x y )\nRotates the three topmost stack entries in the opposite direction, cf. p:stack.ops. Equivalent to rot rot."},
            {"-trailing", "-trailing ( S — S' )\nRemoves from String S all trailing spaces. Equivalent to bl (-trailing)."},
            {"-trailing0", "-trailing0 ( S — S' )\nRemoves from String S all trailing ` 0 ' characters. Equivalent to char 0 (-trailing)."},
            {".", ". ( x — )\nPrints the decimal representation of Integer x, followed by a single space, cf. p:arith.op. Equivalent to._space."},
            {".\"", ".\"❬string❭\" ( — )\nPrints a constant string into the standard output, cf. p:string.ops."},
            {"._", "._ ( x — )\nPrints the decimal representation of Integer x without any spaces. Equivalent to (.) type."},
            {".dump", ".dump ( x — )\nDumps the topmost stack entry in the same way as.s dumps all stack elements, cf. p:tuples. Equivalent to (dump) type space."},
            {".l", ".l ( l — )\nPrints a Lisp-style list l, cf. p:lists."},
            {".s", ".s ( — )\nDumps all stack entries starting from the deepest, leaving them intact, cf. p:stack.ops. Human-readable representations of stack entries are output separated by spaces, followed by an end-of-line character."},
            {".sl", ".sl ( — )\nDumps all stack entries leaving them intact similarly to.s, but showing each entry as a List-style list l as.l does."},
            {".tc", ".tc ( — )\nOutputs the total number of allocated cells into the standard error stream."},
            {"/", "/ ( x y — q:= ⌊x/y⌋ )\nComputes the floor-rounded quotient ⌊x/y⌋ of two Integer s, cf. p:arith.op."},
            {"/*❬multiline-comment❭*/", "/*❬multiline-comment❭*/ ( — )\nSkips a multi-line comment delimited by word “ */ ” (followed by a blank or an end-of-line character), cf. p:comments."},
            {"//❬comment-to-eol❭", "//❬comment-to-eol❭ ( — )\nSkips a single-line comment until the end of the current line, cf. p:comments."},
            {"/c", "/c ( x y — q:= ⌈x/y⌉ )\nComputes the ceiling-rounded quotient ⌈x/y⌉ of two Integer s, cf. p:arith.op."},
            {"/cmod", "/cmod ( x y — q r )\nComputes both the ceiling-rounded quotient q:= ⌈x/y⌉ and the remainder r:=x-qy, cf. p:arith.op."},
            {"/mod", "/mod ( x y — q r )\nComputes both the floor-rounded quotient q:= ⌊x/y⌋ and the remainder r:=x-qy, cf. p:arith.op."},
            {"/r", "/r ( x y — q )\nComputes the nearest-integer-rounded quotient ⌊x/y+½⌋ of two Integer s, cf. p:arith.op."},
            {"/rmod", "/rmod ( x y — q r )\nComputes both the nearest-integer-rounded quotient q:= ⌊x/y+½⌋ and the remainder r:=x-qy, cf. p:arith.op."},
            {"0", "0 ( — 0 )\nPushes Integer 0."},
            {"0!", "0! ( p — )\nStores Integer 0 into Box p, cf. p:variables. Equivalent to 0 swap !."},
            {"0<", "0< ( x — ? )\nChecks whether x<0 (i.e., pushes -1 if x is negative, 0 otherwise), cf. p:int.comp. Equivalent to 0 <."},
            {"0<=", "0<= ( x — ? )\nChecks whether x≤0 (i.e., pushes -1 if x is non-positive, 0 otherwise), cf. p:int.comp. Equivalent to 0 <=."},
            {"0<>", "0<> ( x — ? )\nChecks whether x≠0 (i.e., pushes -1 if x is non-zero, 0 otherwise), cf. p:int.comp. Equivalent to 0 <>."},
            {"0=", "0= ( x — ? )\nChecks whether x=0 (i.e., pushes -1 if x is zero, 0 otherwise), cf. p:int.comp. Equivalent to 0 =."},
            {"0>", "0> ( x — ? )\nChecks whether x>0 (i.e., pushes -1 if x is positive, 0 otherwise), cf. p:int.comp. Equivalent to 0 >."},
            {"0>=", "0>= ( x — ? )\nChecks whether x≥0 (i.e., pushes -1 if x is non-negative, 0 otherwise), cf. p:int.comp. Equivalent to 0 >=."},
            {"1", "1 ( — 1 )\nPushes Integer 1."},
            {"1+", "1+ ( x — x+1 )\nComputes x+1. Equivalent to 1 +."},
            {"1+!", "1+! ( p — )\nIncreases the integer value stored in Box p by one, cf. p:variables. Equivalent to 1 swap +!."},
            {"1-", "1- ( x — x-1 )\nComputes x-1. Equivalent to 1 -."},
            {"1-!", "1-! ( p — )\nDecreases the integer value stored in Box p by one. Equivalent to -1 swap +!."},
            {"1<<", "1<< ( x — 2ˣ )\nComputes 2ˣ for 0≤ x≤ 255. Equivalent to 1 swap <<."},
            {"1<<1-", "1<<1- ( x — 2ˣ -1 )\nComputes 2ˣ -1 for 0≤ x≤ 256. Almost equivalent to 1<< 1-, but works for x=256."},
            {"2", "2 ( — 2 )\nPushes Integer 2."},
            {"2*", "2* ( x — 2x )\nComputes 2x. Equivalent to 2 *."},
            {"2+", "2+ ( x — x+2 )\nComputes x+2. Equivalent to 2 +."},
            {"2-", "2- ( x — x-2 )\nComputes x-2. Equivalent to 2 -."},
            {"2/", "2/ ( x — ⌊x/2⌋ )\nComputes ⌊x/2⌋ . Equivalent to 2 / or to 1 >>."},
            {"2=:❬word-name❭", "2=:❬word-name❭ ( x y — )\nAn active variant of 2constant: defines a new ordinary word ❬word-name❭ that would push the given values x and y when invoked, cf. p:constants."},
            {"2constant", "2constant ( x y — )\nScans a blank-delimited word name S from the remainder of the input, and defines a new ordinary word S as a double constant, which will push the given values x and y (of arbitrary types) when invoked, cf. p:dict.create."},
            {"2drop", "2drop ( x y — )\nRemoves the two topmost stack entries, cf. p:stack.ops. Equivalent to drop drop."},
            {"2dup", "2dup ( x y — x y x y )\nDuplicates the topmost pair of stack entries, cf. p:stack.ops. Equivalent to over over."},
            {"2over", "2over ( x y z w — x y z w x y )\nDuplicates the second topmost pair of stack entries."},
            {"2swap", "2swap ( a b c d — c d a b )\nInterchanges the two topmost pairs of stack entries, cf. p:stack.ops."},
            {":❬word-name❭", ":❬word-name❭ ( e — )\nDefines a new ordinary word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"::❬word-name❭", "::❬word-name❭ ( e — )\nDefines a new active word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"::_❬word-name❭", "::_❬word-name❭ ( e — )\nDefines a new active prefix word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {":_❬word-name❭", ":_❬word-name❭ ( e — )\nDefines a new ordinary prefix word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"<", "< ( x y — ? )\nChecks whether x<y (i.e., pushes -1 if Integer x is less than Integer y, 0 otherwise), cf. p:int.comp."},
            {"<#", "<# ( — S )\nPushes an empty String. Typically used for starting the conversion of an Integer into its human-readable representation, decimal or in another base. Equivalent to \"\"."},
            {"<<", "<< ( x y — x⋅ 2ʸ )\nComputes an arithmetic left shift of binary number x by y≥0 positions, yielding x⋅ 2ʸ , cf. p:arith.op."},
            {"<</", "<</ ( x y z — q )\nComputes q:= ⌊2ᶻ x/y⌋ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */, cf. p:arith.op. Equivalent to 1<< swap */."},
            {"<</c", "<</c ( x y z — q )\nComputes q:= ⌈2ᶻ x/y⌉ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */c, cf. p:arith.op. Equivalent to 1<< swap */c."},
            {"<</r", "<</r ( x y z — q )\nComputes q:= ⌊2ᶻ x/y+½⌋ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */r, cf. p:arith.op. Equivalent to 1<< swap */r."},
            {"<=", "<= ( x y — ? )\nChecks whether x≤ y (i.e., pushes -1 if Integer x is less than or equal to Integer y, 0 otherwise), cf. p:int.comp."},
            {"<>", "<> ( x y — ? )\nChecks whether x≠ y (i.e., pushes -1 if Integer s x and y are not equal, 0 otherwise), cf. p:int.comp."},
            {"<b", "<b ( — b )\nCreates a new empty Builder, cf. p:builder.ops."},
            {"<s", "<s ( c — s )\nTransforms a Cell c into a Slice s containing the same data, cf. p:slice.ops. It usually marks the start of the deserialization of a cell."},
            {"=", "= ( x y — ? )\nChecks whether x=y (i.e., pushes -1 if Integer s x and y are equal, 0 otherwise), cf. p:int.comp."},
            {"=:❬word-name❭", "=:❬word-name❭ ( x — )\nAn active variant of constant: defines a new ordinary word ❬word-name❭ that would push the given value x when invoked, cf. p:constants."},
            {">", "> ( x y — ? )\nChecks whether x>y (i.e., pushes -1 if Integer x is greater than Integer y, 0 otherwise), cf. p:int.comp."},
            {">=", ">= ( x y — ? )\nChecks whether x≥ y (i.e., pushes -1 if Integer x is greater than or equal to Integer y, 0 otherwise), cf. p:int.comp."},
            {">>", ">> ( x y — q:= ⌊x⋅ 2⁻ʸ ⌋ )\nComputes an arithmetic right shift of binary number x by 0≤ y≤ 256 positions, cf. p:arith.op. Equivalent to 1<< /."},
            {">>c", ">>c ( x y — q:= ⌈x⋅ 2⁻ʸ ⌉ )\nComputes the ceiling-rounded quotient q of x by 2ʸ for 0≤ y≤ 256, cf. p:arith.op. Equivalent to 1<< /c."},
            {">>r", ">>r ( x y — q:= ⌊x⋅ 2⁻ʸ +½⌋ )\nComputes the nearest-integer-rounded quotient q of x by 2ʸ for 0≤ y≤ 256, cf. p:arith.op. Equivalent to 1<< /r."},
            {"?dup", "?dup ( x — x x or 0 )\nDuplicates an Integer x, but only if it is non-zero, cf. p:stack.ops. Otherwise leaves it intact."},
            {"@", "@ ( p — x )\nFetches the value currently stored in Box p, cf. p:variables."},
            {"@'❬word-name❭", "@'❬word-name❭ ( — e )\nRecovers the definition of the specified word at execution time, performing a dictionary lookup each time it is invoked, and then executes this definition, cf. p:constants and p:dict.lookup. May be used to recover current values of constants inside word definitions and other blocks by using the phrase @'❬word-name❭, equivalent to (')❬word-name❭execute."},
            {"B+", "B+ ( B' B” — B )\nConcatenates two Bytes values, cf. p:bytes.ops."},
            {"B,", "B, ( b B — b' )\nAppends Bytes B to Builder b, cf. p:builder.ops. If there is no room in b for B, throws an exception."},
            {"B=", "B= ( B B' — ? )\nChecks whether two Bytes sequences are equal, and returns -1 or 0 depending on the comparison outcome, cf. p:bytes.ops."},
            {"B>Li@", "B>Li@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as a signed little-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>Li@+", "B>Li@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as a signed little-endian x -bit Integer y similarly to B>Li@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>Lu@", "B>Lu@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as an unsigned little-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>Lu@+", "B>Lu@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as an unsigned little-endian x -bit Integer y similarly to B>Lu@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>boc", "B>boc ( B — c )\nDeserializes a “standard” bag of cells (i.e., a bag of cells with exactly one root cell) represented by Bytes B, and returns the root Cell c, cf. p:boc.ops."},
            {"B>file", "B>file ( B S — )\nCreates a new (binary) file with the name specified in String S and writes data from Bytes B into the new file, cf. p:bytes.ops. If the specified file already exists, it is overwritten."},
            {"B>i@", "B>i@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as a signed big-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>i@+", "B>i@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as a signed big-endian x -bit Integer y similarly to B>i@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>u@", "B>u@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as an unsigned big-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>u@+", "B>u@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as an unsigned big-endian x -bit Integer y similarly to B>u@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B@", "B@ ( s x — B )\nFetches the first x bytes (i.e., 8x bits) from Slice s, and returns them as a Bytes value B, cf. p:slice.ops. If there are not enough data bits in s, throws an exception."},
            {"B@+", "B@+ ( s x — B s' )\nSimilar to B@, but returns the remainder of Slice s as well, cf. p:slice.ops."},
            {"B@?", "B@? ( s x — B -1 or 0 )\nSimilar to B@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"B@?+", "B@?+ ( s x — B s' -1 or s 0 )\nSimilar to B@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"Bcmp", "Bcmp ( B B' — x )\nLexicographically compares two Bytes sequences, and returns -1, 0, or 1, depending on the comparison result, cf. p:bytes.ops."},
            {"Bhash", "Bhash ( B — x )\nDeprecated version of Bhashu. Use Bhashu or BhashB instead."},
            {"BhashB", "BhashB ( B — B' )\nComputes the SHA256 hash of a Bytes value, cf. p:bytes.ops. The hash is returned as a 32-byte Bytes value."},
            {"Bhashu", "Bhashu ( B — x )\nComputes the SHA256 hash of a Bytes value, cf. p:bytes.ops. The hash is returned as a big-endian unsigned 256-bit Integer value."},
            {"Blen", "Blen ( B — x )\nReturns the length of a Bytes value B in bytes, cf. p:bytes.ops."},
            {"Bx.", "Bx. ( B — )\nPrints the hexadecimal representation of a Bytes value, cf. p:bytes.ops. Each byte is represented by exactly two uppercase hexadecimal digits."},
            {"B{❬{hex-digits}❭}", "B{❬{hex-digits}❭} ( — B )\nPushes a Bytes literal containing data represented by an even number of hexadecimal digits, cf. p:bytes.ops."},
            {"B|", "B| ( B x — B' B” )\nCuts the first x bytes from a Bytes value B, and returns both the first x bytes ( B' ) and the remainder ( B” ) as new Bytes values, cf. p:bytes.ops."},
            {"Li>B", "Li>B ( x y — B )\nStores a signed little-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"Lu>B", "Lu>B ( x y — B )\nStores an unsigned little-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"[", "[ ( — )\nOpens an internal interpreter session even if state is greater than zero, i.e., all subsequent words are executed immediately instead of being compiled."},
            {"[]", "[] ( t i — x )\nReturns the (i+1) -st component t_{i+1} of Tuple t, where 0≤ i<|t|, cf. p:tuples."},
            {"[compile]❬word-name❭", "[compile]❬word-name❭ ( — )\nCompiles ❬word-name❭ as if it were an ordinary word, even if it is active, cf. p:dict.lookup. Essentially equivalent to '❬word-name❭execute."},
            {"]", "] ( x₁ … xₙ n — )\nCloses an internal interpreter session opened by [ and invokes (compile) or (execute) afterwards depending on whether state is greater than zero. For instance, {[2 3 + 1]* } is equivalent to { 5 * }."},
            {"`❬word❭", "`❬word❭ ( — a )\nIntroduces an Atom literal, equal to the only Atom with the name equal to ❬word❭, cf. p:atoms. Equivalent to \"❬word❭\" atom."},
            {"abort", "abort ( S — )\nThrows an exception with an error message taken from String S, cf. p:exception.ops."},
            {"abort\"❬message❭\"", "abort\"❬message❭\" ( x — )\nThrows an exception with the error message ❬message❭ if the Integer x is non-zero, cf. p:exception.ops."},
            {"abs", "abs ( x — |x| )\nComputes the absolute value |x|=max(x,-x) of Integer x. Equivalent to dup negate max."},
            {"allot", "allot ( n — t )\nCreates a new array, i.e., a Tuple that consists of n new empty Box es, cf. p:tuples. Equivalent to | { hole, } rot times."},
            {"and", "and ( x y — x& y )\nComputes the bitwise AND of two Integer s, cf. p:arith.op."},
            {"anon", "anon ( — a )\nCreates a new unique anonymous Atom, cf. p:atoms."},
            {"atom", "atom ( S — a )\nReturns the only Atom a with the name S, creating such an atom if necessary, cf. p:atoms. Equivalent to true (atom) drop."},
            {"atom?", "atom? ( u — ? )\nChecks whether u is an Atom, cf. p:atoms."},
            {"b+", "b+ ( b b' — b” )\nConcatenates two Builders b and b', cf. p:builder.ops."},
            {"b.", "b. ( x — )\nPrints the binary representation of an Integer x, followed by a single space. Equivalent to b._space."},
            {"b._", "b._ ( x — )\nPrints the binary representation of an Integer x without any spaces. Equivalent to (b.) type."},
            {"b>", "b> ( b — c )\nTransforms a Builder b into a new Cell c containing the same data as b, cf. p:builder.ops."},
            {"b>idict!", "b>idict! ( v x s n — s' -1 or s 0 )\nAdds a new value v (represented by a Builder ) with key given by signed big-endian n -bit integer x into dictionary s with n -bit keys, and returns the new dictionary s' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary s and 0 are returned."},
            {"b>idict!+", "b>idict!+ ( v x s n — s' -1 or s 0 )\nAdds a new key-value pair (x,v) into dictionary s similarly to b>idict!, but fails if the key already exists by returning the unchanged dictionary s and 0, cf. p:hashmap.ops."},
            {"b>udict!", "b>udict! ( v x s n — s' -1 or s 0 )\nAdds a new value v (represented by a Builder ) with key given by unsigned big-endian n -bit integer x into dictionary s with n -bit keys, and returns the new dictionary s' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary s and 0 are returned."},
            {"b>udict!+", "b>udict!+ ( v x s n — s' -1 or s 0 )\nAdds a new key-value pair (x,v) into dictionary s similarly to b>udict!, but fails if the key already exists by returning the unchanged dictionary s and 0, cf. p:hashmap.ops."},
            {"bbitrefs", "bbitrefs ( b — x y )\nReturns both the number of data bits x and the number of references y already stored in Builder b, cf. p:builder.ops."},
            {"bbits", "bbits ( b — x )\nReturns the number of data bits already stored in Builder b. The result x is an Integer in the range 0…1023, cf. p:builder.ops."},
            {"bl", "bl ( — x )\nPushes the Unicode codepoint of a space, i.e., 32, cf. p:string.ops."},
            {"boc+>B", "boc+>B ( c x — B )\nCreates and serializes a “standard” bag of cells, containing one root Cell c along with all its descendants, cf. p:boc.ops. An Integer parameter 0≤ x≤ 31 is used to pass flags indicating the additional options for bag-of-cells serialization, with individual bits having the following effect: +1enables bag-of-cells index creation (useful for lazy deserialization of large bags of cells).+2includes the CRC32-C of all data into the serialization (useful for checking data integrity).+4explicitly stores the hash of the root cell into the serialization (so that it can be quickly recovered afterwards without a complete deserialization).+8stores hashes of some intermediate (non-leaf) cells (useful for lazy deserialization of large bags of cells).+16stores cell cache bits to control caching of deserialized cells. Typical values of x are x=0 or x=2 for very small bags of cells (e.g., TON Blockchain external messages) and x=31 for large bags of cells (e.g., TON Blockchain blocks)."},
            {"boc>B", "boc>B ( c — B )\nSerializes a small “standard” bag of cells with root Cell c and all its descendants, cf. p:boc.ops. Equivalent to 0 boc+>B."},
            {"box", "box ( x — p )\nCreates a new Box containing specified value x, cf. p:variables. Equivalent to hole tuck !."},
            {"brefs", "brefs ( b — x )\nReturns the number of references already stored in Builder b, cf. p:builder.ops. The result x is an Integer in the range 0…4."},
            {"brembitrefs", "brembitrefs ( b — x y )\nReturns both the maximum number of additional data bits 0≤ x≤ 1023 and the maximum number of additional cell references 0≤ y≤ 4 that can be stored in Builder b, cf. p:builder.ops."},
            {"brembits", "brembits ( b — x )\nReturns the maximum number of additional data bits that can be stored in Builder b, cf. p:builder.ops. Equivalent to bbits 1023 swap -."},
            {"bremrefs", "bremrefs ( b — x )\nReturns the maximum number of additional cell references that can be stored in Builder b, cf. p:builder.ops."},
            {"bye", "bye ( — )\nQuits the Fift interpreter to the operating system with a zero exit code, cf. p:exit.fift. Equivalent to 0 halt."},
            {"b{❬binary-data❭}", "b{❬binary-data❭} ( — s )\nCreates a Slice s that contains no references and up to 1023 data bits specified in ❬binary-data❭, which must be a string consisting only of the characters ` 0 ' and ` 1 ', cf. p:slice.lit."},
            {"caddr", "caddr ( l — h” )\nReturns the third element of a list. Equivalent to cddr car."},
            {"cadr", "cadr ( l — h' )\nReturns the second element of a list, cf. p:lists. Equivalent to cdr car."},
            {"car", "car ( l — h )\nReturns the head of a list, cf. p:lists. Equivalent to first."},
            {"cddr", "cddr ( l — t' )\nReturns the tail of the tail of a list. Equivalent to cdr cdr."},
            {"cdr", "cdr ( l — t )\nReturns the tail of a list, cf. p:lists. Equivalent to second."},
            {"char❬string❭", "char❬string❭ ( — x )\nPushes an Integer with the Unicode codepoint of the first character of ❬string❭, cf. p:string.ops. For instance, char * is equivalent to 42."},
            {"chr", "chr ( x — S )\nReturns a new String S consisting of one UTF-8 encoded character with Unicode codepoint x."},
            {"cmp", "cmp ( x y — z )\nCompares two Integer s x and y, and pushes 1 if x>y, -1 if x<y, and 0 if x=y, cf. p:int.comp. Approximately equivalent to - sgn."},
            {"cond", "cond ( x e e' — )\nIf Integer x is non-zero, executes e, otherwise executes e', cf. p:cond.ops."},
            {"cons", "cons ( h t — l )\nConstructs a list from its head (first element) h and its tail (the list consisting of all remaining elements) t, cf. p:lists. Equivalent to pair."},
            {"constant", "constant ( x — )\nScans a blank-delimited word name S from the remainder of the input, and defines a new ordinary word S as a constant, which will push the given value x (of arbitrary type) when invoked, cf. p:dict.create and p:constants."},
            {"count", "count ( t — n )\nReturns the length n=|t| of Tuple t, cf. p:tuples."},
            {"cr", "cr ( — )\nOutputs a carriage return (or a newline character) into the standard output, cf. p:string.ops."},
            {"create", "create ( e — )\nDefines a new ordinary word with the name equal to the next word scanned from the input, using WordDef e as its definition, cf. p:dict.create. If the word already exists, it is tacitly redefined."},
            {"csr.", "csr. ( s — )\nRecursively prints a Slice s, cf. p:slice.ops. On the first line, the data bits of s are displayed in hexadecimal form embedded into an x{…} construct similar to the one used for Slice literals (cf. p:slice.lit ). On the next lines, the cells referred to by s are printed with larger indentation."},
            {"def?❬word-name❭", "def?❬word-name❭ ( — ? )\nChecks whether the word ❬word-name❭ is defined at execution time, and returns -1 or 0 accordingly."},
            {"depth", "depth ( — n )\nReturns the current depth (the total number of entries) of the Fift stack as an Integer n≥0."},
            {"dictmap", "dictmap ( D n e — D' )\nApplies execution token e (i.e., an anonymous function) to each of the key-value pairs stored in a dictionary D with n -bit keys, cf. p:hashmap.ops. The execution token is executed once for each key-value pair, with a Builder b and a Slice v (containing the value) pushed into the stack before executing e. After the execution e must leave in the stack either a modified Builder b' (containing all data from b along with the new value v' ) and -1, or 0 indicating failure. In the latter case, the corresponding key is omitted from the new dictionary."},
            {"dictmerge", "dictmerge ( D D' n e — D” )\nCombines two dictionaries D and D' with n -bit keys into one dictionary D” with the same keys, cf. p:hashmap.ops. If a key is present in only one of the dictionaries D and D', this key and the corresponding value are copied verbatim to the new dictionary D”. Otherwise the execution token (anonymous function) e is invoked to merge the two values v and v' corresponding to the same key k in D and D', respectively. Before e is invoked, a Builder b and two Slice s v and v' representing the two values to be merged are pushed. After the execution e leaves either a modified Builder b' (containing the original data from b along with the combined value) and -1, or 0 on failure. In the latter case, the corresponding key is omitted from the new dictionary."},
            {"dictnew", "dictnew ( — D )\nPushes the Null value that represents a new empty dictionary, cf. p:hashmap.ops. Equivalent to null."},
            {"does", "does ( x₁ … xₙ n e — e' )\nCreates a new execution token e' that would push n values x₁, …, xₙ into the stack and then execute e when invoked, cf. p:wordlist.ops. It is roughly equivalent to a combination of ({), (compile), and (})."},
            {"drop", "drop ( x — )\nRemoves the top-of-stack entry, cf. p:stack.ops."},
            {"dup", "dup ( x — x x )\nDuplicates the top-of-stack entry, cf. p:stack.ops. If the stack is empty, throws an exception."},
            {"ed25519_chksign", "ed25519_chksign ( B B' B” — ? )\nChecks whether B' is a valid Ed25519-signature of data B with the public key B”, cf. p:ed25519.ops."},
            {"ed25519_sign", "ed25519_sign ( B B' — B” )\nSigns data B with the Ed25519 private key B' (a 32-byte Bytes value) and returns the signature as a 64-byte Bytes value B”, cf. p:ed25519.ops."},
            {"ed25519_sign_uint", "ed25519_sign_uint ( x B' — B” )\nConverts a big-endian unsigned 256-bit integer x into a 32-byte sequence and signs it using the Ed25519 private key B' similarly to ed25519_sign, cf. p:ed25519.ops. Equivalent to swap 256 u>B swap ed25519_sign. The integer x to be signed is typically computed as the hash of some data."},
            {"emit", "emit ( x — )\nPrints a UTF-8 encoded character with Unicode codepoint given by Integer x into the standard output, cf. p:string.ops. For instance, 42 emit prints an asterisk “ * ”, and 916 emit prints a Greek Delta “ Δ ”. Equivalent to chr type."},
            {"empty?", "empty? ( s — ? )\nChecks whether a Slice is empty (i.e., has no data bits and no references left), and returns -1 or 0 accordingly, cf. p:slice.ops."},
            {"eq?", "eq? ( u v — ? )\nChecks whether u and v are equal Integer s, Atom s, or Null s, cf. p:atoms. If they are not equal, or if they are of different types, or not of one of the types listed, returns zero."},
            {"exch", "exch ( xₙ … x₀ n — x₀ … xₙ )\nInterchanges the top of the stack with the n -th stack entry from the top, where n≥0 is also taken from the stack, cf. p:stack.ops. In particular, 1 exch is equivalent to swap, and 2 exch to swap rot."},
            {"exch2", "exch2 ( … n m — … )\nInterchanges the n -th stack entry from the top with the m -th stack entry from the top, where n≥0, m≥0 are taken from the stack, cf. p:stack.ops."},
            {"execute", "execute ( e — … )\nExecutes the execution token ( WordDef ) e, cf. p:blocks."},
            {"explode", "explode ( t — x₁ … xₙ n )\nUnpacks a Tuple t=(x₁,…,xₙ) of unknown length n, and returns that length, cf. p:tuples."},
            {"false", "false ( — 0 )\nPushes 0 into the stack, cf. p:bool. Equivalent to 0."},
            {"file-exists?", "file-exists? ( S — ? )\nChecks whether the file with the name specified in String S exists, cf. p:bytes.ops."},
            {"file>B", "file>B ( S — B )\nReads the (binary) file with the name specified in String S and returns its contents as a Bytes value, cf. p:bytes.ops. If the file does not exist, an exception is thrown."},
            {"find", "find ( S — e -1 or e 1 or 0 )\nLooks up String S in the dictionary and returns its definition as a WordDef e if found, followed by -1 for ordinary words or 1 for active words, cf. p:dict.lookup. Otherwise pushes 0."},
            {"first", "first ( t — x )\nReturns the first component of a Tuple, cf. p:tuples. Equivalent to 0[]."},
            {"fits", "fits ( x y — ? )\nChecks whether Integer x is a signed y -bit integer (i.e., whether -2ʸ⁻¹ ≤ x<2ʸ⁻¹ for 0≤ y≤ 1023 ), and returns -1 or 0 accordingly."},
            {"forget", "forget ( — )\nForgets (removes from the dictionary) the definition of the next word scanned from the input, cf. p:dict.create."},
            {"gasrunvm", "gasrunvm ( … s c z — … x c' z' )\nA gas-aware version of runvm, cf. p:tvm.ops: invokes a new instance of TVM with both the current continuation cc and the special register c3 initialized from Slice s, and initializes special register c4 (the “root of persistent data”, cf. [ 1.4 ] ) with Cell c. Then starts the new TVM instance with the gas limit set to z. The actually consumed gas z' is returned at the top of the final Fift stack, and the final value of c4 is returned immediately below the top of the final Fift stack as another Cell c'."},
            {"gasrunvmcode", "gasrunvmcode ( … s z — … x z' )\nA gas-aware version of runvmcode, cf. p:tvm.ops: invokes a new instance of TVM with the current continuation cc initialized from Slice s and with the gas limit set to z, thus executing code s in TVM. The original Fift stack (without s ) is passed in its entirety as the initial stack of the new TVM instance. When TVM terminates, its resulting stack is used as the new Fift stack, with the exit code x and the actually consumed gas z' pushed at its top. If x is non-zero, indicating that TVM has been terminated by an unhandled exception, the next stack entry from the top contains the parameter of this exception, and x is the exception code. All other entries are removed from the stack in this case."},
            {"gasrunvmctx", "gasrunvmctx ( … s c t z — … x c' z' )\nA gas-aware version of runvmctx, cf. p:tvm.ops. Differs from gasrunmv in that it initializes c7 with Tuple t."},
            {"gasrunvmdict", "gasrunvmdict ( … s z — … x z' )\nA gas-aware version of runvmdict, cf. p:tvm.ops: invokes a new instance of TVM with the current continuation cc initialized from Slice s and sets the gas limit to z similarly to gasrunvmcode, but also initializes the special register c3 with the same value, and pushes a zero into the initial TVM stack before the TVM execution begins. The actually consumed gas is returned as an Integer z'. In a typical application Slice s consists of a subroutine selection code that uses the top-of-stack Integer to select the subroutine to be executed, thus enabling the definition and execution of several mutually-recursive subroutines (cf. [ 4.6 ] and p:asm.prog ). The selector equal to zero corresponds to the main() subroutine in a large TVM program."},
            {"halt", "halt ( x — )\nQuits to the operating system similarly to bye, but uses Integer x as the exit code, cf. p:exit.fift."},
            {"hash", "hash ( c — x )\nA deprecated version of hashu. Use hashu or hashB instead."},
            {"hashB", "hashB ( c — B )\nComputes the SHA256 -based representation hash of Cell c (cf. [ 3.1 ] ), which unambiguously defines c and all its descendants (provided there are no collisions for SHA256 ), cf. p:hash.ops. The result is returned as a Bytes value consisting of exactly 32 bytes."},
            {"hashu", "hashu ( c — x )\nComputes the SHA256 -based representation hash of Cell c similarly to hashB, but returns the result as a big-endian unsigned 256-bit Integer."},
            {"hold", "hold ( S x — S' )\nAppends to String S one UTF-8 encoded character with Unicode codepoint x. Equivalent to chr $+."},
            {"hole", "hole ( — p )\nCreates a new Box p that does not hold any value, cf. p:variables. Equivalent to null box."},
            {"i,", "i, ( b x y — b' )\nAppends the big-endian binary representation of a signed y -bit integer x to Builder b, where 0≤ y≤ 257, cf. p:builder.ops. If there is not enough room in b (i.e., if b already contains more than 1023-y data bits), or if Integer x does not fit into y bits, an exception is thrown."},
            {"i>B", "i>B ( x y — B )\nStores a signed big-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"i@", "i@ ( s x — y )\nFetches a signed big-endian x -bit integer from the first x bits of Slice s, cf. p:slice.ops. If s contains less than x data bits, an exception is thrown."},
            {"i@+", "i@+ ( s x — y s' )\nFetches a signed big-endian x -bit integer from the first x bits of Slice s similarly to i@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"i@?", "i@? ( s x — y -1 or 0 )\nFetches a signed big-endian integer from a Slice similarly to i@, but pushes integer -1 afterwards on success, cf. p:slice.ops. If there are less than x bits left in s, pushes integer 0 to indicate failure."},
            {"i@?+", "i@?+ ( s x — y s' -1 or s 0 )\nFetches a signed big-endian integer from Slice s and computes the remainder of this Slice similarly to i@+, but pushes -1 afterwards to indicate success, cf. p:slice.ops. On failure, pushes the unchanged Slice s and 0 to indicate failure."},
            {"idict!", "idict! ( v x D n — D' -1 or D 0 )\nAdds a new value v (represented by a Slice ) with key given by signed big-endian n -bit integer x into dictionary D with n -bit keys, and returns the new dictionary D' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary D and 0 are returned."},
            {"idict!+", "idict!+ ( v x D n — D' -1 or D 0 )\nAdds a new key-value pair (x,v) into dictionary D similarly to idict!, but fails if the key already exists by returning the unchanged dictionary D and 0, cf. p:hashmap.ops."},
            {"idict@", "idict@ ( x D n — v -1 or 0 )\nLooks up key represented by signed big-endian n -bit Integer x in the dictionary represented by Cell or Null D, cf. p:hashmap.ops. If the key is found, returns the corresponding value as a Slice v and -1. Otherwise returns 0."},
            {"if", "if ( x e — )\nExecutes execution token (i.e., a WordDef ) e, but only if Integer x is non-zero, cf. p:cond.ops."},
            {"ifnot", "ifnot ( x e — )\nExecutes execution token e, but only if Integer x is zero, cf. p:cond.ops."},
            {"include", "include ( S — )\nLoads and interprets a Fift source file from the path given by String S, cf. p:asm.load. If the filename S does not begin with a slash, the Fift include search path, typically taken from the FIFTPATH environment variable or the -I command-line argument of the Fift interpreter (and equal to /usr/lib/fift if both are absent), is used to locate S."},
            {"list", "list ( x₁ … xₙ n — l )\nConstructs a list l of length n with elements x₁, …, xₙ, in that order, cf. p:lists. Equivalent to null ' cons rot times."},
            {"max", "max ( x y — z )\nComputes the maximum z:=max(x,y) of two Integer s x and y. Equivalent to minmax nip."},
            {"min", "min ( x y — z )\nComputes the minimum z:=min(x,y) of two Integer s x and y. Equivalent to minmax drop."},
            {"minmax", "minmax ( x y — z t )\nComputes both the minimum z:=min(x,y) and the maximum t:=max(x,y) of two Integer s x and y."},
            {"mod", "mod ( x y — r:=x mod y )\nComputes the remainder x mod y=x-y⋅ ⌊x/y⌋ of division of x by y, cf. p:arith.op."},
            {"negate", "negate ( x — -x )\nChanges the sign of an Integer, cf. p:arith.op."},
            {"newkeypair", "newkeypair ( — B B' )\nGenerates a new Ed25519 private/public key pair, and returns both the private key B and the public key B' as 32-byte Bytes values, cf. p:ed25519.ops. The quality of the keys is good enough for testing purposes. Real applications must feed enough entropy into OpenSSL PRNG before generating Ed25519 keypairs."},
            {"nil", "nil ( — t )\nPushes the empty Tuple t=(). Equivalent to 0 tuple."},
            {"nip", "nip ( x y — y )\nRemoves the second stack entry from the top, cf. p:stack.ops. Equivalent to swap drop."},
            {"nop", "nop ( — )\nDoes nothing, cf. p:dict.lookup."},
            {"not", "not ( x — -1-x )\nComputes the bitwise complement of an Integer, cf. p:arith.op."},
            {"now", "now ( — x )\nReturns the current Unixtime as an Integer, cf. p:ed25519.ops."},
            {"null", "null ( — ot )\nPushes the Null value, cf. p:lists"},
            {"null!", "null! ( p — )\nStores a Null value into Box p. Equivalent to null swap !."},
            {"null?", "null? ( x — ? )\nChecks whether x is Null, cf. p:lists."},
            {"or", "or ( x y — x|y )\nComputes the bitwise OR of two Integer s, cf. p:arith.op."},
            {"over", "over ( x y — x y x )\nCreates a copy of the second stack entry from the top over the top-of-stack entry, cf. p:stack.ops."},
            {"pair", "pair ( x y — t )\nCreates new pair t=(x,y), cf. p:tuples. Equivalent to 2 tuple or to | rot, swap,."},
            {"pfxdict!", "pfxdict! ( v k s n — s' -1 or s 0 )\nAdds key-value pair (k,v), both represented by Slice s, into a prefix dictionary s with keys of length at most n, cf. p:hashmap.ops. On success, returns the modified dictionary s' and -1. On failure, returns the original dictionary s and 0."},
            {"pfxdict!+", "pfxdict!+ ( v k s n — s' -1 or s 0 )\nAdds key-value pair (k,v) into prefix dictionary s similarly to pfxdict!, but fails if the key already exists, cf. p:hashmap.ops."},
            {"pfxdict@", "pfxdict@ ( k s n — v -1 or 0 )\nLooks up key k (represented by a Slice ) in the prefix dictionary s with the length of keys limited by n bits, cf. p:hashmap.ops. On success, returns the value found as a Slice v and -1. On failure, returns 0."},
            {"pick", "pick ( xₙ … x₀ n — xₙ … x₀ xₙ )\nCreates a copy of the n -th entry from the top of the stack, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 0 pick is equivalent to dup, and 1 pick to over."},
            {"priv>pub", "priv>pub ( B — B' )\nComputes the public key corresponding to a private Ed25519 key, cf. p:ed25519.ops. Both the public key B' and the private key B are represented by 32-byte Bytes values."},
            {"quit", "quit ( … — )\nExits to the topmost level of the Fift interpreter (without printing an ok in interactive mode) and clears the stack, cf. p:exit.fift."},
            {"ref,", "ref, ( b c — b' )\nAppends to Builder b a reference to Cell c, cf. p:builder.ops. If b already contains four references, an exception is thrown."},
            {"ref@", "ref@ ( s — c )\nFetches the first reference from the Slice s and returns the Cell c referred to, cf. p:slice.ops. If there are no references left, throws an exception."},
            {"ref@+", "ref@+ ( s — s' c )\nFetches the first reference from the Slice s similarly to ref@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"ref@?", "ref@? ( s — c -1 or 0 )\nFetches the first reference from the Slice s similarly to ref@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"ref@?+", "ref@?+ ( s — s' c -1 or s 0 )\nSimilar to ref@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"remaining", "remaining ( s — x y )\nReturns both the number of data bits x and the number of cell references y remaining in the Slice s, cf. p:slice.ops."},
            {"reverse", "reverse ( x₁ … xₙ y₁ … yₘ n m — xₙ … x₁ y₁ … yₘ )\nReverses the order of n stack entries located immediately below the topmost m elements, where both 0≤ m,n≤ 255 are passed in the stack."},
            {"roll", "roll ( xₙ … x₀ n — x_{n-1} … x₀ xₙ )\nRotates the top n stack entries, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 1 roll is equivalent to swap, and 2 roll to rot."},
            {"rot", "rot ( x y z — y z x )\nRotates the three topmost stack entries."},
            {"runvm", "runvm ( … s c — … x c' )\nInvokes a new instance of TVM with both the current continuation cc and the special register c3 initialized from Slice s, and initializes special register c4 (the “root of persistent data”, cf. [ 1.4 ] ) with Cell c, cf. p:tvm.ops. In contrast with runvmdict, does not push an implicit zero into the initial TVM stack; if necessary, it can be explicitly passed under s. The final value of c4 is returned at the top of the final Fift stack as another Cell c'. In this way one can emulate the execution of smart contracts that inspect or modify their persistent storage."},
            {"runvmcode", "runvmcode ( … s — … x )\nInvokes a new instance of TVM with the current continuation cc initialized from Slice s, thus executing code s in TVM, cf. p:tvm.ops. The original Fift stack (without s ) is passed in its entirety as the initial stack of the new TVM instance. When TVM terminates, its resulting stack is used as the new Fift stack, with the exit code x pushed at its top. If x is non-zero, indicating that TVM has been terminated by an unhandled exception, the next stack entry from the top contains the parameter of this exception, and x is the exception code. All other entries are removed from the stack in this case."},
            {"runvmctx", "runvmctx ( … s c t — … x c' )\nA variant of runvm that also initializes c7 (the “context register” of TVM) with Tuple t, cf. p:tvm.ops."},
            {"runvmdict", "runvmdict ( … s — … x )\nInvokes a new instance of TVM with the current continuation cc initialized from Slice s similarly to runvmcode, but also initializes the special register c3 with the same value, and pushes a zero into the initial TVM stack before start, cf. p:tvm.ops. In a typical application Slice s consists of a subroutine selection code that uses the top-of-stack Integer to select the subroutine to be executed, thus enabling the definition and execution of several mutually-recursive subroutines (cf. [ 4.6 ] and p:asm.prog ). The selector equal to zero corresponds to the main() subroutine in a large TVM program."},
            {"s,", "s, ( b s — b' )\nAppends data bits and references taken from Slice s to Builder b, cf. p:builder.ops."},
            {"s>", "s> ( s — )\nThrows an exception if Slice s is non-empty, cf. p:slice.ops. It usually marks the end of the deserialization of a cell, checking whether there are any unprocessed data bits or references left."},
            {"s>c", "s>c ( s — c )\nCreates a Cell c directly from a Slice s, cf. p:slice.ops. Equivalent to <b swap s, b>."},
            {"sbitrefs", "sbitrefs ( s — x y )\nReturns both the number of data bits x and the number of cell references y remaining in Slice s, cf. p:slice.ops. Equivalent to remaining."},
            {"sbits", "sbits ( s — x )\nReturns the number of data bits x remaining in Slice s, cf. p:slice.ops."},
            {"second", "second ( t — x )\nReturns the second component of a Tuple, cf. p:tuples. Equivalent to 1[]."},
            {"sgn", "sgn ( x — y )\nComputes the sign of an Integer x (i.e., pushes 1 if x>0, -1 if x<0, and 0 if x=0 ), cf. p:int.comp. Equivalent to 0 cmp."},
            {"shash", "shash ( s — B )\nComputes the SHA256 -based representation hash of a Slice by first transforming it into a cell, cf. p:hash.ops. Equivalent to s>c hashB."},
            {"sign", "sign ( S x — S' )\nAppends a minus sign “ - ” to String S if Integer x is negative. Otherwise leaves S intact."},
            {"single", "single ( x — t )\nCreates new singleton t=(x), i.e., a one-element Tuple. Equivalent to 1 tuple."},
            {"skipspc", "skipspc ( — )\nSkips blank characters from the current input line until a non-blank or an end-of-line character is found."},
            {"smca>$", "smca>$ ( x y z — S )\nPacks a standard TON smart-contract address with workchain x (a signed 32-bit Integer ) and in-workchain address y (an unsigned 256-bit Integer ) into a 48-character string S (the human-readable representation of the address) according to flags z, cf. p:smc.addr.ops. Possible individual flags in z are: +1 for non-bounceable addresses, +2 for testnet-only addresses, and +4 for base64url output instead of base64."},
            {"space", "space ( — )\nOutputs a single space. Equivalent to bl emit or to.\" \"."},
            {"sr,", "sr, ( b s — b' )\nConstructs a new Cell containing all data and references from Slice s, and appends a reference to this cell to Builder b, cf. p:builder.ops. Equivalent to s>c ref,."},
            {"srefs", "srefs ( s — x )\nReturns the number of cell references x remaining in Slice s, cf. p:slice.ops."},
            {"swap", "swap ( x y — y x )\nInterchanges the two topmost stack entries, cf. p:stack.ops."},
            {"ten", "ten ( — 10 )\nPushes Integer constant 10."},
            {"third", "third ( t — x )\nReturns the third component of a Tuple, cf. p:tuples. Equivalent to 2[]."},
            {"times", "times ( e n — )\nExecutes execution token ( WordDef ) e exactly n times, if n≥0, cf. p:simple.loops. If n is negative, throws an exception."},
            {"triple", "triple ( x y z — t )\nCreates new triple t=(x,y,z), cf. p:tuples. Equivalent to 3 tuple."},
            {"true", "true ( — -1 )\nPushes -1 into the stack, cf. p:bool. Equivalent to -1."},
            {"tuck", "tuck ( x y — y x y )\nEquivalent to swap over, cf. p:stack.ops."},
            {"tuple", "tuple ( x₁ … xₙ n — t )\nCreates new Tuple t:=(x₁,…,xₙ) from n≥0 topmost stack values, cf. p:tuples. Equivalent to dup 1 reverse | { swap, } rot times, but more efficient."},
            {"tuple?", "tuple? ( t — ? )\nChecks whether t is a Tuple, and returns -1 or 0 accordingly."},
            {"type", "type ( s — )\nPrints a String s taken from the top of the stack into the standard output, cf. p:string.ops."},
            {"u,", "u, ( b x y — b' )\nAppends the big-endian binary representation of an unsigned y -bit integer x to Builder b, where 0≤ y≤ 256, cf. p:builder.ops. If the operation is impossible, an exception is thrown."},
            {"u>B", "u>B ( x y — B )\nStores an unsigned big-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"u@", "u@ ( s x — y )\nFetches an unsigned big-endian x -bit integer from the first x bits of Slice s, cf. p:slice.ops. If s contains less than x data bits, an exception is thrown."},
            {"u@+", "u@+ ( s x — y s' )\nFetches an unsigned big-endian x -bit integer from the first x bits of Slice s similarly to u@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"u@?", "u@? ( s x — y -1 or 0 )\nFetches an unsigned big-endian integer from a Slice similarly to u@, but pushes integer -1 afterwards on success, cf. p:slice.ops. If there are less than x bits left in s, pushes integer 0 to indicate failure."},
            {"u@?+", "u@?+ ( s x — y s' -1 or s 0 )\nFetches an unsigned big-endian integer from Slice s and computes the remainder of this Slice similarly to u@+, but pushes -1 afterwards to indicate success, cf. p:slice.ops. On failure, pushes the unchanged Slice s and 0 to indicate failure."},
            {"udict!", "udict! ( v x D n — D' -1 or D 0 )\nAdds a new value v (represented by a Slice ) with key given by big-endian unsigned n -bit integer x into dictionary D with n -bit keys, and returns the new dictionary D' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary D and 0 are returned."},
            {"udict!+", "udict!+ ( v x D n — D' -1 or D 0 )\nAdds a new key-value pair (x,v) into dictionary D similarly to udict!, but fails if the key already exists by returning the unchanged dictionary D and 0, cf. p:hashmap.ops."},
            {"udict@", "udict@ ( x D n — v -1 or 0 )\nLooks up key represented by unsigned big-endian n -bit Integer x in the dictionary represented by Cell or Null D, cf. p:hashmap.ops. If the key is found, returns the corresponding value as a Slice v and -1. Otherwise returns 0."},
            {"ufits", "ufits ( x y — ? )\nChecks whether Integer x is an unsigned y -bit integer (i.e., whether 0≤ x<2ʸ for 0≤ y≤ 1023 ), and returns -1 or 0 accordingly."},
            {"uncons", "uncons ( l — h t )\nDecomposes a non-empty list into its head and its tail, cf. p:lists. Equivalent to unpair."},
            {"undef?❬word-name❭", "undef?❬word-name❭ ( — ? )\nChecks whether the word ❬word-name❭ is undefined at execution time, and returns -1 or 0 accordingly."},
            {"unpair", "unpair ( t — x y )\nUnpacks a pair t=(x,y), cf. p:tuples. Equivalent to 2 untuple."},
            {"unsingle", "unsingle ( t — x )\nUnpacks a singleton t=(x). Equivalent to 1 untuple."},
            {"until", "until ( e — )\nAn until loop, cf. p:loops: executes WordDef e, then removes the top-of-stack integer and checks whether it is zero. If it is, then begins a new iteration of the loop by executing e. Otherwise exits the loop."},
            {"untriple", "untriple ( t — x y z )\nUnpacks a triple t=(x,y,z), cf. p:tuples. Equivalent to 3 untuple."},
            {"untuple", "untuple ( t n — x₁ … xₙ )\nReturns all components of a Tuple t=(x₁,…,xₙ), but only if its length is equal to n, cf. p:tuples. Otherwise throws an exception."},
            {"variable", "variable ( — )\nScans a blank-delimited word name S from the remainder of the input, allocates an empty Box, and defines a new ordinary word S as a constant, which will push the new Box when invoked, cf. p:variables. Equivalent to hole constant."},
            {"while", "while ( e e' — )\nA while loop, cf. p:loops: executes WordDef e, then removes and checks the top-of-stack integer. If it is zero, exits the loop. Otherwise executes WordDef e', then begins a new loop iteration by executing e and checking the exit condition afterwards."},
            {"word", "word ( x — s )\nParses a word delimited by the character with the Unicode codepoint x from the remainder of the current input line and pushes the result as a String, cf. p:string.ops. For instance, bl word abracadabra type will print the string “ abracadabra ”. If x=0, skips leading spaces, and then scans until the end of the current input line. If x=32, skips leading spaces before parsing the next word."},
            {"words", "words ( — )\nPrints the names of all words currently defined in the dictionary, cf. p:dict.lookup."},
            {"x.", "x. ( x — )\nPrints the hexadecimal representation (without the 0x prefix) of an Integer x, followed by a single space. Equivalent to x._space."},
            {"x._", "x._ ( x — )\nPrints the hexadecimal representation (without the 0x prefix) of an Integer x without any spaces. Equivalent to (x.) type."},
            {"xor", "xor ( x y — x⊕ y )\nComputes the bitwise eXclusive OR of two Integer s, cf. p:arith.op."},
            {"x{❬hex-data❭}", "x{❬hex-data❭} ( — s )\nCreates a Slice s that contains no references and up to 1023 data bits specified in ❬hex-data❭, cf. p:slice.lit. More precisely, each hex digit from ❬hex-data❭ is transformed into four binary digits in the usual fashion. After that, if the last character of ❬hex-data❭ is an underscore _, then all trailing binary zeroes and the binary one immediately preceding them are removed from the resulting binary string (cf. [ 1.0 ] for more details). For instance, x{6C_} is equivalent to b{01101}."},
            {"{", "{ ( — l )\nAn active word that increases internal variable state by one and pushes a new empty WordList into the stack, cf. p:wordlist.ops."},
            {"|", "| ( — t )\nCreates an empty Tuple t=(), cf. p:tuples. Equivalent to nil and to 0 tuple."},
            {"|+", "|+ ( s s' — s” )\nConcatenates two Slice s and s', cf. p:slice.lit. This means that the data bits of the new Slice s” are obtained by concatenating the data bits of s and s', and the list of Cell references of s” is constructed similarly by concatenating the corresponding lists for s and s'. Equivalent to <b rot s, swap s, b> <s."},
            {"|_", "|_ ( s s' — s” )\nGiven two Slice s s and s', creates a new Slice s”, which is obtained from s by appending a new reference to a Cell containing s', cf. p:slice.lit. Equivalent to <b rot s, swap s>c ref, b> <s."},
            {"}", "} ( l — e )\nAn active word that transforms a WordList l into a WordDef (an execution token) e, thus making all further modifications of l impossible, and decreases internal variable state by one; then pushes the integer 1, followed by a 'nop, cf. p:wordlist.ops. The net effect is to transform the constructed WordList into an execution token and push this execution token into the stack, either immediately or during the execution of an outer block."},
            {"NOP", "00 — NOP, does nothing."},
            {"ROT", "58 — ROT ( a b c — b c a )\nEquivalent to BLKSWAP 1,2 or to XCHG2 s2,s1."},
            {"ROTREV", "59 — ROTREV or -ROT ( a b c — c a b )\nEquivalent to BLKSWAP 2,1 or to XCHG2 s2,s2."},
            {"PICK", "60 — PICK or PUSHX, pops integer i from the stack, then performs PUSH s(i)."},
            {"ROLLX", "61 — ROLLX, pops integer i from the stack, then performs BLKSWAP 1,i."},
            {"BLKSWX", "63 — BLKSWX, pops integers i, j from the stack, then performs BLKSWAPi,j."},
            {"REVX", "64 — REVX, pops integers i, j from the stack, then performs REVERSEi,j."},
            {"DROPX", "65 — DROPX, pops integer i from the stack, then performs BLKDROPi."},
            {"TUCK", "66 — TUCK ( a b - b a b )\nEquivalent to SWAP; OVER or to XCPU s1,s1."},
            {"XCHGX", "67 — XCHGX, pops integer i from the stack, then performs XCHG s(i)."},
            {"DEPTH", "68 — DEPTH, pushes the current depth of the stack."},
            {"CHKDEPTH", "69 — CHKDEPTH, pops integer i from the stack, then checks whether there are at least i elements, generating a stack underflow exception otherwise."},
            {"ONLYTOPX", "6A — ONLYTOPX, pops integer i from the stack, then removes all but the top i elements."},
            {"ONLYX", "6B — ONLYX, pops integer i from the stack, then leaves only the bottom i elements. Approximately equivalent to DEPTH; SWAP; SUB; DROPX."},
            {"NULL", "6D — NULL or PUSHNULL ( — ot )\nPushes the only value of type Null."},
            {"ISNULL", "6E — ISNULL ( x — ? )\nChecks whether x is a Null, and returns -1 or 0 accordingly."},
            {"NIL", "6F00 — NIL ( — t )\nPushes the only Tuple t=() of length zero."},
            {"SINGLE", "6F01 — SINGLE ( x — t )\nCreates a singleton t:=(x), i.e., a Tuple of length one."},
            {"PAIR", "6F02 — PAIR or CONS ( x y — t )\nCreates pair t:=(x,y)."},
            {"TRIPLE", "6F03 — TRIPLE ( x y z — t )\nCreates triple t:=(x,y,z)."},
            {"FIRST", "6F10 — FIRST or CAR ( t — x )\nReturns the first element of a Tuple."},
            {"SECOND", "6F11 — SECOND or CDR ( t — y )\nReturns the second element of a Tuple."},
            {"THIRD", "6F12 — THIRD ( t — z )\nReturns the third element of a Tuple."},
            {"UNSINGLE", "6F21 — UNSINGLE ( t — x )\nUnpacks a singleton t=(x)."},
            {"UNPAIR", "6F22 — UNPAIR or UNCONS ( t — x y )\nUnpacks a pair t=(x,y)."},
            {"UNTRIPLE", "6F23 — UNTRIPLE ( t — x y z )\nUnpacks a triple t=(x,y,z)."},
            {"CHKTUPLE", "6F30 — CHKTUPLE ( t — )\nChecks whether t is a Tuple."},
            {"SETFIRST", "6F50 — SETFIRST ( t x — t' )\nSets the first component of Tuple t to x and returns the resulting Tuple t'."},
            {"SETSECOND", "6F51 — SETSECOND ( t x — t' )\nSets the second component of Tuple t to x and returns the resulting Tuple t'."},
            {"SETTHIRD", "6F52 — SETTHIRD ( t x — t' )\nSets the third component of Tuple t to x and returns the resulting Tuple t'."},
            {"TUPLEVAR", "6F80 — TUPLEVAR ( x₁ … xₙ n — t )\nCreates a new Tuple t of length n similarly to TUPLE, but with 0≤ n≤ 255 taken from the stack."},
            {"INDEXVAR", "6F81 — INDEXVAR ( t k — x )\nSimilar to INDEXk, but with 0≤ k≤ 254 taken from the stack."},
            {"UNTUPLEVAR", "6F82 — UNTUPLEVAR ( t n — x₁ … xₙ )\nSimilar to UNTUPLEn, but with 0≤ n≤ 255 taken from the stack."},
            {"UNPACKFIRSTVAR", "6F83 — UNPACKFIRSTVAR ( t n — x₁ … xₙ )\nSimilar to UNPACKFIRSTn, but with 0≤ n≤ 255 taken from the stack."},
            {"EXPLODEVAR", "6F84 — EXPLODEVAR ( t n — x₁ … xₘ m )\nSimilar to EXPLODEn, but with 0≤ n≤ 255 taken from the stack."},
            {"SETINDEXVAR", "6F85 — SETINDEXVAR ( t x k — t' )\nSimilar to SETINDEXk, but with 0≤ k≤ 254 taken from the stack."},
            {"INDEXVARQ", "6F86 — INDEXVARQ ( t k — x )\nSimilar to INDEXQn, but with 0≤ k≤ 254 taken from the stack."},
            {"SETINDEXVARQ", "6F87 — SETINDEXVARQ ( t x k — t' )\nSimilar to SETINDEXQk, but with 0≤ k≤ 254 taken from the stack."},
            {"TLEN", "6F88 — TLEN ( t — n )\nReturns the length of a Tuple."},
            {"QTLEN", "6F89 — QTLEN ( t — n or -1 )\nSimilar to TLEN, but returns -1 if t is not a Tuple."},
            {"ISTUPLE", "6F8A — ISTUPLE ( t — ? )\nReturns -1 or 0 depending on whether t is a Tuple."},
            {"LAST", "6F8B — LAST ( t — x )\nReturns the last element t_{|t|} of a non-empty Tuple t."},
            {"TPUSH", "6F8C — TPUSH or COMMA ( t x — t' )\nAppends a value x to a Tuple t=(x₁,…,xₙ), but only if the resulting Tuple t'=(x₁,…,xₙ,x) is of length at most 255. Otherwise throws a type check exception."},
            {"TPOP", "6F8D — TPOP ( t — t' x )\nDetaches the last element x=xₙ from a non-empty Tuple t=(x₁,…,xₙ), and returns both the resulting Tuple t'=(x₁,…,x_{n-1}) and the original last element x."},
            {"NULLSWAPIF", "6FA0 — NULLSWAPIF ( x — x or ot x )\nPushes a Null under the topmost Integer x, but only if x≠0."},
            {"NULLSWAPIFNOT", "6FA1 — NULLSWAPIFNOT ( x — x or ot x )\nPushes a Null under the topmost Integer x, but only if x=0. May be used for stack alignment after quiet primitives such as PLDUXQ."},
            {"NULLROTRIF", "6FA2 — NULLROTRIF ( x y — x y or ot x y )\nPushes a Null under the second stack entry from the top, but only if the topmost Integer y is non-zero."},
            {"NULLROTRIFNOT", "6FA3 — NULLROTRIFNOT ( x y — x y or ot x y )\nPushes a Null under the second stack entry from the top, but only if the topmost Integer y is zero. May be used for stack alignment after quiet primitives such as LDUXQ."},
            {"CADR", "6FB4 — CADR ( t — x )\nRecovers x=(t_2)₁."},
            {"CDDR", "6FB5 — CDDR ( t — x )\nRecovers x=(t_2)_2."},
            {"CADDR", "6FD4 — CADDR ( t — x )\nRecovers x= ((t_2)_2 )₁."},
            {"CDDDR", "6FD5 — CDDDR ( t — x )\nRecovers x= ((t_2)_2 )_2."},
            {"ZERO", "70 — ZERO, FALSE, or PUSHINT 0, pushes a zero."},
            {"ONE", "71 — ONE or PUSHINT 1."},
            {"TWO", "72 — TWO or PUSHINT 2."},
            {"TEN", "7A — TEN or PUSHINT 10."},
            {"TRUE", "7F — TRUE or PUSHINT -1."},
            {"PUSHNAN", "83FF — PUSHNAN, pushes a NaN."},
            {"PUSHREF", "88 — PUSHREF, pushes the first reference of cc.code into the stack as a Cell (and removes this reference from the current continuation)."},
            {"PUSHREFSLICE", "89 — PUSHREFSLICE, similar to PUSHREF, but converts the cell into a Slice."},
            {"PUSHREFCONT", "8A — PUSHREFCONT, similar to PUSHREFSLICE, but makes a simple ordinary Continuation out of the cell."},
            {"ADD", "A0 — ADD ( x y — x+y )\nAdds together two integers."},
            {"SUB", "A1 — SUB ( x y — x-y )."},
            {"SUBR", "A2 — SUBR ( x y — y-x )\nEquivalent to SWAP; SUB."},
            {"NEGATE", "A3 — NEGATE ( x — -x )\nEquivalent to MULCONST-1 or to ZERO; SUBR. Notice that it triggers an integer overflow exception if x=-2^{256}."},
            {"INC", "A4 — INC ( x — x+1 )\nEquivalent to ADDCONST 1."},
            {"DEC", "A5 — DEC ( x — x-1 )\nEquivalent to ADDCONST-1."},
            {"MUL", "A8 — MUL ( x y — xy )."},
            {"DIV", "A904 — DIV ( x y — q:= ⌊x/y⌋ )."},
            {"DIVR", "A905 — DIVR ( x y — q':= ⌊x/y+½⌋ )."},
            {"DIVC", "A906 — DIVC ( x y — q”:= ⌈x/y⌉ )."},
            {"MOD", "A908 — MOD ( x y — r )\nWhere q:= ⌊x/y⌋ , r:=x mod y:=x-yq."},
            {"DIVMOD", "A90C — DIVMOD ( x y — q r )\nWhere q:= ⌊x/y⌋ , r:=x-yq."},
            {"DIVMODR", "A90D — DIVMODR ( x y — q' r' )\nWhere q':= ⌊x/y+½⌋ , r':=x-yq'."},
            {"DIVMODC", "A90E — DIVMODC ( x y — q” r” )\nWhere q”:= ⌈x/y⌉ , r”:=x-yq”."},
            {"MULDIVR", "A985 — MULDIVR ( x y z — q' )\nWhere q'= ⌊xy/z+½⌋ ."},
            {"MULDIVMOD", "A98C — MULDIVMOD ( x y z — q r )\nWhere q:= ⌊x⋅ y/z⌋ , r:=x⋅ y mod z (same as */MOD in Forth)."},
            {"LSHIFT", "AC — LSHIFT ( x y — x⋅ 2ʸ ), 0≤ y≤ 1023."},
            {"RSHIFT", "AD — RSHIFT ( x y — ⌊x⋅ 2⁻ʸ ⌋ ), 0≤ y≤ 1023."},
            {"AND", "B0 — AND ( x y — x&y )\nBitwise “and” of two signed integers x and y, sign-extended to infinity."},
            {"OR", "B1 — OR ( x y — x∨ y )\nBitwise “or” of two integers."},
            {"XOR", "B2 — XOR ( x y — x⊕ y )\nBitwise “xor” of two integers."},
            {"NOT", "B3 — NOT ( x — x⊕-1=-1-x )\nBitwise “not” of an integer."},
            {"FITSX", "B600 — FITSX ( x c — x )\nChecks whether x is a c -bit signed integer for 0≤ c≤ 1023."},
            {"UFITSX", "B601 — UFITSX ( x c — x )\nChecks whether x is a c -bit unsigned integer for 0≤ c≤ 1023."},
            {"BITSIZE", "B602 — BITSIZE ( x — c )\nComputes smallest c≥0 such that x fits into a c -bit signed integer ( -2^{c-1}≤ c<2^{c-1} )."},
            {"UBITSIZE", "B603 — UBITSIZE ( x — c )\nComputes smallest c≥0 such that x fits into a c -bit unsigned integer ( 0≤ x<2^c ), or throws a range check exception."},
            {"MIN", "B608 — MIN ( x y — x or y )\nComputes the minimum of two integers x and y."},
            {"MAX", "B609 — MAX ( x y — x or y )\nComputes the maximum of two integers x and y."},
            {"MINMAX", "B60A — MINMAX or INTSORT2 ( x y — x y or y x )\nSorts two integers. Quiet version of this operation returns two NaN s if any of the arguments are NaN s."},
            {"ABS", "B60B — ABS ( x — |x| )\nComputes the absolute value of an integer x."},
            {"QADD", "B7A0 — QADD ( x y — x+y )\nAlways works if x and y are itInteger s, but returns a NaN if the addition cannot be performed."},
            {"QDIV", "B7A904 — QDIV ( x y — ⌊x/y⌋ )\nReturns a NaN if y=0, or if y=-1 and x=-2^{256}, or if either of x or y is a NaN."},
            {"QAND", "B7B0 — QAND ( x y — x&y )\nBitwise “and” (similar to AND ), but returns a NaN if either x or y is a NaN instead of throwing an integer overflow exception. However, if one of the arguments is zero, and the other is a NaN, the result is zero."},
            {"QOR", "B7B1 — QOR ( x y — x∨ y )\nBitwise “or”. If x=-1 or y=-1, the result is always -1, even if the other argument is a NaN."},
            {"SGN", "B8 — SGN ( x — sgn(x) ), computes the sign of an integer x: -1 if x<0, 0 if x=0, 1 if x>0."},
            {"LESS", "B9 — LESS ( x y — x<y )\nReturns -1 if x<y, 0 otherwise."},
            {"EQUAL", "BA — EQUAL ( x y — x=y )\nReturns -1 if x=y, 0 otherwise."},
            {"LEQ", "BB — LEQ ( x y — x≤ y )."},
            {"GREATER", "BC — GREATER ( x y — x>y )."},
            {"NEQ", "BD — NEQ ( x y — x≠ y )\nEquivalent to EQUAL; NOT."},
            {"GEQ", "BE — GEQ ( x y — x≥ y )\nEquivalent to LESS; NOT."},
            {"CMP", "BF — CMP ( x y — sgn(x-y) ), computes the sign of x-y: -1 if x<y, 0 if x=y, 1 if x>y. No integer overflow can occur here unless x or y is a NaN."},
            {"ISZERO", "C000 — ISZERO, checks whether an integer is zero. Corresponds to Forth's 0=."},
            {"ISNEG", "C100 — ISNEG, checks whether an integer is negative. Corresponds to Forth's 0<."},
            {"ISNPOS", "C101 — ISNPOS, checks whether an integer is non-positive."},
            {"ISPOS", "C200 — ISPOS, checks whether an integer is positive. Corresponds to Forth's 0>."},
            {"ISNNEG", "C2FF — ISNNEG, checks whether an integer is non-negative."},
            {"ISNAN", "C4 — ISNAN ( x — x=NaN )\nChecks whether x is a NaN."},
            {"CHKNAN", "C5 — CHKNAN ( x — x )\nThrows an arithmetic overflow exception if x is a NaN."},
            {"SEMPTY", "C700 — SEMPTY ( s — s=∅ )\nChecks whether a Slices is empty (i.e., contains no bits of data and no cell references)."},
            {"SDEMPTY", "C701 — SDEMPTY ( s — s≈∅ )\nChecks whether Slices has no bits of data."},
            {"SREMPTY", "C702 — SREMPTY ( s — r(s)=0 ), checks whether Slice s has no references."},
            {"SDFIRST", "C703 — SDFIRST ( s — s₀=1 )\nChecks whether the first bit of Slice s is a one."},
            {"SDLEXCMP", "C704 — SDLEXCMP ( s s' — c )\nCompares the data of s lexicographically with the data of s', returning -1, 0, or 1 depending on the result."},
            {"SDEQ", "C705 — SDEQ ( s s' — s≈ s' )\nChecks whether the data parts of s and s' coincide, equivalent to SDLEXCMP; ISZERO."},
            {"SDPFX", "C708 — SDPFX ( s s' — ? )\nChecks whether s is a prefix of s'."},
            {"SDPFXREV", "C709 — SDPFXREV ( s s' — ? )\nChecks whether s' is a prefix of s, equivalent to SWAP; SDPFX."},
            {"SDPPFX", "C70A — SDPPFX ( s s' — ? )\nChecks whether s is a proper prefix of s' (i.e., a prefix distinct from s' )."},
            {"SDPPFXREV", "C70B — SDPPFXREV ( s s' — ? )\nChecks whether s' is a proper prefix of s."},
            {"SDSFX", "C70C — SDSFX ( s s' — ? )\nChecks whether s is a suffix of s'."},
            {"SDSFXREV", "C70D — SDSFXREV ( s s' — ? )\nChecks whether s' is a suffix of s."},
            {"SDPSFX", "C70E — SDPSFX ( s s' — ? )\nChecks whether s is a proper suffix of s'."},
            {"SDPSFXREV", "C70F — SDPSFXREV ( s s' — ? )\nChecks whether s' is a proper suffix of s."},
            {"NEWC", "C8 — NEWC ( — b )\nCreates a new empty Builder."},
            {"ENDC", "C9 — ENDC ( b — c )\nConverts a Builder into an ordinary Cell."},
            {"STREF", "CC — STREF ( c b — b' )\nStores a reference to Cell c into Builder b."},
            {"STBREFR", "CD — STBREFR or ENDCST ( b b” — b )\nEquivalent to ENDC; SWAP; STREF."},
            {"STSLICE", "CE — STSLICE ( s b — b' )\nStores Slice s into Builder b."},
            {"STIX", "CF00 — STIX ( x b l — b' )\nStores a signed l -bit integer x into b for 0≤ l≤ 257."},
            {"STUX", "CF01 — STUX ( x b l — b' )\nStores an unsigned l -bit integer x into b for 0≤ l≤ 256."},
            {"STIXR", "CF02 — STIXR ( b x l — b' )\nSimilar to STIX, but with arguments in a different order."},
            {"STUXR", "CF03 — STUXR ( b x l — b' )\nSimilar to STUX, but with arguments in a different order."},
            {"STIXQ", "CF04 — STIXQ ( x b l — x b f or b' 0 )\nA quiet version of STIX. If there is no space in b, sets b'=b and f=-1. If x does not fit into l bits, sets b'=b and f=1. If the operation succeeds, b' is the new Builder and f=0. However, 0≤ l≤ 257, with a range check exception if this is not so."},
            {"STUXQ", "CF05 — STUXQ ( x b l — b' f )."},
            {"STIXRQ", "CF06 — STIXRQ ( b x l — b x f or b' 0 )."},
            {"STUXRQ", "CF07 — STUXRQ ( b x l — b x f or b' 0 )."},
            {"STBREF", "CF11 — STBREF ( b' b — b” )\nEquivalent to SWAP; STBREFREV."},
            {"STB", "CF13 — STB ( b' b — b” )\nAppends all data from Builder b' to Builder b."},
            {"STREFR", "CF14 — STREFR ( b c — b' )."},
            {"STBREFR", "CF15 — STBREFR ( b b' — b” )\nA longer encoding of STBREFR."},
            {"STSLICER", "CF16 — STSLICER ( b s — b' )."},
            {"STBR", "CF17 — STBR ( b b' — b” )\nConcatenates two Builder s, equivalent to SWAP; STB."},
            {"STREFQ", "CF18 — STREFQ ( c b — c b -1 or b' 0 )."},
            {"STBREFQ", "CF19 — STBREFQ ( b' b — b' b -1 or b” 0 )."},
            {"STSLICEQ", "CF1A — STSLICEQ ( s b — s b -1 or b' 0 )."},
            {"STBQ", "CF1B — STBQ ( b' b — b' b -1 or b” 0 )."},
            {"STREFRQ", "CF1C — STREFRQ ( b c — b c -1 or b' 0 )."},
            {"STBREFRQ", "CF1D — STBREFRQ ( b b' — b b' -1 or b” 0 )."},
            {"STSLICERQ", "CF1E — STSLICERQ ( b s — b s -1 or b” 0 )."},
            {"STBRQ", "CF1F — STBRQ ( b b' — b b' -1 or b” 0 )."},
            {"STREFCONST", "CF20 — STREFCONST, equivalent to PUSHREF; STREFR."},
            {"ENDXC", "CF23 — ENDXC ( b x — c )\nIf x≠0, creates a special or exotic cell (cf. sp:exotic.cells ) from Builder b. The type of the exotic cell must be stored in the first 8 bits of b. If x=0, it is equivalent to ENDC. Otherwise some validity checks on the data and references of b are performed before creating the exotic cell."},
            {"BBITS", "CF31 — BBITS ( b — x )\nReturns the number of data bits already stored in Builder b."},
            {"BREFS", "CF32 — BREFS ( b — y )\nReturns the number of cell references already stored in b."},
            {"BBITREFS", "CF33 — BBITREFS ( b — x y )\nReturns the numbers of both data bits and cell references in b."},
            {"BREMBITS", "CF35 — BREMBITS ( b — x' )\nReturns the number of data bits that can still be stored in b."},
            {"BREMREFS", "CF36 — BREMREFS ( b — y' )."},
            {"BREMBITREFS", "CF37 — BREMBITREFS ( b — x' y' )."},
            {"BCHKBITS", "CF39 — BCHKBITS ( b x — )\nChecks whether x bits can be stored into b, 0≤ x≤ 1023. If there is no space for x more bits in b, or if x is not within the range 0…1023, throws an exception."},
            {"BCHKREFS", "CF3A — BCHKREFS ( b y — )\nChecks whether y references can be stored into b, 0≤ y≤ 7."},
            {"BCHKBITREFS", "CF3B — BCHKBITREFS ( b x y — )\nChecks whether x bits and y references can be stored into b, 0≤ x≤ 1023, 0≤ y≤ 7."},
            {"BCHKBITSQ", "CF3D — BCHKBITSQ ( b x — ? )\nChecks whether x bits can be stored into b, 0≤ x≤ 1023."},
            {"BCHKREFSQ", "CF3E — BCHKREFSQ ( b y — ? )\nChecks whether y references can be stored into b, 0≤ y≤ 7."},
            {"BCHKBITREFSQ", "CF3F — BCHKBITREFSQ ( b x y — ? )\nChecks whether x bits and y references can be stored into b, 0≤ x≤ 1023, 0≤ y≤ 7."},
            {"STZEROES", "CF40 — STZEROES ( b n — b' )\nStores n binary zeroes into Builder b."},
            {"STONES", "CF41 — STONES ( b n — b' )\nStores n binary ones into Builder b."},
            {"STSAME", "CF42 — STSAME ( b n x — b' )\nStores n binary x es ( 0≤ x≤1 ) into Builder b."},
            {"CTOS", "D0 — CTOS ( c — s )\nConverts a Cell into a Slice. Notice that c must be either an ordinary cell, or an exotic cell (cf. sp:exotic.cells ) which is automatically loaded to yield an ordinary cell c', converted into a Slice afterwards."},
            {"ENDS", "D1 — ENDS ( s — )\nRemoves a Slice s from the stack, and throws an exception if it is not empty."},
            {"LDREF", "D4 — LDREF ( s — c s' )\nLoads a cell reference c from s."},
            {"LDREFRTOS", "D5 — LDREFRTOS ( s — s' s” )\nEquivalent to LDREF; SWAP; CTOS."},
            {"LDIX", "D700 — LDIX ( s l — x s' )\nLoads a signed l -bit ( 0≤ l≤ 257 ) integer x from Slice s, and returns the remainder of s as s'."},
            {"LDUX", "D701 — LDUX ( s l — x s' )\nLoads an unsigned l -bit integer x from (the first l bits of) s, with 0≤ l≤ 256."},
            {"PLDIX", "D702 — PLDIX ( s l — x )\nPreloads a signed l -bit integer from Slice s, for 0≤ l≤ 257."},
            {"PLDUX", "D703 — PLDUX ( s l — x )\nPreloads an unsigned l -bit integer from s, for 0≤ l≤ 256."},
            {"LDIXQ", "D704 — LDIXQ ( s l — x s' -1 or s 0 )\nQuiet version of LDIX: loads a signed l -bit integer from s similarly to LDIX, but returns a success flag, equal to -1 on success or to 0 on failure (if s does not have l bits), instead of throwing a cell underflow exception."},
            {"LDUXQ", "D705 — LDUXQ ( s l — x s' -1 or s 0 )\nQuiet version of LDUX."},
            {"PLDIXQ", "D706 — PLDIXQ ( s l — x -1 or 0 )\nQuiet version of PLDIX."},
            {"PLDUXQ", "D707 — PLDUXQ ( s l — x -1 or 0 )\nQuiet version of PLDUX."},
            {"LDSLICEX", "D718 — LDSLICEX ( s l — s” s' )\nLoads the first 0≤ l≤ 1023 bits from Slice s into a separate Slice s”, returning the remainder of s as s'."},
            {"PLDSLICEX", "D719 — PLDSLICEX ( s l — s” )\nReturns the first 0≤ l≤ 1023 bits of s as s”."},
            {"LDSLICEXQ", "D71A — LDSLICEXQ ( s l — s” s' -1 or s 0 )\nA quiet version of LDSLICEX."},
            {"PLDSLICEXQ", "D71B — PLDSLICEXQ ( s l — s' -1 or 0 )\nA quiet version of LDSLICEXQ."},
            {"SDCUTFIRST", "D720 — SDCUTFIRST ( s l — s' )\nReturns the first 0≤ l≤ 1023 bits of s. It is equivalent to PLDSLICEX."},
            {"SDSKIPFIRST", "D721 — SDSKIPFIRST ( s l — s' )\nReturns all but the first 0≤ l≤ 1023 bits of s. It is equivalent to LDSLICEX; NIP."},
            {"SDCUTLAST", "D722 — SDCUTLAST ( s l — s' )\nReturns the last 0≤ l≤ 1023 bits of s."},
            {"SDSKIPLAST", "D723 — SDSKIPLAST ( s l — s' )\nReturns all but the last 0≤ l≤ 1023 bits of s."},
            {"SDSUBSTR", "D724 — SDSUBSTR ( s l l' — s' )\nReturns 0≤ l'≤ 1023 bits of s starting from offset 0≤ l≤ 1023, thus extracting a bit substring out of the data of s."},
            {"SDBEGINSX", "D726 — SDBEGINSX ( s s' — s” )\nChecks whether s begins with (the data bits of) s', and removes s' from s on success. On failure throws a cell deserialization exception. Primitive SDPFXREV can be considered a quiet version of SDBEGINSX."},
            {"SDBEGINSXQ", "D727 — SDBEGINSXQ ( s s' — s” -1 or s 0 )\nA quiet version of SDBEGINSX."},
            {"SCUTFIRST", "D730 — SCUTFIRST ( s l r — s' )\nReturns the first 0≤ l≤ 1023 bits and first 0≤ r≤ 4 references of s."},
            {"SSKIPFIRST", "D731 — SSKIPFIRST ( s l r — s' )."},
            {"SCUTLAST", "D732 — SCUTLAST ( s l r — s' )\nReturns the last 0≤ l≤ 1023 data bits and last 0≤ r≤ 4 references of s."},
            {"SSKIPLAST", "D733 — SSKIPLAST ( s l r — s' )."},
            {"SUBSLICE", "D734 — SUBSLICE ( s l r l' r' — s' )\nReturns 0≤ l'≤ 1023 bits and 0≤ r'≤ 4 references from Slice s, after skipping the first 0≤ l≤ 1023 bits and first 0≤ r≤ 4 references."},
            {"SPLIT", "D736 — SPLIT ( s l r — s' s” )\nSplits the first 0≤ l≤ 1023 data bits and first 0≤ r≤ 4 references from s into s', returning the remainder of s as s”."},
            {"SPLITQ", "D737 — SPLITQ ( s l r — s' s” -1 or s 0 )\nA quiet version of SPLIT."},
            {"XCTOS", "D739 — XCTOS ( c — s ? )\nTransforms an ordinary or exotic cell into a Slice, as if it were an ordinary cell. A flag is returned indicating whether c is exotic. If that be the case, its type can later be deserialized from the first eight bits of s."},
            {"XLOAD", "D73A — XLOAD ( c — c' )\nLoads an exotic cell c and returns an ordinary cell c'. If c is already ordinary, does nothing. If c cannot be loaded, throws an exception."},
            {"XLOADQ", "D73B — XLOADQ ( c — c' -1 or c 0 )\nLoads an exotic cell c as XLOAD, but returns 0 on failure."},
            {"SCHKBITS", "D741 — SCHKBITS ( s l — )\nChecks whether there are at least l data bits in Slice s. If this is not the case, throws a cell deserialisation (i.e., cell underflow) exception."},
            {"SCHKREFS", "D742 — SCHKREFS ( s r — )\nChecks whether there are at least r references in Slice s."},
            {"SCHKBITREFS", "D743 — SCHKBITREFS ( s l r — )\nChecks whether there are at least l data bits and r references in Slice s."},
            {"SCHKBITSQ", "D745 — SCHKBITSQ ( s l — ? )\nChecks whether there are at least l data bits in Slice s."},
            {"SCHKREFSQ", "D746 — SCHKREFSQ ( s r — ? )\nChecks whether there are at least r references in Slice s."},
            {"SCHKBITREFSQ", "D747 — SCHKBITREFSQ ( s l r — ? )\nChecks whether there are at least l data bits and r references in Slice s."},
            {"PLDREFVAR", "D748 — PLDREFVAR ( s n — c )\nReturns the n -th cell reference of Slice s for 0≤ n≤ 3."},
            {"SBITS", "D749 — SBITS ( s — l )\nReturns the number of data bits in Slice s."},
            {"SREFS", "D74A — SREFS ( s — r )\nReturns the number of references in Slice s."},
            {"SBITREFS", "D74B — SBITREFS ( s — l r )\nReturns both the number of data bits and the number of references in s."},
            {"PLDREF", "D74C — PLDREF ( s — c )\nPreloads the first cell reference of a Slice."},
            {"LDZEROES", "D760 — LDZEROES ( s — n s' )\nReturns the count n of leading zero bits in s, and removes these bits from s."},
            {"LDONES", "D761 — LDONES ( s — n s' )\nReturns the count n of leading one bits in s, and removes these bits from s."},
            {"LDSAME", "D762 — LDSAME ( s x — n s' )\nReturns the count n of leading bits equal to 0≤ x≤ 1 in s, and removes these bits from s."},
            {"EXECUTE", "D8 — EXECUTE or CALLX ( c — )\nCalls or executes continuation c (i.e., cc🡐 c◦₀cc )."},
            {"JMPX", "D9 — JMPX ( c — )\nJumps, or transfers control, to continuation c (i.e., cc🡐 c◦₀c0, or rather cc🡐(c◦₀c0)◦₁c1 ). The remainder of the previous current continuation cc is discarded."},
            {"RET", "DB30 — RET or RETTRUE, returns to the continuation at c0 (i.e., performs cc🡐c0 ). The remainder of the current continuation cc is discarded. Approximately equivalent to PUSH c0; JMPX."},
            {"RETALT", "DB31 — RETALT or RETFALSE, returns to the continuation at c1 (i.e., cc🡐c1 ). Approximately equivalent to PUSH c1; JMPX."},
            {"BRANCH", "DB32 — BRANCH or RETBOOL ( f — )\nPerforms RETTRUE if integer f≠ 0, or RETFALSE if f=0."},
            {"CALLCC", "DB34 — CALLCC ( c — )\nCall with current continuation, transfers control to c, pushing the old value of cc into c 's stack (instead of discarding it or writing it into new c0 )."},
            {"JMPXDATA", "DB35 — JMPXDATA ( c — )\nSimilar to CALLCC, but the remainder of the current continuation (the old value of cc ) is converted into a Slice before pushing it into the stack of c."},
            {"CALLXVARARGS", "DB38 — CALLXVARARGS ( c p r — )\nSimilar to CALLXARGS, but takes -1≤ p,r≤254 from the stack. The next three operations also take p and r from the stack, both in the range -1…254."},
            {"RETVARARGS", "DB39 — RETVARARGS ( p r — )\nSimilar to RETARGS."},
            {"JMPXVARARGS", "DB3A — JMPXVARARGS ( c p r — )\nSimilar to JMPXARGS."},
            {"CALLCCVARARGS", "DB3B — CALLCCVARARGS ( c p r — )\nSimilar to CALLCCARGS."},
            {"CALLREF", "DB3C — CALLREF, equivalent to PUSHREFCONT; CALLX."},
            {"JMPREF", "DB3D — JMPREF, equivalent to PUSHREFCONT; JMPX."},
            {"JMPREFDATA", "DB3E — JMPREFDATA, equivalent to PUSHREFCONT; JMPXDATA."},
            {"RETDATA", "DB3F — RETDATA, equivalent to PUSH c0; JMPXDATA. In this way, the remainder of the current continuation is converted into a Slice and returned to the caller."},
            {"IFRET", "DC — IFRET ( f — )\nPerforms a RET, but only if integer f is non-zero. If f is a NaN, throws an integer overflow exception."},
            {"IFNOTRET", "DD — IFNOTRET ( f — )\nPerforms a RET, but only if integer f is zero."},
            {"IF", "DE — IF ( f c — )\nPerforms EXECUTE for c (i.e., executes c ), but only if integer f is non-zero. Otherwise simply discards both values."},
            {"IFNOT", "DF — IFNOT ( f c — )\nExecutes continuation c, but only if integer f is zero. Otherwise simply discards both values."},
            {"IFJMP", "E0 — IFJMP ( f c — )\nJumps to c (similarly to JMPX ), but only if f is non-zero."},
            {"IFNOTJMP", "E1 — IFNOTJMP ( f c — )\nJumps to c (similarly to JMPX ), but only if f is zero."},
            {"IFELSE", "E2 — IFELSE ( f c c' — )\nIf integer f is non-zero, executes c, otherwise executes c'. Equivalent to CONDSELCHK; EXECUTE."},
            {"IFREF", "E300 — IFREF ( f — )\nEquivalent to PUSHREFCONT; IF."},
            {"IFNOTREF", "E301 — IFNOTREF ( f — )\nEquivalent to PUSHREFCONT; IFNOT."},
            {"IFJMPREF", "E302 — IFJMPREF ( f — )\nEquivalent to PUSHREFCONT; IFJMP."},
            {"IFNOTJMPREF", "E303 — IFNOTJMPREF ( f — )\nEquivalent to PUSHREFCONT; IFNOTJMP."},
            {"CONDSEL", "E304 — CONDSEL ( f x y — x or y )\nIf integer f is non-zero, returns x, otherwise returns y. Notice that no type checks are performed on x and y; as such, it is more like a conditional stack operation. Roughly equivalent to ROT; ISZERO; INC; ROLLX; NIP."},
            {"CONDSELCHK", "E305 — CONDSELCHK ( f x y — x or y )\nSame as CONDSEL, but first checks whether x and y have the same type."},
            {"IFRETALT", "E308 — IFRETALT ( f —)\nPerforms RETALT if integer f≠0."},
            {"IFNOTRETALT", "E309 — IFNOTRETALT ( f —)\nPerforms RETALT if integer f=0."},
            {"REPEAT", "E4 — REPEAT ( n c — )\nExecutes continuation c n times, if integer n is non-negative. If n≥2^{31} or n<-2^{31}, generates a range check exception. Notice that a RET inside the code of c works as a continue, not as a break. One should use either alternative (experimental) loops or alternative RETALT (along with a SETEXITALT before the loop) to break out of a loop."},
            {"REPEATEND", "E5 — REPEATEND ( n — )\nSimilar to REPEAT, but it is applied to the current continuation cc."},
            {"UNTIL", "E6 — UNTIL ( c — )\nExecutes continuation c, then pops an integer x from the resulting stack. If x is zero, performs another iteration of this loop. The actual implementation of this primitive involves an extraordinary continuation ec_until (cf. sp:extraord.cont ) with its arguments set to the body of the loop (continuation c ) and the original current continuation cc. This extraordinary continuation is then saved into the savelist of c as c.c0 and the modified c is then executed. The other loop primitives are implemented similarly with the aid of suitable extraordinary continuations."},
            {"UNTILEND", "E7 — UNTILEND ( — )\nSimilar to UNTIL, but executes the current continuation cc in a loop. When the loop exit condition is satisfied, performs a RET."},
            {"WHILE", "E8 — WHILE ( c' c — )\nExecutes c' and pops an integer x from the resulting stack. If x is zero, exists the loop and transfers control to the original cc. If x is non-zero, executes c, and then begins a new iteration."},
            {"WHILEEND", "E9 — WHILEEND ( c' — )\nSimilar to WHILE, but uses the current continuation cc as the loop body."},
            {"AGAIN", "EA — AGAIN ( c — )\nSimilar to REPEAT, but executes c infinitely many times. A RET only begins a new iteration of the infinite loop, which can be exited only by an exception, or a RETALT (or an explicit JMPX )."},
            {"AGAINEND", "EB — AGAINEND ( — )\nSimilar to AGAIN, but performed with respect to the current continuation cc."},
            {"RETURNVARARGS", "ED10 — RETURNVARARGS ( p — )\nSimilar to RETURNARGS, but with Integer 0≤ p≤ 255 taken from the stack."},
            {"SETCONTVARARGS", "ED11 — SETCONTVARARGS ( x₁ x_2 … x_r c r n — c' )\nSimilar to SETCONTARGS, but with 0≤ r≤ 255 and -1≤ n≤ 255 taken from the stack."},
            {"SETNUMVARARGS", "ED12 — SETNUMVARARGS ( c n — c' )\nWhere -1≤ n≤ 255. If n=-1, this operation does nothing ( c'=c ). Otherwise its action is similar to SETNUMARGSn, but with n taken from the stack."},
            {"BLESS", "ED1E — BLESS ( s — c )\nTransforms a Slice s into a simple ordinary continuation c, with c.code=s and an empty stack and savelist."},
            {"BLESSVARARGS", "ED1F — BLESSVARARGS ( x₁ … x_r s r n — c )\nEquivalent to ROT; BLESS; ROTREV; SETCONTVARARGS."},
            {"PUSHCTRX", "EDE0 — PUSHCTRX ( i — x )\nSimilar to PUSHCTR c(i), but with i, 0≤ i≤255, taken from the stack. Notice that this primitive is one of the few “exotic” primitives, which are not polymorphic like stack manipulation primitives, and at the same time do not have well-defined types of parameters and return values, because the type of x depends on i."},
            {"POPCTRX", "EDE1 — POPCTRX ( x i — )\nSimilar to POPCTR c(i), but with 0≤ i≤255 from the stack."},
            {"SETCONTCTRX", "EDE2 — SETCONTCTRX ( x c i — c' )\nSimilar to SETCONTCTR c(i), but with 0≤ i≤ 255 from the stack."},
            {"COMPOS", "EDF0 — COMPOS or BOOLAND ( c c' — c” )\nComputes the composition c◦₀c', which has the meaning of “perform c, and, if successful, perform c' ” (if c is a boolean circuit) or simply “perform c, then c' ”. Equivalent to SWAP; SETCONT c0."},
            {"COMPOSALT", "EDF1 — COMPOSALT or BOOLOR ( c c' — c” )\nComputes the alternative composition c◦₁ c', which has the meaning of “perform c, and, if not successful, perform c' ” (if c is a boolean circuit). Equivalent to SWAP; SETCONT c1."},
            {"COMPOSBOTH", "EDF2 — COMPOSBOTH ( c c' — c” )\nComputes (c◦₀c')◦₁c', which has the meaning of “compute boolean circuit c, then compute c', regardless of the result of c ”."},
            {"ATEXIT", "EDF3 — ATEXIT ( c — )\nSets c0🡐 c◦₀c0. In other words, c will be executed before exiting current subroutine."},
            {"ATEXITALT", "EDF4 — ATEXITALT ( c — )\nSets c1🡐 c◦₁c1. In other words, c will be executed before exiting current subroutine by its alternative return path."},
            {"SETEXITALT", "EDF5 — SETEXITALT ( c — )\nSets c1🡐 (c◦₀c0)◦₁c1. In this way, a subsequent RETALT will first execute c, then transfer control to the original c0. This can be used, for instance, to exit from nested loops."},
            {"THENRET", "EDF6 — THENRET ( c — c' )\nComputes c':=c◦₀c0"},
            {"THENRETALT", "EDF7 — THENRETALT ( c — c' )\nComputes c':=c◦₀c1"},
            {"INVERT", "EDF8 — INVERT ( — )\nInterchanges c0 and c1."},
            {"BOOLEVAL", "EDF9 — BOOLEVAL ( c — ? )\nPerforms cc🡐 (c◦₀((PUSH-1)◦₀cc) )◦₁((PUSH0)◦₀cc). If c represents a boolean circuit, the net effect is to evaluate it and push either -1 or 0 into the stack before continuing."},
            {"THROWANY", "F2F0 — THROWANY ( n — 0 n )\nThrows exception 0≤ n<2^{16} with parameter zero. Approximately equivalent to PUSHINT 0; SWAP; THROWARGANY."},
            {"THROWARGANY", "F2F1 — THROWARGANY ( x n — x n )\nThrows exception 0≤ n<2^{16} with parameter x, transferring control to the continuation in c2. Approximately equivalent to PUSH c2; JMPXARGS 2."},
            {"THROWANYIF", "F2F2 — THROWANYIF ( n f — )\nThrows exception 0≤ n<2^{16} with parameter zero only if f≠0."},
            {"THROWARGANYIF", "F2F3 — THROWARGANYIF ( x n f — )\nThrows exception 0≤ n<2^{16} with parameter x only if f≠0."},
            {"THROWANYIFNOT", "F2F4 — THROWANYIFNOT ( n f — )\nThrows exception 0≤ n<2^{16} with parameter zero only if f=0."},
            {"THROWARGANYIFNOT", "F2F5 — THROWARGANYIFNOT ( x n f — )\nThrows exception 0≤ n<2^{16} with parameter x only if f=0."},
            {"TRY", "F2FF — TRY ( c c' — )\nSets c2 to c', first saving the old value of c2 both into the savelist of c' and into the savelist of the current continuation, which is stored into c.c0 and c'.c0. Then runs c similarly to EXECUTE. If c does not throw any exceptions, the original value of c2 is automatically restored on return from c. If an exception occurs, the execution is transferred to c', but the original value of c2 is restored in the process, so that c' can re-throw the exception by THROWANY if it cannot handle it by itself."},
            {"NEWDICT", "6D — NEWDICT ( — D )\nReturns a new empty dictionary. It is an alternative mnemonics for PUSHNULL, cf. sp:null.ops."},
            {"DICTEMPTY", "6E — DICTEMPTY ( D — ? )\nChecks whether dictionary D is empty, and returns -1 or 0 accordingly. It is an alternative mnemonics for ISNULL, cf. sp:null.ops."},
            {"STDICTS", "CE — STDICTS ( s b — b' )\nStores a Slice -represented dictionary s into Builder b. It is actually a synonym for STSLICE."},
            {"STDICT", "F400 — STDICT or STOPTREF ( D b — b' )\nStores dictionary D into Builder b, returing the resulting Builder b'. In other words, if D is a cell, performs STONE and STREF; if D is Null, performs NIP and STZERO; otherwise throws a type checking exception."},
            {"SKIPDICT", "F401 — SKIPDICT or SKIPOPTREF ( s — s' )\nEquivalent to LDDICT; NIP."},
            {"LDDICTS", "F402 — LDDICTS ( s — s' s” )\nLoads (parses) a ( Slice -represented) dictionary s' from Slice s, and returns the remainder of s as s”. This is a “split function” for all HashmapE(n,X) dictionary types."},
            {"PLDDICTS", "F403 — PLDDICTS ( s — s' )\nPreloads a ( Slice -represented) dictionary s' from Slice s. Approximately equivalent to LDDICTS; DROP."},
            {"LDDICT", "F404 — LDDICT or LDOPTREF ( s — D s' )\nLoads (parses) a dictionary D from Slice s, and returns the remainder of s as s'. May be applied to dictionaries or to values of arbitrary (^Y)^? types."},
            {"PLDDICT", "F405 — PLDDICT or PLDOPTREF ( s — D )\nPreloads a dictionary D from Slice s. Approximately equivalent to LDDICT; DROP."},
            {"LDDICTQ", "F406 — LDDICTQ ( s — D s' -1 or s 0 )\nA quiet version of LDDICT."},
            {"PLDDICTQ", "F407 — PLDDICTQ ( s — D -1 or 0 )\nA quiet version of PLDDICT."},
            {"DICTGET", "F40A — DICTGET ( k D n — x -1 or 0 )\nLooks up key k (represented by a Slice, the first 0≤ n≤ 1023 data bits of which are used as a key) in dictionary D of type HashmapE(n,X) with n -bit keys. On success, returns the value found as a Slice x."},
            {"DICTGETREF", "F40B — DICTGETREF ( k D n — c -1 or 0 )\nSimilar to DICTGET, but with a LDREF; ENDS applied to x on success. This operation is useful for dictionaries of type HashmapE(n,^Y)."},
            {"DICTIGET", "F40C — DICTIGET ( i D n — x -1 or 0 )\nSimilar to DICTGET, but with a signed (big-endian) n -bit Integer i as a key. If i does not fit into n bits, returns 0. If i is a NaN, throws an integer overflow exception."},
            {"DICTIGETREF", "F40D — DICTIGETREF ( i D n — c -1 or 0 )\nCombines DICTIGET with DICTGETREF: it uses signed n -bit Integer i as a key and returns a Cell instead of a Slice on success."},
            {"DICTUGET", "F40E — DICTUGET ( i D n — x -1 or 0 )\nSimilar to DICTIGET, but with unsigned (big-endian) n -bit Integer i used as a key."},
            {"DICTUGETREF", "F40F — DICTUGETREF ( i D n — c -1 or 0 )\nSimilar to DICTIGETREF, but with an unsigned n -bit Integer key i."},
            {"DICTSET", "F412 — DICTSET ( x k D n — D' )\nSets the value associated with n -bit key k (represented by a Slice as in DICTGET ) in dictionary D (also represented by a Slice ) to value x (again a Slice ), and returns the resulting dictionary as D'."},
            {"DICTSETREF", "F413 — DICTSETREF ( c k D n — D' )\nSimilar to DICTSET, but with the value set to a reference to Cell c."},
            {"DICTISET", "F414 — DICTISET ( x i D n — D' )\nSimilar to DICTSET, but with the key represented by a (big-endian) signed n -bit integer i. If i does not fit into n bits, a range check exception is generated."},
            {"DICTISETREF", "F415 — DICTISETREF ( c i D n — D' )\nSimilar to DICTSETREF, but with the key a signed n -bit integer as in DICTISET."},
            {"DICTUSET", "F416 — DICTUSET ( x i D n — D' )\nSimilar to DICTISET, but with i an unsigned n -bit integer."},
            {"DICTUSETREF", "F417 — DICTUSETREF ( c i D n — D' )\nSimilar to DICTISETREF, but with i unsigned."},
            {"DICTSETGET", "F41A — DICTSETGET ( x k D n — D' y -1 or D' 0 )\nCombines DICTSET with DICTGET: it sets the value corresponding to key k to x, but also returns the old value y associated with the key in question, if present."},
            {"DICTSETGETREF", "F41B — DICTSETGETREF ( c k D n — D' c' -1 or D' 0 )\nCombines DICTSETREF with DICTGETREF similarly to DICTSETGET."},
            {"DICTISETGET", "F41C — DICTISETGET ( x i D n — D' y -1 or D' 0 )\nSimilar to DICTSETGET, but with the key represented by a big-endian signed n -bit Integer i."},
            {"DICTISETGETREF", "F41D — DICTISETGETREF ( c i D n — D' c' -1 or D' 0 )\nA version of DICTSETGETREF with signed Integer i as a key."},
            {"DICTUSETGET", "F41E — DICTUSETGET ( x i D n — D' y -1 or D' 0 )\nSimilar to DICTISETGET, but with i an unsigned n -bit integer."},
            {"DICTUSETGETREF", "F41F — DICTUSETGETREF ( c i D n — D' c' -1 or D' 0 )."},
            {"DICTREPLACE", "F422 — DICTREPLACE ( x k D n — D' -1 or D 0 )\nA scReplace operation, which is similar to DICTSET, but sets the value of key k in dictionary D to x only if the key k was already present in D."},
            {"DICTREPLACEREF", "F423 — DICTREPLACEREF ( c k D n — D' -1 or D 0 )\nA scReplace counterpart of DICTSETREF."},
            {"DICTIREPLACE", "F424 — DICTIREPLACE ( x i D n — D' -1 or D 0 )\nA version of DICTREPLACE with signed n -bit Integer i used as a key."},
            {"DICTIREPLACEREF", "F425 — DICTIREPLACEREF ( c i D n — D' -1 or D 0 )."},
            {"DICTUREPLACE", "F426 — DICTUREPLACE ( x i D n — D' -1 or D 0 )."},
            {"DICTUREPLACEREF", "F427 — DICTUREPLACEREF ( c i D n — D' -1 or D 0 )."},
            {"DICTREPLACEGET", "F42A — DICTREPLACEGET ( x k D n — D' y -1 or D 0 )\nA scReplace counterpart of DICTSETGET: on success, also returns the old value associated with the key in question."},
            {"DICTREPLACEGETREF", "F42B — DICTREPLACEGETREF ( c k D n — D' c' -1 or D 0 )."},
            {"DICTIREPLACEGET", "F42C — DICTIREPLACEGET ( x i D n — D' y -1 or D 0 )."},
            {"DICTIREPLACEGETREF", "F42D — DICTIREPLACEGETREF ( c i D n — D' c' -1 or D 0 )."},
            {"DICTUREPLACEGET", "F42E — DICTUREPLACEGET ( x i D n — D' y -1 or D 0 )."},
            {"DICTUREPLACEGETREF", "F42F — DICTUREPLACEGETREF ( c i D n — D' c' -1 or D 0 )."},
            {"DICTADD", "F432 — DICTADD ( x k D n — D' -1 or D 0 )\nAn scAdd counterpart of DICTSET: sets the value associated with key k in dictionary D to x, but only if it is not already present in D."},
            {"DICTADDREF", "F433 — DICTADDREF ( c k D n — D' -1 or D 0 )."},
            {"DICTIADD", "F434 — DICTIADD ( x i D n — D' -1 or D 0 )."},
            {"DICTIADDREF", "F435 — DICTIADDREF ( c i D n — D' -1 or D 0 )."},
            {"DICTUADD", "F436 — DICTUADD ( x i D n — D' -1 or D 0 )."},
            {"DICTUADDREF", "F437 — DICTUADDREF ( c i D n — D' -1 or D 0 )."},
            {"DICTADDGET", "F43A — DICTADDGET ( x k D n — D' -1 or D y 0 )\nAn scAdd counterpart of DICTSETGET: sets the value associated with key k in dictionary D to x, but only if key k is not already present in D. Otherwise, just returns the old value y without changing the dictionary."},
            {"DICTADDGETREF", "F43B — DICTADDGETREF ( c k D n — D' -1 or D c' 0 )\nAn scAdd counterpart of DICTSETGETREF."},
            {"DICTIADDGET", "F43C — DICTIADDGET ( x i D n — D' -1 or D y 0 )."},
            {"DICTIADDGETREF", "F43D — DICTIADDGETREF ( c i D n — D' -1 or D c' 0 )."},
            {"DICTUADDGET", "F43E — DICTUADDGET ( x i D n — D' -1 or D y 0 )."},
            {"DICTUADDGETREF", "F43F — DICTUADDGETREF ( c i D n — D' -1 or D c' 0 )."},
            {"DICTSETB", "F441 — DICTSETB ( b k D n — D' )."},
            {"DICTISETB", "F442 — DICTISETB ( b i D n — D' )."},
            {"DICTUSETB", "F443 — DICTUSETB ( b i D n — D' )."},
            {"DICTSETGETB", "F445 — DICTSETGETB ( b k D n — D' y -1 or D' 0 )."},
            {"DICTISETGETB", "F446 — DICTISETGETB ( b i D n — D' y -1 or D' 0 )."},
            {"DICTUSETGETB", "F447 — DICTUSETGETB ( b i D n — D' y -1 or D' 0 )."},
            {"DICTREPLACEB", "F449 — DICTREPLACEB ( b k D n — D' -1 or D 0 )."},
            {"DICTIREPLACEB", "F44A — DICTIREPLACEB ( b i D n — D' -1 or D 0 )."},
            {"DICTUREPLACEB", "F44B — DICTUREPLACEB ( b i D n — D' -1 or D 0 )."},
            {"DICTREPLACEGETB", "F44D — DICTREPLACEGETB ( b k D n — D' y -1 or D 0 )."},
            {"DICTIREPLACEGETB", "F44E — DICTIREPLACEGETB ( b i D n — D' y -1 or D 0 )."},
            {"DICTUREPLACEGETB", "F44F — DICTUREPLACEGETB ( b i D n — D' y -1 or D 0 )."},
            {"DICTADDB", "F451 — DICTADDB ( b k D n — D' -1 or D 0 )."},
            {"DICTIADDB", "F452 — DICTIADDB ( b i D n — D' -1 or D 0 )."},
            {"DICTUADDB", "F453 — DICTUADDB ( b i D n — D' -1 or D 0 )."},
            {"DICTADDGETB", "F455 — DICTADDGETB ( b k D n — D' -1 or D y 0 )."},
            {"DICTIADDGETB", "F456 — DICTIADDGETB ( b i D n — D' -1 or D y 0 )."},
            {"DICTUADDGETB", "F457 — DICTUADDGETB ( b i D n — D' -1 or D y 0 )."},
            {"DICTDEL", "F459 — DICTDEL ( k D n — D' -1 or D 0 )\nDeletes n -bit key, represented by a Slice k, from dictionary D. If the key is present, returns the modified dictionary D' and the success flag -1. Otherwise, returns the original dictionary D and 0."},
            {"DICTIDEL", "F45A — DICTIDEL ( i D n — D' ? )\nA version of DICTDEL with the key represented by a signed n -bit Integer i. If i does not fit into n bits, simply returns D 0 (“key not found, dictionary unmodified”)."},
            {"DICTUDEL", "F45B — DICTUDEL ( i D n — D' ? )\nSimilar to DICTIDEL, but with i an unsigned n -bit integer."},
            {"DICTDELGET", "F462 — DICTDELGET ( k D n — D' x -1 or D 0 )\nDeletes n -bit key, represented by a Slice k, from dictionary D. If the key is present, returns the modified dictionary D', the original value x associated with the key k (represented by a Slice ), and the success flag -1. Otherwise, returns the original dictionary D and 0."},
            {"DICTDELGETREF", "F463 — DICTDELGETREF ( k D n — D' c -1 or D 0 )\nSimilar to DICTDELGET, but with LDREF; ENDS applied to x on success, so that the value returned c is a Cell."},
            {"DICTIDELGET", "F464 — DICTIDELGET ( i D n — D' x -1 or D 0 )\nA variant of primitive DICTDELGET with signed n -bit integer i as a key."},
            {"DICTIDELGETREF", "F465 — DICTIDELGETREF ( i D n — D' c -1 or D 0 )\nA variant of primitive DICTIDELGET returning a Cell instead of a Slice."},
            {"DICTUDELGET", "F466 — DICTUDELGET ( i D n — D' x -1 or D 0 )\nA variant of primitive DICTDELGET with unsigned n -bit integer i as a key."},
            {"DICTUDELGETREF", "F467 — DICTUDELGETREF ( i D n — D' c -1 or D 0 )\nA variant of primitive DICTUDELGET returning a Cell instead of a Slice."},
            {"DICTGETOPTREF", "F469 — DICTGETOPTREF ( k D n — c^? )\nA variant of DICTGETREF that returns Null instead of the value c^? if the key k is absent from dictionary D."},
            {"DICTIGETOPTREF", "F46A — DICTIGETOPTREF ( i D n — c^? )\nSimilar to DICTGETOPTREF, but with the key given by signed n -bit Integer i. If the key i is out of range, also returns Null."},
            {"DICTUGETOPTREF", "F46B — DICTUGETOPTREF ( i D n — c^? )\nSimilar to DICTGETOPTREF, but with the key given by unsigned n -bit Integer i."},
            {"DICTSETGETOPTREF", "F46D — DICTSETGETOPTREF ( c^? k D n — D' ć^? )\nA variant of both DICTGETOPTREF and DICTSETGETREF that sets the value corresponding to key k in dictionary D to c^? (if c^? is Null, then the key is deleted instead), and returns the old value ć^? (if the key k was absent before, returns Null instead)."},
            {"DICTISETGETOPTREF", "F46E — DICTISETGETOPTREF ( c^? i D n — D' ć^? )\nSimilar to primitive DICTSETGETOPTREF, but using signed n -bit Integer i as a key. If i does not fit into n bits, throws a range checking exception."},
            {"DICTUSETGETOPTREF", "F46F — DICTUSETGETOPTREF ( c^? i D n — D' ć^? )\nSimilar to primitive DICTSETGETOPTREF, but using unsigned n -bit Integer i as a key."},
            {"PFXDICTSET", "F470 — PFXDICTSET ( x k D n — D' -1 or D 0 )."},
            {"PFXDICTREPLACE", "F471 — PFXDICTREPLACE ( x k D n — D' -1 or D 0 )."},
            {"PFXDICTADD", "F472 — PFXDICTADD ( x k D n — D' -1 or D 0 )."},
            {"PFXDICTDEL", "F473 — PFXDICTDEL ( k D n — D' -1 or D 0 )."},
            {"DICTGETNEXT", "F474 — DICTGETNEXT ( k D n — x' k' -1 or 0 )\nComputes the minimal key k' in dictionary D that is lexicographically greater than k, and returns k' (represented by a Slice ) along with associated value x' (also represented by a Slice )."},
            {"DICTGETNEXTEQ", "F475 — DICTGETNEXTEQ ( k D n — x' k' -1 or 0 )\nSimilar to DICTGETNEXT, but computes the minimal key k' that is lexicographically greater than or equal to k."},
            {"DICTGETPREV", "F476 — DICTGETPREV ( k D n — x' k' -1 or 0 )\nSimilar to DICTGETNEXT, but computes the maximal key k' lexicographically smaller than k."},
            {"DICTGETPREVEQ", "F477 — DICTGETPREVEQ ( k D n — x' k' -1 or 0 )\nSimilar to DICTGETPREV, but computes the maximal key k' lexicographically smaller than or equal to k."},
            {"DICTIGETNEXT", "F478 — DICTIGETNEXT ( i D n — x' i' -1 or 0 )\nSimilar to DICTGETNEXT, but interprets all keys in dictionary D as big-endian signed n -bit integers, and computes the minimal key i' that is larger than Integer i (which does not necessarily fit into n bits)."},
            {"DICTIGETNEXTEQ", "F479 — DICTIGETNEXTEQ ( i D n — x' i' -1 or 0 )."},
            {"DICTIGETPREV", "F47A — DICTIGETPREV ( i D n — x' i' -1 or 0 )."},
            {"DICTIGETPREVEQ", "F47B — DICTIGETPREVEQ ( i D n — x' i' -1 or 0 )."},
            {"DICTUGETNEXT", "F47C — DICTUGETNEXT ( i D n — x' i' -1 or 0 )\nSimilar to DICTGETNEXT, but interprets all keys in dictionary D as big-endian unsigned n -bit integers, and computes the minimal key i' that is larger than Integer i (which does not necessarily fit into n bits, and is not necessarily non-negative)."},
            {"DICTUGETNEXTEQ", "F47D — DICTUGETNEXTEQ ( i D n — x' i' -1 or 0 )."},
            {"DICTUGETPREV", "F47E — DICTUGETPREV ( i D n — x' i' -1 or 0 )."},
            {"DICTUGETPREVEQ", "F47F — DICTUGETPREVEQ ( i D n — x' i' -1 or 0 )."},
            {"DICTMIN", "F482 — DICTMIN ( D n — x k -1 or 0 )\nComputes the minimal key k (represented by a Slice with n data bits) in dictionary D, and returns k along with the associated value x."},
            {"DICTMINREF", "F483 — DICTMINREF ( D n — c k -1 or 0 )\nSimilar to DICTMIN, but returns the only reference in the value as a Cell c."},
            {"DICTIMIN", "F484 — DICTIMIN ( D n — x i -1 or 0 )\nSomewhat similar to DICTMIN, but computes the minimal key i under the assumption that all keys are big-endian signed n -bit integers. Notice that the key and value returned may differ from those computed by DICTMIN and DICTUMIN."},
            {"DICTIMINREF", "F485 — DICTIMINREF ( D n — c i -1 or 0 )."},
            {"DICTUMIN", "F486 — DICTUMIN ( D n — x i -1 or 0 )\nSimilar to DICTMIN, but returns the key as an unsigned n -bit Integer i."},
            {"DICTUMINREF", "F487 — DICTUMINREF ( D n — c i -1 or 0 )."},
            {"DICTMAX", "F48A — DICTMAX ( D n — x k -1 or 0 )\nComputes the maximal key k (represented by a Slice with n data bits) in dictionary D, and returns k along with the associated value x."},
            {"DICTMAXREF", "F48B — DICTMAXREF ( D n — c k -1 or 0 )."},
            {"DICTIMAX", "F48C — DICTIMAX ( D n — x i -1 or 0 )."},
            {"DICTIMAXREF", "F48D — DICTIMAXREF ( D n — c i -1 or 0 )."},
            {"DICTUMAX", "F48E — DICTUMAX ( D n — x i -1 or 0 )."},
            {"DICTUMAXREF", "F48F — DICTUMAXREF ( D n — c i -1 or 0 )."},
            {"DICTREMMIN", "F492 — DICTREMMIN ( D n — D' x k -1 or D 0 )\nComputes the minimal key k (represented by a Slice with n data bits) in dictionary D, removes k from the dictionary, and returns k along with the associated value x and the modified dictionary D'."},
            {"DICTREMMINREF", "F493 — DICTREMMINREF ( D n — D' c k -1 or D 0 )\nSimilar to DICTREMMIN, but returns the only reference in the value as a Cell c."},
            {"DICTIREMMIN", "F494 — DICTIREMMIN ( D n — D' x i -1 or D 0 )\nSomewhat similar to DICTREMMIN, but computes the minimal key i under the assumption that all keys are big-endian signed n -bit integers. Notice that the key and value returned may differ from those computed by DICTREMMIN and DICTUREMMIN."},
            {"DICTIREMMINREF", "F495 — DICTIREMMINREF ( D n — D' c i -1 or D 0 )."},
            {"DICTUREMMIN", "F496 — DICTUREMMIN ( D n — D' x i -1 or D 0 )\nSimilar to DICTREMMIN, but returns the key as an unsigned n -bit Integer i."},
            {"DICTUREMMINREF", "F497 — DICTUREMMINREF ( D n — D' c i -1 or D 0 )."},
            {"DICTREMMAX", "F49A — DICTREMMAX ( D n — D' x k -1 or D 0 )\nComputes the maximal key k (represented by a Slice with n data bits) in dictionary D, removes k from the dictionary, and returns k along with the associated value x and the modified dictionary D'."},
            {"DICTREMMAXREF", "F49B — DICTREMMAXREF ( D n — D' c k -1 or D 0 )."},
            {"DICTIREMMAX", "F49C — DICTIREMMAX ( D n — D' x i -1 or D 0 )."},
            {"DICTIREMMAXREF", "F49D — DICTIREMMAXREF ( D n — D' c i -1 or D 0 )."},
            {"DICTUREMMAX", "F49E — DICTUREMMAX ( D n — D' x i -1 or D 0 )."},
            {"DICTUREMMAXREF", "F49F — DICTUREMMAXREF ( D n — D' c i -1 or D 0 )."},
            {"DICTIGETJMP", "F4A0 — DICTIGETJMP ( i D n — )\nSimilar to DICTIGET (cf. sp:prim.dict.get ), but with x BLESS ed into a continuation with a subsequent JMPX to it on success. On failure, does nothing. This is useful for implementing switch / case constructions."},
            {"DICTUGETJMP", "F4A1 — DICTUGETJMP ( i D n — )\nSimilar to DICTIGETJMP, but performs DICTUGET instead of DICTIGET."},
            {"DICTIGETEXEC", "F4A2 — DICTIGETEXEC ( i D n — )\nSimilar to DICTIGETJMP, but with EXECUTE instead of JMPX."},
            {"DICTUGETEXEC", "F4A3 — DICTUGETEXEC ( i D n — )\nSimilar to DICTUGETJMP, but with EXECUTE instead of JMPX."},
            {"PFXDICTGETQ", "F4A8 — PFXDICTGETQ ( s D n — s' x s” -1 or s 0 )\nLooks up the unique prefix of Slice s present in the prefix code dictionary (cf. sp:pfx.dict.tlb ) represented by Cell^? D and 0≤ n≤ 1023. If found, the prefix of s is returned as s', and the corresponding value (also a Slice ) as x. The remainder of s is returned as a Slice s”. If no prefix of s is a key in prefix code dictionary D, returns the unchanged s and a zero flag to indicate failure."},
            {"PFXDICTGET", "F4A9 — PFXDICTGET ( s D n — s' x s” )\nSimilar to PFXDICTGET, but throws a cell deserialization failure exception on failure."},
            {"PFXDICTGETJMP", "F4AA — PFXDICTGETJMP ( s D n — s' s” or s )\nSimilar to PFXDICTGETQ, but on success BLESS es the value x into a Continuation and transfers control to it as if by a JMPX. On failure, returns s unchanged and continues execution."},
            {"PFXDICTGETEXEC", "F4AB — PFXDICTGETEXEC ( s D n — s' s” )\nSimilar to PFXDICTGETJMP, but EXEC utes the continuation found instead of jumping to it. On failure, throws a cell deserialization exception."},
            {"SUBDICTGET", "F4B1 — SUBDICTGET ( k l D n — D' )\nConstructs a subdictionary consisting of all keys beginning with prefix k (represented by a Slice, the first 0≤ l≤ n≤ 1023 data bits of which are used as a key) of length l in dictionary D of type HashmapE(n,X) with n -bit keys. On success, returns the new subdictionary of the same type HashmapE(n,X) as a Slice D'."},
            {"SUBDICTIGET", "F4B2 — SUBDICTIGET ( x l D n — D' )\nVariant of SUBDICTGET with the prefix represented by a signed big-endian l -bit Integer x, where necessarily l≤257."},
            {"SUBDICTUGET", "F4B3 — SUBDICTUGET ( x l D n — D' )\nVariant of SUBDICTGET with the prefix represented by an unsigned big-endian l -bit Integer x, where necessarily l≤256."},
            {"SUBDICTRPGET", "F4B5 — SUBDICTRPGET ( k l D n — D' )\nSimilar to SUBDICTGET, but removes the common prefix k from all keys of the new dictionary D', which becomes of type HashmapE(n-l,X)."},
            {"SUBDICTIRPGET", "F4B6 — SUBDICTIRPGET ( x l D n — D' )\nVariant of SUBDICTRPGET with the prefix represented by a signed big-endian l -bit Integer x, where necessarily l≤257."},
            {"SUBDICTURPGET", "F4B7 — SUBDICTURPGET ( x l D n — D' )\nVariant of SUBDICTRPGET with the prefix represented by an unsigned big-endian l -bit Integer x, where necessarily l≤256."},
            {"ACCEPT", "F800 — ACCEPT, sets current gas limit g_l to its maximal allowed value gₘ, and resets the gas credit g_c to zero (cf. p:tvm.state )\nDecreasing the value of g_r by g_c in the process. In other words, the current smart contract agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves."},
            {"SETGASLIMIT", "F801 — SETGASLIMIT ( g — )\nSets current gas limit g_l to the minimum of g and gₘ, and resets the gas credit g_c to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of g_l, an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that SETGASLIMIT with an argument g≥ 2^{63}-1 is equivalent to ACCEPT."},
            {"BUYGAS", "F802 — BUYGAS ( x — )\nComputes the amount of gas that can be bought for x nanograms, and sets g_l accordingly in the same way as SETGASLIMIT."},
            {"GRAMTOGAS", "F804 — GRAMTOGAS ( x — g )\nComputes the amount of gas that can be bought for x nanograms. If x is negative, returns 0. If g exceeds 2^{63}-1, it is replaced with this value."},
            {"GASTOGRAM", "F805 — GASTOGRAM ( g — x )\nComputes the price of g gas in nanograms."},
            {"COMMIT", "F80F — COMMIT ( — )\nCommits the current state of registers c4 (“persistent data”) and c5 (“actions”) so that the current execution is considered “successful” with the saved values even if an exception is thrown later."},
            {"NOW", "F823 — NOW ( — x )\nReturns the current Unix time as an Integer. If it is impossible to recover the requested value starting from c7, throws a type checking or range checking exception as appropriate. Equivalent to GETPARAM 3."},
            {"BLOCKLT", "F824 — BLOCKLT ( — x )\nReturns the starting logical time of the current block. Equivalent to GETPARAM 4."},
            {"LTIME", "F825 — LTIME ( — x )\nReturns the logical time of the current transaction. Equivalent to GETPARAM 5."},
            {"BALANCE", "F826 — BALANCE ( — t )\nReturns the remaining balance of the smart contract as a Tuple consisting of an Integer (the remaining Gram balance in nanograms) and a Maybe Cell (a dictionary with 32-bit keys representing the balance of “extra currencies”). Equivalent to GETPARAM 6. Note that RAW primitives such as SENDRAWMSG do not update this field."},
            {"RANDSEED", "F827 — RANDSEED ( — x )\nReturns the current random seed as an unsigned 256-bit Integer. Equivalent to GETPARAM 7."},
            {"MYADDR", "F828 — MYADDR ( — s )\nReturns the internal address of the current smart contract as a Slice with a MsgAddressInt. If necessary, it can be parsed further using primitives such as PARSESTDADDR or REWRITESTDADDR. Equivalent to GETPARAM 8."},
            {"CONFIGROOT", "F829 — CONFIGROOT ( — D )\nReturns the Maybe Cell D with the current global configuration dictionary. Equivalent to GETPARAM 9."},
            {"CONFIGDICT", "F830 — CONFIGDICT ( — D 32 )\nReturns the global configuration dictionary along with its key length (32). Equivalent to CONFIGROOT; PUSHINT 32."},
            {"CONFIGPARAM", "F832 — CONFIGPARAM ( i — c -1 or 0 )\nReturns the value of the global configuration parameter with integer index i as a Cell c, and a flag to indicate success. Equivalent to CONFIGDICT; DICTIGETREF."},
            {"CONFIGOPTPARAM", "F833 — CONFIGOPTPARAM ( i — c^? )\nReturns the value of the global configuration parameter with integer index i as a Maybe Cell c^?. Equivalent to CONFIGDICT; DICTIGETOPTREF."},
            {"GETGLOBVAR", "F840 — GETGLOBVAR ( k — x )\nReturns the k -th global variable for 0≤ k<255. Equivalent to PUSH c7; SWAP; INDEXVARQ (cf. sp:prim.tuple )."},
            {"SETGLOBVAR", "F860 — SETGLOBVAR ( x k — )\nAssigns x to the k -th global variable for 0≤ k<255. Equivalent to PUSH c7; ROTREV; SETINDEXVARQ; POP c7."},
            {"HASHCU", "F900 — HASHCU ( c — x )\nComputes the representation hash (cf. sp:repr.hash ) of a Cell c and returns it as a 256-bit unsigned integer x. Useful for signing and checking signatures of arbitrary entities represented by a tree of cells."},
            {"HASHSU", "F901 — HASHSU ( s — x )\nComputes the hash of a Slice s and returns it as a 256-bit unsigned integer x. The result is the same as if an ordinary cell containing only data and references from s had been created and its hash computed by HASHCU."},
            {"CHKSIGNU", "F910 — CHKSIGNU ( h s k — ? )\nChecks the Ed25519-signature s of a hash h (a 256-bit unsigned integer, usually computed as the hash of some data) using public key k (also represented by a 256-bit unsigned integer). The signature s must be a Slice containing at least 512 data bits; only the first 512 bits are used. The result is -1 if the signature is valid, 0 otherwise. Notice that CHKSIGNU is equivalent to ROT; NEWB; STU 256; ENDB; NEWC; ROTREV; CHKSIGNS, i.e., to CHKSIGNS with the first argument d set to 256-bit Slice containing h. Therefore, if h is computed as the hash of some data, these data are hashed twice, the second hashing occurring inside CHKSIGNS."},
            {"CHKSIGNS", "F911 — CHKSIGNS ( d s k — ? )\nChecks whether s is a valid Ed25519-signature of the data portion of Slice d using public key k, similarly to CHKSIGNU. If the bit length of Slice d is not divisible by eight, throws a cell underflow exception. The verification of Ed25519 signatures is the standard one, with SHA256 used to reduce d to the 256-bit number that is actually signed."},
            {"LDGRAMS", "FA00 — LDGRAMS or LDVARUINT16 ( s — x s' )\nLoads (deserializes) a Gram or VarUInteger 16 amount from CellSlice s, and returns the amount as Integer x along with the remainder s' of s. The expected serialization of x consists of a 4-bit unsigned big-endian integer l, followed by an 8l -bit unsigned big-endian representation of x. The net effect is approximately equivalent to LDU 4; SWAP; LSHIFT 3; LDUX."},
            {"STGRAMS", "FA02 — STGRAMS or STVARUINT16 ( b x — b' )\nStores (serializes) an Integer x in the range 0…2^{120}-1 into Builder b, and returns the resulting Builder b'. The serialization of x consists of a 4-bit unsigned big-endian integer l, which is the smallest integer l≥0, such that x<2^{8l}, followed by an 8l -bit unsigned big-endian representation of x. If x does not belong to the supported range, a range check exception is thrown."},
            {"LDMSGADDR", "FA40 — LDMSGADDR ( s — s' s” )\nLoads from CellSlice s the only prefix that is a valid MsgAddress, and returns both this prefix s' and the remainder s” of s as CellSlice s."},
            {"LDMSGADDRQ", "FA41 — LDMSGADDRQ ( s — s' s” -1 or s 0 )\nA quiet version of LDMSGADDR: on success, pushes an extra -1; on failure, pushes the original s and a zero."},
            {"PARSEMSGADDR", "FA42 — PARSEMSGADDR ( s — t )\nDecomposes CellSlice s containing a valid MsgAddress into a Tuple t with separate fields of this MsgAddress. If s is not a valid MsgAddress, a cell deserialization exception is thrown."},
            {"PARSEMSGADDRQ", "FA43 — PARSEMSGADDRQ ( s — t -1 or 0 )\nA quiet version of PARSEMSGADDR: returns a zero on error instead of throwing an exception."},
            {"REWRITESTDADDR", "FA44 — REWRITESTDADDR ( s — x y )\nParses CellSlice s containing a valid MsgAddressInt (usually a msg_addr_std ), applies rewriting from the anycast (if present) to the same-length prefix of the address, and returns both the workchain x and the 256-bit address y as Integer s. If the address is not 256-bit, or if s is not a valid serialization of MsgAddressInt, throws a cell deserialization exception."},
            {"REWRITESTDADDRQ", "FA45 — REWRITESTDADDRQ ( s — x y -1 or 0 )\nA quiet version of primitive REWRITESTDADDR."},
            {"REWRITEVARADDR", "FA46 — REWRITEVARADDR ( s — x s' )\nA variant of REWRITESTDADDR that returns the (rewritten) address as a Slice s, even if it is not exactly 256 bit long (represented by a msg_addr_var )."},
            {"REWRITEVARADDRQ", "FA47 — REWRITEVARADDRQ ( s — x s' -1 or 0 )\nA quiet version of primitive REWRITEVARADDR."},
            {"SENDRAWMSG", "FB00 — SENDRAWMSG ( c x — )\nSends a raw message contained in Cellc, which should contain a correctly serialized object MessageX, with the only exception that the source address is allowed to have dummy value addrₙone (to be automatically replaced with the current smart-contract address), and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction). Integer parameter x contains the flags. Currently x=0 is used for ordinary messages; x=128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message); x=64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount); x'=x+1 means that the sender wants to pay transfer fees separately; x'=x+2 means that any errors arising while processing this message during the action phase should be ignored."},
            {"RAWRESERVE", "FB02 — RAWRESERVE ( x y — )\nCreates an output action which would reserve exactly x nanograms (if y=0 ), at most x nanograms (if y=2 ), or all but x nanograms (if y=1 or y=3 ), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying x nanograms (or b-x nanograms, where b is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit +2 in y means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Currently x must be a non-negative integer, and y must be in the range 0… 3."},
            {"RAWRESERVEX", "FB03 — RAWRESERVEX ( s y — )\nSimilar to RAWRESERVE, but accepts a Slices with a CurrencyCollection as an argument. In this way currencies other than Grams can be reserved."},
            {"SETCODE", "FB04 — SETCODE ( c — )\nCreates an output action that would change this smart contract code to that given by Cell c. Notice that this change will take effect only after the successful termination of the current run of the smart contract."},
            {"DUMPSTK", "FE00 — DUMPSTK, dumps the stack (at most the top 255 values) and shows the total stack depth."},
            {"HEXDUMP", "FE10 — HEXDUMP, dumps s0 in hexadecimal form, be it a Slice or an Integer."},
            {"HEXPRINT", "FE11 — HEXPRINT, similar to HEXDUMP, except the hexadecimal representation of s0 is not immediately output, but rather concatenated to an output text buffer."},
            {"BINDUMP", "FE12 — BINDUMP, dumps s0 in binary form, similarly to HEXDUMP."},
            {"BINPRINT", "FE13 — BINPRINT, outputs the binary representation of s0 to a text buffer."},
            {"STRDUMP", "FE14 — STRDUMP, dumps the Slice at s0 as an UTF-8 string."},
            {"STRPRINT", "FE15 — STRPRINT, similar to STRDUMP, but outputs the string into a text buffer (without carriage return)."},
            {"DEBUGOFF", "FE1E — DEBUGOFF, disables all debug output until it is re-enabled by a DEBUGON. More precisely, this primitive increases an internal counter, which disables all debug operations (except DEBUGOFF and DEBUGON ) when strictly positive."},
            {"DEBUGON", "FE1F — DEBUGON, enables debug output (in a debug version of TVM)."},
            {"LOGFLUSH", "FEF000 — LOGFLUSH, flushes all pending debug output from the buffer into the debug log."},
            {"SETCPX", "FFF0 — SETCPX ( c — )\nSelects codepage c with -2^{15}≤ c<2^{15} passed in the top of the stack."},
        };
        
        if (!word.empty()) {
            auto docstring = docs.find(word);
            if (docstring != docs.end()) {
                return docstring->second;
            }
        }
        return std::string(); 
    }
}