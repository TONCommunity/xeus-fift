#include <string>
#include <unordered_map>

namespace xfift {
    static inline std::string get_docstring(const std::string& word) {
        static std::unordered_map<std::string, std::string> docs = {
            {"!", "! ( x p -- ), stores new value x into Box p."},
            {"\"", "\"〈string〉\" ( -- S ), pushes a String literal into the stack."},
            {"#", "# ( x S -- x' S' ), performs one step of the conversion of Integer x into its decimal representation by appending to String S one decimal digit representing xmod10. The quotient x':=⌊x/10⌋ is returned as well."},
            {"#>", "#> ( S -- S' ), finishes the conversion of an Integer into its human-readable representation (decimal or otherwise) started with <# by reversing String S. Equivalent to $reverse."},
            {"#s", "#s ( x S -- x' S' ), performs # one or more times until the quotient x' becomes non-positive. Equivalent to {#over 0<= } until."},
            {"\\$#", "$# ( -- x ), pushes the total number of command-line arguments passed to the Fift program. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$(", "(〈string/〉) ( -- … ), looks up the word $〈string/〉 during execution time and executes its current definition. Typically used to access the current values of command-line arguments, e.g., $(2) is essentially equivalent to @' $2."},
            {"\\$()", "$() ( x -- S ), pushes the x -th command-line argument similarly to $n, but with Integer x≥0 taken from the stack. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"\\$+", "$+ ( S S' -- S.S' ), concatenates two strings."},
            {"\\$,", "$, ( b S -- b' ), appends String S to Builder b. The string is interpreted as a binary string of length 8n, where n is the number of bytes in the UTF-8 representation of S."},
            {"\\$", "$n ( -- S ), pushes the n -th command-line argument as a String S. For instance, $0 pushes the name of the script being executed, $1 the first command line argument, and so on. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"\\$=", "$= ( S S' -- ? ), returns -1 if strings S and S' are equal, 0 otherwise. Equivalent to $cmp 0=."},
            {"\\$>s", "$>s ( S -- s ), transforms the String S into a Slice. Equivalent to <b swap $, b> <s."},
            {"\\$>smca", "$>smca ( S -- x y z -1 or 0 ), unpacks a standard TON smart-contract address from its human-readable string representation S. On success, returns the signed 32-bit workchain x, the unsigned 256-bit in-workchain address y, the flags z (where +1 means that the address is non-bounceable, +2 that the address is testnet-only), and -1. On failure, pushes 0."},
            {"\\$@", "$@ ( s x -- S ), fetches the first x bytes (i.e., 8x bits) from Slice s, and returns them as a UTF-8 String S. If there are not enough data bits in s, throws an exception."},
            {"\\$@+", "$@+ ( s x -- S s' ), similar to $@, but returns the remainder of Slice s as well."},
            {"\\$@?", "$@? ( s x -- S -1 or 0 ), similar to $@, but uses a flag to indicate failure instead of throwing an exception."},
            {"\\$@?+", "$@?+ ( s x -- S s' -1 or s 0 ), similar to $@+, but uses a flag to indicate failure instead of throwing an exception."},
            {"\\$cmp", "$cmp ( S S' -- x ), returns 0 if strings S and S' are equal, -1 if S is lexicographically less than S', and 1 if S is lexicographically greater than S'."},
            {"\\$len", "$len ( S -- x ), computes the byte length (not the UTF-8 character length!) of a string."},
            {"\\$reverse", "$reverse ( S -- S' ), reverses the order of UTF-8 characters in String S. If S is not a valid UTF-8 string, the return value is undefined and may be also invalid."},
            {"\\%1<", "%1<< ( x y -- z ), computes z:=xmod 2^y=x&(2^y-1) for two Integer s x and 0≤y≤256."},
            {"'", "'〈word-name〉 ( -- e ), returns the execution token equal to the current (compile-time) definition of 〈word-name〉. If the specified word is not found, throws an exception."},
            {"'nop", "'nop ( -- e ), pushes the default definition of nop ---an execution token that does nothing when executed."},
            {"(')", "(')〈word-name〉 ( -- e ), similar to ', but returns the definition of the specified word at execution time, performing a dictionary lookup each time it is invoked. May be used to recover the current values of constants inside word definitions and other blocks by using the phrase (')〈word-name〉execute."},
            {"(-trailing)", "(-trailing) ( S x -- S' ), removes from String S all trailing characters with UTF-8 codepoint x."},
            {"(.)", "(.) ( x -- S ), returns the String with the decimal representation of Integer x. Equivalent to dup abs <##srot sign#> nip."},
            {"(atom)", "(atom) ( S x -- a -1 or 0 ), returns the only Atom a with the name given by String S. If there is no such Atom yet, either creates it (if Integer x is non-zero) or returns a single zero to indicate failure (if x is zero)."},
            {"(b.)", "(b.) ( x -- S ), returns the String with the binary representation of Integer x."},
            {"(compile)", "(compile) ( l x_1 … x_n n e -- l' ), extends WordList l so that it would push 0≤n≤255 values x_1, …, x_n into the stack and execute the execution token e when invoked, where 0≤n≤255 is an Integer. If e is equal to the special value 'nop, the last step is omitted."},
            {"(create)", "(create) ( e S x -- ), creates a new word with the name equal to String S and definition equal to WordDef e, using flags passed in Integer 0≤x≤3. If bit +1 is set in x, creates an active word; if bit +2 is set in x, creates a prefix word."},
            {"(def?)", "(def?) ( S -- ? ), checks whether the word S is defined."},
            {"(dump)", "(dump) ( x -- S ), returns a String with a dump of the topmost stack value x, in the same format as employed by .dump."},
            {"(execute)", "(execute) ( x_1 … x_n n e -- … ), executes execution token e, but first checks that there are at least 0≤n≤255 values in the stack apart from n and e themselves. It is a counterpart of (compile) that may be used to immediately “execute” (perform the intended runtime action of) an active word after its immediate execution, as explained in ."},
            {"(forget)", "(forget) ( S -- ), forgets the word with the name specified in String S. If the word is not found, throws an exception."},
            {"(number)", "(number) ( S -- 0 or x 1 or x y 2 ), attempts to parse the String S as an integer or fractional literal. On failure, returns a single 0. On success, returns x 1 if S is a valid integer literal with value x, or x y 2 if S is a valid fractional literal with value x/y."},
            {"(x.)", "(x.) ( x -- S ), returns the String with the hexadecimal representation of Integer x."},
            {"(\\{)", "({) ( -- l ), pushes an empty WordList into the stack"},
            {"(\\})", "(}) ( l -- e ), transforms a WordList into an execution token ( WordDef ), making all further modifications impossible."},
            {"*", "* ( x y -- xy ), computes the product xy of two Integer s x and y."},
            {"*/", "*/ ( x y z -- ⌊xy/z⌋ ), “multiply-then-divide”: multiplies two integers x and y producing a 513-bit intermediate result, then divides the product by z."},
            {"*/c", "*/c ( x y z -- lceil xy/zrceil ), “multiply-then-divide” with ceiling rounding: multiplies two integers x and y producing a 513-bit intermediate result, then divides the product by z."},
            {"*/cmod", "*/cmod ( x y z -- q r ), similar to */c, but computes both the quotient q:=lceil xy/zrceil and the remainder r:=xy-qz."},
            {"*/mod", "*/mod ( x y z -- q r ), similar to */, but computes both the quotient q:=⌊xy/z⌋ and the remainder r:=xy-qz."},
            {"*/r", "*/r ( x y z -- q:=⌊xy/z+1/2⌋ ), “multiply-then-divide” with nearest-integer rounding: multiplies two integers x and y with 513-bit intermediate result, then divides the product by z."},
            {"*/rmod", "*/rmod ( x y z -- q r ), similar to */r, but computes both the quotient q:=⌊xy/z+1/2⌋ and the remainder r:=xy-qz."},
            {"*>", "*>> ( x y z -- q ), similar to */, but with division replaced with a right shift. Computes q:=⌊xy/2^z⌋ for 0≤z≤256. Equivalent to 1<< */."},
            {"*>", "*>>c ( x y z -- q ), similar to */c, but with division replaced with a right shift. Computes q:=lceil xy/2^zrceil for 0≤z≤256. Equivalent to 1<< */c."},
            {"*>", "*>>r ( x y z -- q ), similar to */r, but with division replaced with a right shift. Computes q:=⌊xy/2^z+1/2⌋ for 0≤z≤256. Equivalent to 1<< */r."},
            {"*mod", "*mod ( x y z -- r ), similar to */mod, but computes only the remainder r:=xy-qz, where q:=⌊xy/z⌋. Equivalent to */mod nip."},
            {"+", "+ ( x y -- x+y ), computes the sum x+y of two Integer s x and y."},
            {"+!", "+! ( x p -- ), increases the integer value stored in Box p by Integer x. Equivalent to tuck @ + swap !."},
            {"+\"", "+\"〈string〉\" ( S -- S' ), concatenates String S with a string literal. Equivalent to \"〈string〉\" $+."},
            {",", ", ( t x -- t' ), appends x to the end of Tuple t, and returns the resulting Tuple t'."},
            {"-", "- ( x y -- x-y ), computes the difference x-y of two Integer s x and y."},
            {"-!", "-! ( x p -- ), decreases the integer value stored in Box p by Integer x. Equivalent to swap negate swap +!."},
            {"-1", "-1 ( -- -1 ), pushes Integer -1."},
            {"-1<", "-1<< ( x -- -2^x ), computes -2^x for 0≤x≤256. Approximately equivalent to 1<< negate or -1 swap <<, but works for x=256 as well."},
            {"-roll", "-roll ( x_n … x_0 n -- x_0 x_n … x_1 ), rotates the top n stack entries in the opposite direction, where n≥0 is also passed in the stack. In particular, 1 -roll is equivalent to swap, and 2 -roll to -rot."},
            {"-rot", "-rot ( x y z -- z x y ), rotates the three topmost stack entries in the opposite direction. Equivalent to rot rot."},
            {"-trailing", "-trailing ( S -- S' ), removes from String S all trailing spaces. Equivalent to bl (-trailing)."},
            {"-trailing0", "-trailing0 ( S -- S' ), removes from String S all trailing ` 0 ' characters. Equivalent to char 0 (-trailing)."},
            {".", ". ( x -- ), prints the decimal representation of Integer x, followed by a single space. Equivalent to ._space."},
            {".\"", ".\"〈string〉\" ( -- ), prints a constant string into the standard output."},
            {"._", "._ ( x -- ), prints the decimal representation of Integer x without any spaces. Equivalent to (.) type."},
            {".dump", ".dump ( x -- ), dumps the topmost stack entry in the same way as .s dumps all stack elements. Equivalent to (dump) type space."},
            {".l", ".l ( l -- ), prints a Lisp-style list l."},
            {".s", ".s ( -- ), dumps all stack entries starting from the deepest, leaving them intact. Human-readable representations of stack entries are output separated by spaces, followed by an end-of-line character."},
            {".sl", ".sl ( -- ), dumps all stack entries leaving them intact similarly to .s, but showing each entry as a List-style list l as .l does."},
            {".tc", ".tc ( -- ), outputs the total number of allocated cells into the standard error stream."},
            {"/", "/ ( x y -- q:=⌊x/y⌋ ), computes the floor-rounded quotient ⌊x/y⌋ of two Integer s."},
            {"/*", "/*〈multiline-comment〉*/ ( -- ), skips a multi-line comment delimited by word “ */ ” (followed by a blank or an end-of-line character)."},
            {"//", "//〈comment-to-eol〉 ( -- ), skips a single-line comment until the end of the current line."},
            {"/c", "/c ( x y -- q:=lceil x/yrceil ), computes the ceiling-rounded quotient lceil x/yrceil of two Integer s."},
            {"/cmod", "/cmod ( x y -- q r ), computes both the ceiling-rounded quotient q:=lceil x/yrceil and the remainder r:=x-qy."},
            {"/mod", "/mod ( x y -- q r ), computes both the floor-rounded quotient q:=⌊x/y⌋ and the remainder r:=x-qy."},
            {"/r", "/r ( x y -- q ), computes the nearest-integer-rounded quotient ⌊x/y+1/2⌋ of two Integer s."},
            {"/rmod", "/rmod ( x y -- q r ), computes both the nearest-integer-rounded quotient q:=⌊x/y+1/2⌋ and the remainder r:=x-qy."},
            {"0", "0 ( -- 0 ), pushes Integer 0."},
            {"0!", "0! ( p -- ), stores Integer 0 into Box p. Equivalent to 0 swap !."},
            {"0<", "0< ( x -- ? ), checks whether x<0 (i.e., pushes -1 if x is negative, 0 otherwise). Equivalent to 0 <."},
            {"0<=", "0<= ( x -- ? ), checks whether x≤0 (i.e., pushes -1 if x is non-positive, 0 otherwise). Equivalent to 0 <=."},
            {"0<>", "0<> ( x -- ? ), checks whether xneq0 (i.e., pushes -1 if x is non-zero, 0 otherwise). Equivalent to 0 <>."},
            {"0=", "0= ( x -- ? ), checks whether x=0 (i.e., pushes -1 if x is zero, 0 otherwise). Equivalent to 0 =."},
            {"0>", "0> ( x -- ? ), checks whether x>0 (i.e., pushes -1 if x is positive, 0 otherwise). Equivalent to 0 >."},
            {"0>=", "0>= ( x -- ? ), checks whether x≥0 (i.e., pushes -1 if x is non-negative, 0 otherwise). Equivalent to 0 >=."},
            {"1", "1 ( -- 1 ), pushes Integer 1."},
            {"1+", "1+ ( x -- x+1 ), computes x+1. Equivalent to 1 +."},
            {"1+!", "1+! ( p -- ), increases the integer value stored in Box p by one. Equivalent to 1 swap +!."},
            {"1-", "1- ( x -- x-1 ), computes x-1. Equivalent to 1 -."},
            {"1-!", "1-! ( p -- ), decreases the integer value stored in Box p by one. Equivalent to -1 swap +!."},
            {"1<", "1<< ( x -- 2^x ), computes 2^x for 0≤x≤255. Equivalent to 1 swap <<."},
            {"1<", "1<<1- ( x -- 2^x-1 ), computes 2^x-1 for 0≤x≤256. Almost equivalent to 1<< 1-, but works for x=256."},
            {"2", "2 ( -- 2 ), pushes Integer 2."},
            {"2*", "2* ( x -- 2x ), computes 2x. Equivalent to 2 *."},
            {"2+", "2+ ( x -- x+2 ), computes x+2. Equivalent to 2 +."},
            {"2-", "2- ( x -- x-2 ), computes x-2. Equivalent to 2 -."},
            {"2/", "2/ ( x -- ⌊x/2⌋ ), computes ⌊x/2⌋. Equivalent to 2 / or to 1 >>."},
            {"2=:", "2=:〈word-name〉 ( x y -- ), an active variant of 2constant: defines a new ordinary word 〈word-name〉 that would push the given values x and y when invoked."},
            {"2constant", "2constant ( x y -- ), scans a blank-delimited word name S from the remainder of the input, and defines a new ordinary word S as a double constant, which will push the given values x and y (of arbitrary types) when invoked."},
            {"2drop", "2drop ( x y -- ), removes the two topmost stack entries. Equivalent to drop drop."},
            {"2dup", "2dup ( x y -- x y x y ), duplicates the topmost pair of stack entries. Equivalent to over over."},
            {"2over", "2over ( x y z w -- x y z w x y ), duplicates the second topmost pair of stack entries."},
            {"2swap", "2swap ( a b c d -- c d a b ), interchanges the two topmost pairs of stack entries."},
            {":", ":〈word-name〉 ( e -- ), defines a new ordinary word 〈word-name〉 in the dictionary using WordDef e as its definition. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"::", "::〈word-name〉 ( e -- ), defines a new active word 〈word-name〉 in the dictionary using WordDef e as its definition. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"::_", "::_〈word-name〉 ( e -- ), defines a new active prefix word 〈word-name〉 in the dictionary using WordDef e as its definition. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {":_", ":_〈word-name〉 ( e -- ), defines a new ordinary prefix word 〈word-name〉 in the dictionary using WordDef e as its definition. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"<", "< ( x y -- ? ), checks whether x<y (i.e., pushes -1 if Integer x is less than Integer y, 0 otherwise)."},
            {"<#", "<# ( -- S ), pushes an empty String. Typically used for starting the conversion of an Integer into its human-readable representation, decimal or in another base. Equivalent to \"\"."},
            {"<", "<< ( x y -- xcdot 2^y ), computes an arithmetic left shift of binary number x by y≥0 positions, yielding xcdot 2^y."},
            {"<", "<</ ( x y z -- q ), computes q:=⌊2^zx/y⌋ for 0≤z≤256 producing a 513-bit intermediate result, similarly to */. Equivalent to 1<< swap */."},
            {"<", "<</c ( x y z -- q ), computes q:=lceil 2^zx/yrceil for 0≤z≤256 producing a 513-bit intermediate result, similarly to */c. Equivalent to 1<< swap */c."},
            {"<", "<</r ( x y z -- q ), computes q:=⌊2^zx/y+1/2⌋ for 0≤z≤256 producing a 513-bit intermediate result, similarly to */r. Equivalent to 1<< swap */r."},
            {"<=", "<= ( x y -- ? ), checks whether x≤y (i.e., pushes -1 if Integer x is less than or equal to Integer y, 0 otherwise)."},
            {"<>", "<> ( x y -- ? ), checks whether xneq y (i.e., pushes -1 if Integer s x and y are not equal, 0 otherwise)."},
            {"<b", "<b ( -- b ), creates a new empty Builder."},
            {"<s", "<s ( c -- s ), transforms a Cell c into a Slice s containing the same data. It usually marks the start of the deserialization of a cell."},
            {"=", "= ( x y -- ? ), checks whether x=y (i.e., pushes -1 if Integer s x and y are equal, 0 otherwise)."},
            {"=:", "=:〈word-name〉 ( x -- ), an active variant of constant: defines a new ordinary word 〈word-name〉 that would push the given value x when invoked."},
            {">", "> ( x y -- ? ), checks whether x>y (i.e., pushes -1 if Integer x is greater than Integer y, 0 otherwise)."},
            {">=", ">= ( x y -- ? ), checks whether x≥y (i.e., pushes -1 if Integer x is greater than or equal to Integer y, 0 otherwise)."},
            {">", ">> ( x y -- q:=⌊xcdot 2^{-y}⌋ ), computes an arithmetic right shift of binary number x by 0≤y≤256 positions. Equivalent to 1<< /."},
            {">", ">>c ( x y -- q:=lceil xcdot 2^{-y}rceil ), computes the ceiling-rounded quotient q of x by 2^y for 0≤y≤256. Equivalent to 1<< /c."},
            {">", ">>r ( x y -- q:=⌊xcdot 2^{-y}+1/2⌋ ), computes the nearest-integer-rounded quotient q of x by 2^y for 0≤y≤256. Equivalent to 1<< /r."},
            {"?dup", "?dup ( x -- x x or 0 ), duplicates an Integer x, but only if it is non-zero. Otherwise leaves it intact."},
            {"@", "@ ( p -- x ), fetches the value currently stored in Box p."},
            {"@'", "@'〈word-name〉 ( -- e ), recovers the definition of the specified word at execution time, performing a dictionary lookup each time it is invoked, and then executes this definition. May be used to recover current values of constants inside word definitions and other blocks by using the phrase @'〈word-name〉, equivalent to (')〈word-name〉execute."},
            {"B+", "B+ ( B' B” -- B ), concatenates two Bytes values."},
            {"B,", "B, ( b B -- b' ), appends Bytes B to Builder b. If there is no room in b for B, throws an exception."},
            {"B=", "B= ( B B' -- ? ), checks whether two Bytes sequences are equal, and returns -1 or 0 depending on the comparison outcome."},
            {"B>Li@", "B>Li@ ( B x -- y ), deserializes the first x/8 bytes of a Bytes value B as a signed little-endian x -bit Integer y."},
            {"B>Li@+", "B>Li@+ ( B x -- B' y ), deserializes the first x/8 bytes of B as a signed little-endian x -bit Integer y similarly to B>Li@, but also returns the remaining bytes of B."},
            {"B>Lu@", "B>Lu@ ( B x -- y ), deserializes the first x/8 bytes of a Bytes value B as an unsigned little-endian x -bit Integer y."},
            {"B>Lu@+", "B>Lu@+ ( B x -- B' y ), deserializes the first x/8 bytes of B as an unsigned little-endian x -bit Integer y similarly to B>Lu@, but also returns the remaining bytes of B."},
            {"B>boc", "B>boc ( B -- c ), deserializes a “standard” bag of cells (i.e., a bag of cells with exactly one root cell) represented by Bytes B, and returns the root Cell c."},
            {"B>file", "B>file ( B S -- ), creates a new (binary) file with the name specified in String S and writes data from Bytes B into the new file. If the specified file already exists, it is overwritten."},
            {"B>i@", "B>i@ ( B x -- y ), deserializes the first x/8 bytes of a Bytes value B as a signed big-endian x -bit Integer y."},
            {"B>i@+", "B>i@+ ( B x -- B' y ), deserializes the first x/8 bytes of B as a signed big-endian x -bit Integer y similarly to B>i@, but also returns the remaining bytes of B."},
            {"B>u@", "B>u@ ( B x -- y ), deserializes the first x/8 bytes of a Bytes value B as an unsigned big-endian x -bit Integer y."},
            {"B>u@+", "B>u@+ ( B x -- B' y ), deserializes the first x/8 bytes of B as an unsigned big-endian x -bit Integer y similarly to B>u@, but also returns the remaining bytes of B."},
            {"B@", "B@ ( s x -- B ), fetches the first x bytes (i.e., 8x bits) from Slice s, and returns them as a Bytes value B. If there are not enough data bits in s, throws an exception."},
            {"B@+", "B@+ ( s x -- B s' ), similar to B@, but returns the remainder of Slice s as well."},
            {"B@?", "B@? ( s x -- B -1 or 0 ), similar to B@, but uses a flag to indicate failure instead of throwing an exception."},
            {"B@?+", "B@?+ ( s x -- B s' -1 or s 0 ), similar to B@+, but uses a flag to indicate failure instead of throwing an exception."},
            {"Bcmp", "Bcmp ( B B' -- x ), lexicographically compares two Bytes sequences, and returns -1, 0, or 1, depending on the comparison result."},
            {"Bhash", "Bhash ( B -- x ), deprecated version of Bhashu. Use Bhashu or BhashB instead."},
            {"BhashB", "BhashB ( B -- B' ), computes the Sha hash of a Bytes value. The hash is returned as a 32-byte Bytes value."},
            {"Bhashu", "Bhashu ( B -- x ), computes the Sha hash of a Bytes value. The hash is returned as a big-endian unsigned 256-bit Integer value."},
            {"Blen", "Blen ( B -- x ), returns the length of a Bytes value B in bytes."},
            {"Bx.", "Bx. ( B -- ), prints the hexadecimal representation of a Bytes value. Each byte is represented by exactly two uppercase hexadecimal digits."},
            {"B\\{", "B{〈{hex-digits}〉} ( -- B ), pushes a Bytes literal containing data represented by an even number of hexadecimal digits."},
            {"B|", "B| ( B x -- B' B” ), cuts the first x bytes from a Bytes value B, and returns both the first x bytes ( B' ) and the remainder ( B” ) as new Bytes values."},
            {"Li>B", "Li>B ( x y -- B ), stores a signed little-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256."},
            {"Lu>B", "Lu>B ( x y -- B ), stores an unsigned little-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256."},
            {"lsqbr", "[ ( -- ), opens an internal interpreter session even if state is greater than zero, i.e., all subsequent words are executed immediately instead of being compiled."},
            {"lsqbr rsqbr", "[] ( t i -- x ), returns the (i+1) -st component t_{i+1} of Tuple t, where 0≤i<|t|."},
            {"lsqbr compilersqbr", "[compile]〈word-name〉 ( -- ), compiles 〈word-name〉 as if it were an ordinary word, even if it is active. Essentially equivalent to '〈word-name〉execute."},
            {"rsqbr", "] ( x_1 … x_n n -- ), closes an internal interpreter session opened by [ and invokes (compile) or (execute) afterwards depending on whether state is greater than zero. For instance, {[2 3 + 1]* } is equivalent to { 5 * }."},
            {"`", "`〈word/〉 ( -- a ), introduces an Atom literal, equal to the only Atom with the name equal to 〈word/〉. Equivalent to \"〈word/〉\" atom."},
            {"abort", "abort ( S -- ), throws an exception with an error message taken from String S."},
            {"abort\"", "abort\"〈message〉\" ( x -- ), throws an exception with the error message 〈message〉 if the Integer x is non-zero."},
            {"abs", "abs ( x -- |x| ), computes the absolute value |x|=max(x,-x) of Integer x. Equivalent to dup negate max."},
            {"allot", "allot ( n -- t ), creates a new array, i.e., a Tuple that consists of n new empty Box es. Equivalent to | { hole, } rot times."},
            {"and", "and ( x y -- x& y ), computes the bitwise AND of two Integer s."},
            {"anon", "anon ( -- a ), creates a new unique anonymous Atom."},
            {"atom", "atom ( S -- a ), returns the only Atom a with the name S, creating such an atom if necessary. Equivalent to true (atom) drop."},
            {"atom?", "atom? ( u -- ? ), checks whether u is an Atom."},
            {"b+", "b+ ( b b' -- b” ), concatenates two Builders b and b'."},
            {"b.", "b. ( x -- ), prints the binary representation of an Integer x, followed by a single space. Equivalent to b._space."},
            {"b._", "b._ ( x -- ), prints the binary representation of an Integer x without any spaces. Equivalent to (b.) type."},
            {"b>", "b> ( b -- c ), transforms a Builder b into a new Cell c containing the same data as b."},
            {"b>idict!", "b>idict! ( v x s n -- s' -1 or s 0 ), adds a new value v (represented by a Builder ) with key given by signed big-endian n -bit integer x into dictionary s with n -bit keys, and returns the new dictionary s' and -1 on success. Otherwise the unchanged dictionary s and 0 are returned."},
            {"b>idict!+", "b>idict!+ ( v x s n -- s' -1 or s 0 ), adds a new key-value pair (x,v) into dictionary s similarly to b>idict!, but fails if the key already exists by returning the unchanged dictionary s and 0."},
            {"b>udict!", "b>udict! ( v x s n -- s' -1 or s 0 ), adds a new value v (represented by a Builder ) with key given by unsigned big-endian n -bit integer x into dictionary s with n -bit keys, and returns the new dictionary s' and -1 on success. Otherwise the unchanged dictionary s and 0 are returned."},
            {"b>udict!+", "b>udict!+ ( v x s n -- s' -1 or s 0 ), adds a new key-value pair (x,v) into dictionary s similarly to b>udict!, but fails if the key already exists by returning the unchanged dictionary s and 0."},
            {"bbitrefs", "bbitrefs ( b -- x y ), returns both the number of data bits x and the number of references y already stored in Builder b."},
            {"bbits", "bbits ( b -- x ), returns the number of data bits already stored in Builder b. The result x is an Integer in the range 0…1023."},
            {"bl", "bl ( -- x ), pushes the Unicode codepoint of a space, i.e., 32."},
            {"boc+>B", "boc+>B ( c x -- B ), creates and serializes a “standard” bag of cells, containing one root Cell c along with all its descendants. An Integer parameter 0≤x≤31 is used to pass flags indicating the additional options for bag-of-cells serialization, with individual bits having the following effect: Typical values of x are x=0 or x=2 for very small bags of cells (e.g., TON Blockchain external messages) and x=31 for large bags of cells (e.g., TON Blockchain blocks)."},
            {"boc>B", "boc>B ( c -- B ), serializes a small “standard” bag of cells with root Cell c and all its descendants. Equivalent to 0 boc+>B."},
            {"box", "box ( x -- p ), creates a new Box containing specified value x. Equivalent to hole tuck !."},
            {"brefs", "brefs ( b -- x ), returns the number of references already stored in Builder b. The result x is an Integer in the range 0…4."},
            {"brembitrefs", "brembitrefs ( b -- x y ), returns both the maximum number of additional data bits 0≤x≤1023 and the maximum number of additional cell references 0≤y≤4 that can be stored in Builder b."},
            {"brembits", "brembits ( b -- x ), returns the maximum number of additional data bits that can be stored in Builder b. Equivalent to bbits 1023 swap -."},
            {"bremrefs", "bremrefs ( b -- x ), returns the maximum number of additional cell references that can be stored in Builder b."},
            {"bye", "bye ( -- ), quits the Fift interpreter to the operating system with a zero exit code. Equivalent to 0 halt."},
            {"b\\{", "b{〈binary-data〉} ( -- s ), creates a Slice s that contains no references and up to 1023 data bits specified in 〈binary-data〉, which must be a string consisting only of the characters ` 0 ' and ` 1 '."},
            {"caddr", "caddr ( l -- h” ), returns the third element of a list. Equivalent to cddr car."},
            {"cadr", "cadr ( l -- h' ), returns the second element of a list. Equivalent to cdr car."},
            {"car", "car ( l -- h ), returns the head of a list. Equivalent to first."},
            {"cddr", "cddr ( l -- t' ), returns the tail of the tail of a list. Equivalent to cdr cdr."},
            {"cdr", "cdr ( l -- t ), returns the tail of a list. Equivalent to second."},
            {"char", "char〈string〉 ( -- x ), pushes an Integer with the Unicode codepoint of the first character of 〈string〉. For instance, char * is equivalent to 42."},
            {"chr", "chr ( x -- S ), returns a new String S consisting of one UTF-8 encoded character with Unicode codepoint x."},
            {"cmp", "cmp ( x y -- z ), compares two Integer s x and y, and pushes 1 if x>y, -1 if x<y, and 0 if x=y. Approximately equivalent to - sgn."},
            {"cond", "cond ( x e e' -- ), if Integer x is non-zero, executes e, otherwise executes e'."},
            {"cons", "cons ( h t -- l ), constructs a list from its head (first element) h and its tail (the list consisting of all remaining elements) t. Equivalent to pair."},
            {"constant", "constant ( x -- ), scans a blank-delimited word name S from the remainder of the input, and defines a new ordinary word S as a constant, which will push the given value x (of arbitrary type) when invoked."},
            {"count", "count ( t -- n ), returns the length n=|t| of Tuple t."},
            {"cr", "cr ( -- ), outputs a carriage return (or a newline character) into the standard output."},
            {"create", "create ( e -- ), defines a new ordinary word with the name equal to the next word scanned from the input, using WordDef e as its definition. If the word already exists, it is tacitly redefined."},
            {"csr.", "csr. ( s -- ), recursively prints a Slice s. On the first line, the data bits of s are displayed in hexadecimal form embedded into an x{…} construct similar to the one used for Slice literals (cf. ). On the next lines, the cells referred to by s are printed with larger indentation."},
            {"def?", "def?〈word-name/〉 ( -- ? ), checks whether the word 〈word-name/〉 is defined at execution time, and returns -1 or 0 accordingly."},
            {"depth", "depth ( -- n ), returns the current depth (the total number of entries) of the Fift stack as an Integer n≥0."},
            {"dictmap", "dictmap ( D n e -- D' ), applies execution token e (i.e., an anonymous function) to each of the key-value pairs stored in a dictionary D with n -bit keys. The execution token is executed once for each key-value pair, with a Builder b and a Slice v (containing the value) pushed into the stack before executing e. After the execution e must leave in the stack either a modified Builder b' (containing all data from b along with the new value v' ) and -1, or 0 indicating failure. In the latter case, the corresponding key is omitted from the new dictionary."},
            {"dictmerge", "dictmerge ( D D' n e -- D” ), combines two dictionaries D and D' with n -bit keys into one dictionary D” with the same keys. If a key is present in only one of the dictionaries D and D', this key and the corresponding value are copied verbatim to the new dictionary D”. Otherwise the execution token (anonymous function) e is invoked to merge the two values v and v' corresponding to the same key k in D and D', respectively. Before e is invoked, a Builder b and two Slice s v and v' representing the two values to be merged are pushed. After the execution e leaves either a modified Builder b' (containing the original data from b along with the combined value) and -1, or 0 on failure. In the latter case, the corresponding key is omitted from the new dictionary."},
            {"dictnew", "dictnew ( -- D ), pushes the Null value that represents a new empty dictionary. Equivalent to null."},
            {"does", "does ( x_1 … x_n n e -- e' ), creates a new execution token e' that would push n values x_1, …, x_n into the stack and then execute e when invoked. It is roughly equivalent to a combination of ({), (compile), and (})."},
            {"drop", "drop ( x -- ), removes the top-of-stack entry."},
            {"dup", "dup ( x -- x x ), duplicates the top-of-stack entry. If the stack is empty, throws an exception."},
            {"ed25519_chksign", "ed25519_chksign ( B B' B” -- ? ), checks whether B' is a valid Ed25519-signature of data B with the public key B”."},
            {"ed25519_sign", "ed25519_sign ( B B' -- B” ), signs data B with the Ed25519 private key B' (a 32-byte Bytes value) and returns the signature as a 64-byte Bytes value B”."},
            {"ed25519_sign_uint", "ed25519_sign_uint ( x B' -- B” ), converts a big-endian unsigned 256-bit integer x into a 32-byte sequence and signs it using the Ed25519 private key B' similarly to ed25519_sign. Equivalent to swap 256 u>B swap ed25519_sign. The integer x to be signed is typically computed as the hash of some data."},
            {"emit", "emit ( x -- ), prints a UTF-8 encoded character with Unicode codepoint given by Integer x into the standard output. For instance, 42 emit prints an asterisk “ * ”, and 916 emit prints a Greek Delta “ Delta ”. Equivalent to chr type."},
            {"empty?", "empty? ( s -- ? ), checks whether a Slice is empty (i.e., has no data bits and no references left), and returns -1 or 0 accordingly."},
            {"eq?", "eq? ( u v -- ? ), checks whether u and v are equal Integer s, Atom s, or Null s. If they are not equal, or if they are of different types, or not of one of the types listed, returns zero."},
            {"exch", "exch ( x_n … x_0 n -- x_0 … x_n ), interchanges the top of the stack with the n -th stack entry from the top, where n≥0 is also taken from the stack. In particular, 1 exch is equivalent to swap, and 2 exch to swap rot."},
            {"exch2", "exch2 ( … n m -- … ), interchanges the n -th stack entry from the top with the m -th stack entry from the top, where n≥0, m≥0 are taken from the stack."},
            {"execute", "execute ( e -- … ), executes the execution token ( WordDef ) e."},
            {"explode", "explode ( t -- x_1 … x_n n ), unpacks a Tuple t=(x_1,…,x_n) of unknown length n, and returns that length."},
            {"false", "false ( -- 0 ), pushes 0 into the stack. Equivalent to 0."},
            {"file-exists?", "file-exists? ( S -- ? ), checks whether the file with the name specified in String S exists."},
            {"file>B", "file>B ( S -- B ), reads the (binary) file with the name specified in String S and returns its contents as a Bytes value. If the file does not exist, an exception is thrown."},
            {"find", "find ( S -- e -1 or e 1 or 0 ), looks up String S in the dictionary and returns its definition as a WordDef e if found, followed by -1 for ordinary words or 1 for active words. Otherwise pushes 0."},
            {"first", "first ( t -- x ), returns the first component of a Tuple. Equivalent to 0[]."},
            {"fits", "fits ( x y -- ? ), checks whether Integer x is a signed y -bit integer (i.e., whether -2^{y-1}≤x<2^{y-1} for 0≤y≤1023 ), and returns -1 or 0 accordingly."},
            {"forget", "forget ( -- ), forgets (removes from the dictionary) the definition of the next word scanned from the input."},
            {"gasrunvm", "gasrunvm ( … s c z -- … x c' z' ), a gas-aware version of runvm. [ 1.4 ] ) with Cell c. Then starts the new TVM instance with the gas limit set to z. The actually consumed gas z' is returned at the top of the final Fift stack, and the final value of c4 is returned immediately below the top of the final Fift stack as another Cell c'."},
            {"gasrunvmcode", "gasrunvmcode ( … s z -- … x z' ), a gas-aware version of runvmcode. The original Fift stack (without s ) is passed in its entirety as the initial stack of the new TVM instance. When TVM terminates, its resulting stack is used as the new Fift stack, with the exit code x and the actually consumed gas z' pushed at its top. If x is non-zero, indicating that TVM has been terminated by an unhandled exception, the next stack entry from the top contains the parameter of this exception, and x is the exception code. All other entries are removed from the stack in this case."},
            {"gasrunvmctx", "gasrunvmctx ( … s c t z -- … x c' z' ), a gas-aware version of runvmctx. Differs from gasrunmv in that it initializes c7 with Tuple t."},
            {"gasrunvmdict", "gasrunvmdict ( … s z -- … x z' ), a gas-aware version of runvmdict. The actually consumed gas is returned as an Integer z'. In a typical application Slice s consists of a subroutine selection code that uses the top-of-stack Integer to select the subroutine to be executed, thus enabling the definition and execution of several mutually-recursive subroutines (cf. [ 4.6 ] and ). The selector equal to zero corresponds to the main() subroutine in a large TVM program."},
            {"halt", "halt ( x -- ), quits to the operating system similarly to bye, but uses Integer x as the exit code."},
            {"hash", "hash ( c -- x ), a deprecated version of hashu. Use hashu or hashB instead."},
            {"hashB", "hashB ( c -- B ), computes the Sha -based representation hash of Cell c (cf. [ 3.1 ] ), which unambiguously defines c and all its descendants (provided there are no collisions for Sha ). The result is returned as a Bytes value consisting of exactly 32 bytes."},
            {"hashu", "hashu ( c -- x ), computes the Sha -based representation hash of Cell c similarly to hashB, but returns the result as a big-endian unsigned 256-bit Integer."},
            {"hold", "hold ( S x -- S' ), appends to String S one UTF-8 encoded character with Unicode codepoint x. Equivalent to chr $+."},
            {"hole", "hole ( -- p ), creates a new Box p that does not hold any value. Equivalent to null box."},
            {"i,", "i, ( b x y -- b' ), appends the big-endian binary representation of a signed y -bit integer x to Builder b, where 0≤y≤257. If there is not enough room in b (i.e., if b already contains more than 1023-y data bits), or if Integer x does not fit into y bits, an exception is thrown."},
            {"i>B", "i>B ( x y -- B ), stores a signed big-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256."},
            {"i@", "i@ ( s x -- y ), fetches a signed big-endian x -bit integer from the first x bits of Slice s. If s contains less than x data bits, an exception is thrown."},
            {"i@+", "i@+ ( s x -- y s' ), fetches a signed big-endian x -bit integer from the first x bits of Slice s similarly to i@, but returns the remainder of s as well."},
            {"i@?", "i@? ( s x -- y -1 or 0 ), fetches a signed big-endian integer from a Slice similarly to i@, but pushes integer -1 afterwards on success. If there are less than x bits left in s, pushes integer 0 to indicate failure."},
            {"i@?+", "i@?+ ( s x -- y s' -1 or s 0 ), fetches a signed big-endian integer from Slice s and computes the remainder of this Slice similarly to i@+, but pushes -1 afterwards to indicate success. On failure, pushes the unchanged Slice s and 0 to indicate failure."},
            {"idict!", "idict! ( v x D n -- D' -1 or D 0 ), adds a new value v (represented by a Slice ) with key given by signed big-endian n -bit integer x into dictionary D with n -bit keys, and returns the new dictionary D' and -1 on success. Otherwise the unchanged dictionary D and 0 are returned."},
            {"idict!+", "idict!+ ( v x D n -- D' -1 or D 0 ), adds a new key-value pair (x,v) into dictionary D similarly to idict!, but fails if the key already exists by returning the unchanged dictionary D and 0."},
            {"idict@", "idict@ ( x D n -- v -1 or 0 ), looks up key represented by signed big-endian n -bit Integer x in the dictionary represented by Cell or Null D. If the key is found, returns the corresponding value as a Slice v and -1. Otherwise returns 0."},
            {"if", "if ( x e -- ), executes execution token (i.e., a WordDef ) e, but only if Integer x is non-zero."},
            {"ifnot", "ifnot ( x e -- ), executes execution token e, but only if Integer x is zero."},
            {"include", "include ( S -- ), loads and interprets a Fift source file from the path given by String S. If the filename S does not begin with a slash, the Fift include search path, typically taken from the FIFTPATH environment variable or the -I command-line argument of the Fift interpreter (and equal to /usr/lib/fift if both are absent), is used to locate S."},
            {"list", "list ( x_1 … x_n n -- l ), constructs a list l of length n with elements x_1, …, x_n, in that order. Equivalent to null ' cons rot times."},
            {"max", "max ( x y -- z ), computes the maximum z:=max(x,y) of two Integer s x and y. Equivalent to minmax nip."},
            {"min", "min ( x y -- z ), computes the minimum z:=min(x,y) of two Integer s x and y. Equivalent to minmax drop."},
            {"minmax", "minmax ( x y -- z t ), computes both the minimum z:=min(x,y) and the maximum t:=max(x,y) of two Integer s x and y."},
            {"mod", "mod ( x y -- r:=xmod y ), computes the remainder xmod y=x-ycdot⌊x/y⌋ of division of x by y."},
            {"negate", "negate ( x -- -x ), changes the sign of an Integer."},
            {"newkeypair", "newkeypair ( -- B B' ), generates a new Ed25519 private/public key pair, and returns both the private key B and the public key B' as 32-byte Bytes values. The quality of the keys is good enough for testing purposes. Real applications must feed enough entropy into OpenSSL PRNG before generating Ed25519 keypairs."},
            {"nil", "nil ( -- t ), pushes the empty Tuple t=(). Equivalent to 0 tuple."},
            {"nip", "nip ( x y -- y ), removes the second stack entry from the top. Equivalent to swap drop."},
            {"nop", "nop ( -- ), does nothing."},
            {"not", "not ( x -- -1-x ), computes the bitwise complement of an Integer."},
            {"now", "now ( -- x ), returns the current Unixtime as an Integer."},
            {"null", "null ( -- ot ), pushes the Null value"},
            {"null!", "null! ( p -- ), stores a Null value into Box p. Equivalent to null swap !."},
            {"null?", "null? ( x -- ? ), checks whether x is Null."},
            {"or", "or ( x y -- x|y ), computes the bitwise OR of two Integer s."},
            {"over", "over ( x y -- x y x ), creates a copy of the second stack entry from the top over the top-of-stack entry."},
            {"pair", "pair ( x y -- t ), creates new pair t=(x,y). Equivalent to 2 tuple or to | rot, swap,."},
            {"pfxdict!", "pfxdict! ( v k s n -- s' -1 or s 0 ), adds key-value pair (k,v), both represented by Slice s, into a prefix dictionary s with keys of length at most n. On success, returns the modified dictionary s' and -1. On failure, returns the original dictionary s and 0."},
            {"pfxdict!+", "pfxdict!+ ( v k s n -- s' -1 or s 0 ), adds key-value pair (k,v) into prefix dictionary s similarly to pfxdict!, but fails if the key already exists."},
            {"pfxdict@", "pfxdict@ ( k s n -- v -1 or 0 ), looks up key k (represented by a Slice ) in the prefix dictionary s with the length of keys limited by n bits. On success, returns the value found as a Slice v and -1. On failure, returns 0."},
            {"pick", "pick ( x_n … x_0 n -- x_n … x_0 x_n ), creates a copy of the n -th entry from the top of the stack, where n≥0 is also passed in the stack. In particular, 0 pick is equivalent to dup, and 1 pick to over."},
            {"priv>pub", "priv>pub ( B -- B' ), computes the public key corresponding to a private Ed25519 key. Both the public key B' and the private key B are represented by 32-byte Bytes values."},
            {"quit", "quit ( … -- ), exits to the topmost level of the Fift interpreter (without printing an ok in interactive mode) and clears the stack."},
            {"ref,", "ref, ( b c -- b' ), appends to Builder b a reference to Cell c. If b already contains four references, an exception is thrown."},
            {"ref@", "ref@ ( s -- c ), fetches the first reference from the Slice s and returns the Cell c referred to. If there are no references left, throws an exception."},
            {"ref@+", "ref@+ ( s -- s' c ), fetches the first reference from the Slice s similarly to ref@, but returns the remainder of s as well."},
            {"ref@?", "ref@? ( s -- c -1 or 0 ), fetches the first reference from the Slice s similarly to ref@, but uses a flag to indicate failure instead of throwing an exception."},
            {"ref@?+", "ref@?+ ( s -- s' c -1 or s 0 ), similar to ref@+, but uses a flag to indicate failure instead of throwing an exception."},
            {"remaining", "remaining ( s -- x y ), returns both the number of data bits x and the number of cell references y remaining in the Slice s."},
            {"reverse", "reverse ( x_1 … x_n y_1 … y_m n m -- x_n … x_1 y_1 … y_m ), reverses the order of n stack entries located immediately below the topmost m elements, where both 0≤m,n≤255 are passed in the stack."},
            {"roll", "roll ( x_n … x_0 n -- x_{n-1} … x_0 x_n ), rotates the top n stack entries, where n≥0 is also passed in the stack. In particular, 1 roll is equivalent to swap, and 2 roll to rot."},
            {"rot", "rot ( x y z -- y z x ), rotates the three topmost stack entries."},
            {"runvm", "runvm ( … s c -- … x c' ), invokes a new instance of TVM with both the current continuation cc and the special register c3 initialized from Slice s, and initializes special register c4 (the “root of persistent data”.4 ] ) with Cell c. In contrast with runvmdict, does not push an implicit zero into the initial TVM stack; if necessary, it can be explicitly passed under s. The final value of c4 is returned at the top of the final Fift stack as another Cell c'. In this way one can emulate the execution of smart contracts that inspect or modify their persistent storage."},
            {"runvmcode", "runvmcode ( … s -- … x ), invokes a new instance of TVM with the current continuation cc initialized from Slice s, thus executing code s in TVM. The original Fift stack (without s ) is passed in its entirety as the initial stack of the new TVM instance. When TVM terminates, its resulting stack is used as the new Fift stack, with the exit code x pushed at its top. If x is non-zero, indicating that TVM has been terminated by an unhandled exception, the next stack entry from the top contains the parameter of this exception, and x is the exception code. All other entries are removed from the stack in this case."},
            {"runvmctx", "runvmctx ( … s c t -- … x c' ), a variant of runvm that also initializes c7 (the “context register” of TVM) with Tuple t."},
            {"runvmdict", "runvmdict ( … s -- … x ), invokes a new instance of TVM with the current continuation cc initialized from Slice s similarly to runvmcode, but also initializes the special register c3 with the same value, and pushes a zero into the initial TVM stack before start. In a typical application Slice s consists of a subroutine selection code that uses the top-of-stack Integer to select the subroutine to be executed, thus enabling the definition and execution of several mutually-recursive subroutines (cf. [ 4.6 ] and ). The selector equal to zero corresponds to the main() subroutine in a large TVM program."},
            {"s,", "s, ( b s -- b' ), appends data bits and references taken from Slice s to Builder b."},
            {"s>", "s> ( s -- ), throws an exception if Slice s is non-empty. It usually marks the end of the deserialization of a cell, checking whether there are any unprocessed data bits or references left."},
            {"s>c", "s>c ( s -- c ), creates a Cell c directly from a Slice s. Equivalent to <b swap s, b>."},
            {"sbitrefs", "sbitrefs ( s -- x y ), returns both the number of data bits x and the number of cell references y remaining in Slice s. Equivalent to remaining."},
            {"sbits", "sbits ( s -- x ), returns the number of data bits x remaining in Slice s."},
            {"second", "second ( t -- x ), returns the second component of a Tuple. Equivalent to 1[]."},
            {"sgn", "sgn ( x -- y ), computes the sign of an Integer x (i.e., pushes 1 if x>0, -1 if x<0, and 0 if x=0 ). Equivalent to 0 cmp."},
            {"shash", "shash ( s -- B ), computes the Sha -based representation hash of a Slice by first transforming it into a cell. Equivalent to s>c hashB."},
            {"sign", "sign ( S x -- S' ), appends a minus sign “ - ” to String S if Integer x is negative. Otherwise leaves S intact."},
            {"single", "single ( x -- t ), creates new singleton t=(x), i.e., a one-element Tuple. Equivalent to 1 tuple."},
            {"skipspc", "skipspc ( -- ), skips blank characters from the current input line until a non-blank or an end-of-line character is found."},
            {"smca>\\$", "smca>$ ( x y z -- S ), packs a standard TON smart-contract address with workchain x (a signed 32-bit Integer ) and in-workchain address y (an unsigned 256-bit Integer ) into a 48-character string S (the human-readable representation of the address) according to flags z. Possible individual flags in z are: +1 for non-bounceable addresses, +2 for testnet-only addresses, and +4 for base64url output instead of base64."},
            {"space", "space ( -- ), outputs a single space. Equivalent to bl emit or to .\" \"."},
            {"sr,", "sr, ( b s -- b' ), constructs a new Cell containing all data and references from Slice s, and appends a reference to this cell to Builder b. Equivalent to s>c ref,."},
            {"srefs", "srefs ( s -- x ), returns the number of cell references x remaining in Slice s."},
            {"swap", "swap ( x y -- y x ), interchanges the two topmost stack entries."},
            {"ten", "ten ( -- 10 ), pushes Integer constant 10."},
            {"third", "third ( t -- x ), returns the third component of a Tuple. Equivalent to 2[]."},
            {"times", "times ( e n -- ), executes execution token ( WordDef ) e exactly n times, if n≥0. If n is negative, throws an exception."},
            {"triple", "triple ( x y z -- t ), creates new triple t=(x,y,z). Equivalent to 3 tuple."},
            {"true", "true ( -- -1 ), pushes -1 into the stack. Equivalent to -1."},
            {"tuck", "tuck ( x y -- y x y ), equivalent to swap over."},
            {"tuple", "tuple ( x_1 … x_n n -- t ), creates new Tuple t:=(x_1,…,x_n) from n≥0 topmost stack values. Equivalent to dup 1 reverse | { swap, } rot times, but more efficient."},
            {"tuple?", "tuple? ( t -- ? ), checks whether t is a Tuple, and returns -1 or 0 accordingly."},
            {"type", "type ( s -- ), prints a String s taken from the top of the stack into the standard output."},
            {"u,", "u, ( b x y -- b' ), appends the big-endian binary representation of an unsigned y -bit integer x to Builder b, where 0≤y≤256. If the operation is impossible, an exception is thrown."},
            {"u>B", "u>B ( x y -- B ), stores an unsigned big-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256."},
            {"u@", "u@ ( s x -- y ), fetches an unsigned big-endian x -bit integer from the first x bits of Slice s. If s contains less than x data bits, an exception is thrown."},
            {"u@+", "u@+ ( s x -- y s' ), fetches an unsigned big-endian x -bit integer from the first x bits of Slice s similarly to u@, but returns the remainder of s as well."},
            {"u@?", "u@? ( s x -- y -1 or 0 ), fetches an unsigned big-endian integer from a Slice similarly to u@, but pushes integer -1 afterwards on success. If there are less than x bits left in s, pushes integer 0 to indicate failure."},
            {"u@?+", "u@?+ ( s x -- y s' -1 or s 0 ), fetches an unsigned big-endian integer from Slice s and computes the remainder of this Slice similarly to u@+, but pushes -1 afterwards to indicate success. On failure, pushes the unchanged Slice s and 0 to indicate failure."},
            {"udict!", "udict! ( v x D n -- D' -1 or D 0 ), adds a new value v (represented by a Slice ) with key given by big-endian unsigned n -bit integer x into dictionary D with n -bit keys, and returns the new dictionary D' and -1 on success. Otherwise the unchanged dictionary D and 0 are returned."},
            {"udict!+", "udict!+ ( v x D n -- D' -1 or D 0 ), adds a new key-value pair (x,v) into dictionary D similarly to udict!, but fails if the key already exists by returning the unchanged dictionary D and 0."},
            {"udict@", "udict@ ( x D n -- v -1 or 0 ), looks up key represented by unsigned big-endian n -bit Integer x in the dictionary represented by Cell or Null D. If the key is found, returns the corresponding value as a Slice v and -1. Otherwise returns 0."},
            {"ufits", "ufits ( x y -- ? ), checks whether Integer x is an unsigned y -bit integer (i.e., whether 0≤x<2^y for 0≤y≤1023 ), and returns -1 or 0 accordingly."},
            {"uncons", "uncons ( l -- h t ), decomposes a non-empty list into its head and its tail. Equivalent to unpair."},
            {"undef?", "undef?〈word-name/〉 ( -- ? ), checks whether the word 〈word-name/〉 is undefined at execution time, and returns -1 or 0 accordingly."},
            {"unpair", "unpair ( t -- x y ), unpacks a pair t=(x,y). Equivalent to 2 untuple."},
            {"unsingle", "unsingle ( t -- x ), unpacks a singleton t=(x). Equivalent to 1 untuple."},
            {"until", "until ( e -- ), an until loop. If it is, then begins a new iteration of the loop by executing e. Otherwise exits the loop."},
            {"untriple", "untriple ( t -- x y z ), unpacks a triple t=(x,y,z). Equivalent to 3 untuple."},
            {"untuple", "untuple ( t n -- x_1 … x_n ), returns all components of a Tuple t=(x_1,…,x_n), but only if its length is equal to n. Otherwise throws an exception."},
            {"variable", "variable ( -- ), scans a blank-delimited word name S from the remainder of the input, allocates an empty Box, and defines a new ordinary word S as a constant, which will push the new Box when invoked. Equivalent to hole constant."},
            {"while", "while ( e e' -- ), a while loop. If it is zero, exits the loop. Otherwise executes WordDef e', then begins a new loop iteration by executing e and checking the exit condition afterwards."},
            {"word", "word ( x -- s ), parses a word delimited by the character with the Unicode codepoint x from the remainder of the current input line and pushes the result as a String. For instance, bl word abracadabra type will print the string “ abracadabra ”. If x=0, skips leading spaces, and then scans until the end of the current input line. If x=32, skips leading spaces before parsing the next word."},
            {"words", "words ( -- ), prints the names of all words currently defined in the dictionary."},
            {"x.", "x. ( x -- ), prints the hexadecimal representation (without the 0x prefix) of an Integer x, followed by a single space. Equivalent to x._space."},
            {"x._", "x._ ( x -- ), prints the hexadecimal representation (without the 0x prefix) of an Integer x without any spaces. Equivalent to (x.) type."},
            {"xor", "xor ( x y -- xoplus y ), computes the bitwise eXclusive OR of two Integer s."},
            {"x\\{", "x{〈hex-data〉} ( -- s ), creates a Slice s that contains no references and up to 1023 data bits specified in 〈hex-data〉. More precisely, each hex digit from 〈hex-data〉 is transformed into four binary digits in the usual fashion. After that, if the last character of 〈hex-data〉 is an underscore _, then all trailing binary zeroes and the binary one immediately preceding them are removed from the resulting binary string (cf. [ 1.0 ] for more details). For instance, x{6C_} is equivalent to b{01101}."},
            {"{", "{ ( -- l ), an active word that increases internal variable state by one and pushes a new empty WordList into the stack."},
            {"|", "| ( -- t ), creates an empty Tuple t=(). Equivalent to nil and to 0 tuple."},
            {"|+", "|+ ( s s' -- s” ), concatenates two Slice s and s'. This means that the data bits of the new Slice s” are obtained by concatenating the data bits of s and s', and the list of Cell references of s” is constructed similarly by concatenating the corresponding lists for s and s'. Equivalent to <b rot s, swap s, b> <s."},
            {"|_", "|_ ( s s' -- s” ), given two Slice s s and s', creates a new Slice s”, which is obtained from s by appending a new reference to a Cell containing s'. Equivalent to <b rot s, swap s>c ref, b> <s."},
            {"}", "} ( l -- e ), an active word that transforms a WordList l into a WordDef (an execution token) e, thus making all further modifications of l impossible, and decreases internal variable state by one; then pushes the integer 1, followed by a 'nop. The net effect is to transform the constructed WordList into an execution token and push this execution token into the stack, either immediately or during the execution of an outer block."},
            {"+1", "+1 enables bag-of-cells index creation (useful for lazy deserialization of large bags of cells)."},
            {"+2", "+2 includes the CRC32-C of all data into the serialization (useful for checking data integrity)."},
            {"+4", "+4 explicitly stores the hash of the root cell into the serialization (so that it can be quickly recovered afterwards without a complete deserialization)."},
            {"+8", "+8 stores hashes of some intermediate (non-leaf) cells (useful for lazy deserialization of large bags of cells)."},
            {"+16", "+16 stores cell cache bits to control caching of deserialized cells."},
        };
        
        if (!word.empty()) {
            auto docstring = docs.find(word);
            if (docstring != docs.end()) {
                return docstring->second;
            }
        }
        return std::string(); 
    }
}