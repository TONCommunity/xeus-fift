#include <string>
#include <unordered_map>

namespace xfift {
    static inline std::string get_docstring(const std::string& word) {
        static std::unordered_map<std::string, std::string> docs = {
            {"!", "! ( x p — )\nStores new value x into Box p, cf. p:variables."},
            {"\"", "\"❬string❭\" ( — S )\nPushes a String literal into the stack, cf. p:string.lit and p:string.ops."},
            {"#", "# ( x S — x' S' )\nPerforms one step of the conversion of Integer x into its decimal representation by appending to String S one decimal digit representing x mod10. The quotient x':= ⌊x/10⌋ is returned as well."},
            {"#>", "#> ( S — S' )\nFinishes the conversion of an Integer into its human-readable representation (decimal or otherwise) started with <# by reversing String S. Equivalent to $reverse."},
            {"#s", "#s ( x S — x' S' )\nPerforms # one or more times until the quotient x' becomes non-positive. Equivalent to { # over 0<= } until."},
            {"$#", "$# ( — x )\nPushes the total number of command-line arguments passed to the Fift program, cf. p:cmdline.ops. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$(", "$(❬string❭) ( — … ), looks up the word $❬string❭ during execution time and executes its current definition. Typically used to access the current values of command-line arguments, e.g., $(2) is essentially equivalent to @' $2."},
            {"$()", "$() ( x — S ), pushes the x -th command-line argument similarly to $n, but with Integer x≥0 taken from the stack, cf. p:cmdline.ops. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$+", "$+ ( S S' — S.S' )\nConcatenates two strings, cf. p:string.ops."},
            {"$,", "$, ( b S — b' )\nAppends String S to Builder b, cf. p:builder.ops. The string is interpreted as a binary string of length 8n, where n is the number of bytes in the UTF-8 representation of S."},
            {"$n", "$n ( — S )\nPushes the n -th command-line argument as a String S, cf. p:cmdline.ops. For instance, $0 pushes the name of the script being executed, $1 the first command line argument, and so on. Defined only when the Fift interpreter is invoked in script mode (with the -s command line argument)."},
            {"$=", "$= ( S S' — ? )\nReturns -1 if strings S and S' are equal, 0 otherwise, cf. p:string.cmp.ops. Equivalent to $cmp 0=."},
            {"$>s", "$>s ( S — s )\nTransforms the String S into a Slice, cf. p:slice.ops. Equivalent to <b swap $, b> <s."},
            {"$>smca", "$>smca ( S — x y z -1 or 0 )\nUnpacks a standard TON smart-contract address from its human-readable string representation S, cf. p:smc.addr.ops. On success, returns the signed 32-bit workchain x, the unsigned 256-bit in-workchain address y, the flags z (where +1 means that the address is non-bounceable, +2 that the address is testnet-only), and -1. On failure, pushes 0."},
            {"$@", "$@ ( s x — S )\nFetches the first x bytes (i.e., 8x bits) from Slice s, and returns them as a UTF-8 String S, cf. p:slice.ops. If there are not enough data bits in s, throws an exception."},
            {"$@+", "$@+ ( s x — S s' )\nSimilar to $@, but returns the remainder of Slice s as well, cf. p:slice.ops."},
            {"$@?", "$@? ( s x — S -1 or 0 )\nSimilar to $@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"$@?+", "$@?+ ( s x — S s' -1 or s 0 )\nSimilar to $@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"$cmp", "$cmp ( S S' — x )\nReturns 0 if strings S and S' are equal, -1 if S is lexicographically less than S', and 1 if S is lexicographically greater than S', cf. p:string.cmp.ops."},
            {"$len", "$len ( S — x )\nComputes the byte length (not the UTF-8 character length!) of a string, cf. p:string.ops."},
            {"$reverse", "$reverse ( S — S' )\nReverses the order of UTF-8 characters in String S. If S is not a valid UTF-8 string, the return value is undefined and may be also invalid."},
            {"%1<<", "%1<< ( x y — z )\nComputes z:=x mod 2ʸ =x&(2ʸ -1) for two Integer s x and 0≤ y≤ 256."},
            {"'", "' ❬word-name❭ ( — e )\nReturns the execution token equal to the current (compile-time) definition of ❬word-name❭, cf. p:blocks. If the specified word is not found, throws an exception."},
            {"'nop", "'nop ( — e )\nPushes the default definition of nop —an execution token that does nothing when executed, cf. p:dict.lookup."},
            {"(')", "(') ❬word-name❭ ( — e ), similar to ', but returns the definition of the specified word at execution time, performing a dictionary lookup each time it is invoked, cf. p:dict.lookup. May be used to recover the current values of constants inside word definitions and other blocks by using the phrase (') ❬word-name❭ execute."},
            {"(-trailing)", "(-trailing) ( S x — S' ), removes from String S all trailing characters with UTF-8 codepoint x."},
            {"(.)", "(.) ( x — S ), returns the String with the decimal representation of Integer x. Equivalent to dup abs <# #s rot sign #> nip."},
            {"(atom)", "(atom) ( S x — a -1 or 0 ), returns the only Atom a with the name given by String S, cf. p:atoms. If there is no such Atom yet, either creates it (if Integer x is non-zero) or returns a single zero to indicate failure (if x is zero)."},
            {"(b.)", "(b.) ( x — S ), returns the String with the binary representation of Integer x."},
            {"(compile)", "(compile) ( l x₁ … xₙ n e — l' ), extends WordList l so that it would push 0≤ n≤ 255 values x₁, …, xₙ into the stack and execute the execution token e when invoked, where 0≤ n≤ 255 is an Integer, cf. p:wordlist.ops. If e is equal to the special value 'nop, the last step is omitted."},
            {"(create)", "(create) ( e S x — ), creates a new word with the name equal to String S and definition equal to WordDef e, using flags passed in Integer 0≤ x≤ 3, cf. p:dict.create. If bit +1 is set in x, creates an active word; if bit +2 is set in x, creates a prefix word."},
            {"(def?)", "(def?) ( S — ? ), checks whether the word S is defined."},
            {"(dump)", "(dump) ( x — S ), returns a String with a dump of the topmost stack value x, in the same format as employed by .dump."},
            {"(execute)", "(execute) ( x₁ … xₙ n e — … ), executes execution token e, but first checks that there are at least 0≤ n≤ 255 values in the stack apart from n and e themselves. It is a counterpart of (compile) that may be used to immediately “execute” (perform the intended runtime action of) an active word after its immediate execution, as explained in p:active.words."},
            {"(forget)", "(forget) ( S — ), forgets the word with the name specified in String S, cf. p:dict.create. If the word is not found, throws an exception."},
            {"(number)", "(number) ( S — 0 or x 1 or x y 2 ), attempts to parse the String S as an integer or fractional literal, cf. p:string.ops and p:int.lit. On failure, returns a single 0. On success, returns x 1 if S is a valid integer literal with value x, or x y 2 if S is a valid fractional literal with value x/y."},
            {"(x.)", "(x.) ( x — S ), returns the String with the hexadecimal representation of Integer x."},
            {"({)", "({) ( — l ), pushes an empty WordList into the stack, cf. p:wordlist.ops"},
            {"(})", "(}) ( l — e ), transforms a WordList into an execution token ( WordDef ), making all further modifications impossible, cf. p:wordlist.ops."},
            {"*", "* ( x y — xy )\nComputes the product xy of two Integer s x and y, cf. p:arith.op."},
            {"*/", "*/ ( x y z — ⌊xy/z⌋ ), “multiply-then-divide”: multiplies two integers x and y producing a 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/c", "*/c ( x y z — ⌈xy/z⌉ ), “multiply-then-divide” with ceiling rounding: multiplies two integers x and y producing a 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/cmod", "*/cmod ( x y z — q r )\nSimilar to */c, but computes both the quotient q:= ⌈xy/z⌉ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*/mod", "*/mod ( x y z — q r )\nSimilar to */, but computes both the quotient q:= ⌊xy/z⌋ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*/r", "*/r ( x y z — q:= ⌊xy/z+½⌋ ), “multiply-then-divide” with nearest-integer rounding: multiplies two integers x and y with 513-bit intermediate result, then divides the product by z, cf. p:arith.op."},
            {"*/rmod", "*/rmod ( x y z — q r )\nSimilar to */r, but computes both the quotient q:= ⌊xy/z+½⌋ and the remainder r:=xy-qz, cf. p:arith.op."},
            {"*>>", "*>> ( x y z — q )\nSimilar to */, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌊xy/2ᶻ ⌋ for 0≤ z≤ 256. Equivalent to 1<< */."},
            {"*>>c", "*>>c ( x y z — q )\nSimilar to */c, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌈xy/2ᶻ ⌉ for 0≤ z≤ 256. Equivalent to 1<< */c."},
            {"*>>r", "*>>r ( x y z — q )\nSimilar to */r, but with division replaced with a right shift, cf. p:arith.op. Computes q:= ⌊xy/2ᶻ +½⌋ for 0≤ z≤ 256. Equivalent to 1<< */r."},
            {"*mod", "*mod ( x y z — r )\nSimilar to */mod, but computes only the remainder r:=xy-qz, where q:= ⌊xy/z⌋ . Equivalent to */mod nip."},
            {"+", "+ ( x y — x+y )\nComputes the sum x+y of two Integer s x and y, cf. p:arith.op."},
            {"+!", "+! ( x p — )\nIncreases the integer value stored in Box p by Integer x, cf. p:variables. Equivalent to tuck @ + swap !."},
            {"+\"", "+\"❬string❭\" ( S — S' )\nConcatenates String S with a string literal, cf. p:string.ops. Equivalent to \"❬string❭\" $+."},
            {",", ", ( t x — t' )\nAppends x to the end of Tuple t, and returns the resulting Tuple t', cf. p:tuples."},
            {"-", "- ( x y — x-y )\nComputes the difference x-y of two Integer s x and y, cf. p:arith.op."},
            {"-!", "-! ( x p — )\nDecreases the integer value stored in Box p by Integer x. Equivalent to swap negate swap +!."},
            {"-1", "-1 ( — -1 )\nPushes Integer -1."},
            {"-1<<", "-1<< ( x — -2ˣ )\nComputes -2ˣ for 0≤ x≤ 256. Approximately equivalent to 1<< negate or -1 swap <<, but works for x=256 as well."},
            {"-roll", "-roll ( xₙ … x₀ n — x₀ xₙ … x₁ )\nRotates the top n stack entries in the opposite direction, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 1 -roll is equivalent to swap, and 2 -roll to -rot."},
            {"-rot", "-rot ( x y z — z x y )\nRotates the three topmost stack entries in the opposite direction, cf. p:stack.ops. Equivalent to rot rot."},
            {"-trailing", "-trailing ( S — S' )\nRemoves from String S all trailing spaces. Equivalent to bl (-trailing)."},
            {"-trailing0", "-trailing0 ( S — S' )\nRemoves from String S all trailing ` 0 ' characters. Equivalent to char 0 (-trailing)."},
            {".", ". ( x — )\nPrints the decimal representation of Integer x, followed by a single space, cf. p:arith.op. Equivalent to ._ space."},
            {".\"", ".\"❬string❭\" ( — )\nPrints a constant string into the standard output, cf. p:string.ops."},
            {"._", "._ ( x — )\nPrints the decimal representation of Integer x without any spaces. Equivalent to (.) type."},
            {".dump", ".dump ( x — )\nDumps the topmost stack entry in the same way as .s dumps all stack elements, cf. p:tuples. Equivalent to (dump) type space."},
            {".l", ".l ( l — )\nPrints a Lisp-style list l, cf. p:lists."},
            {".s", ".s ( — )\nDumps all stack entries starting from the deepest, leaving them intact, cf. p:stack.ops. Human-readable representations of stack entries are output separated by spaces, followed by an end-of-line character."},
            {".sl", ".sl ( — )\nDumps all stack entries leaving them intact similarly to .s, but showing each entry as a List-style list l as .l does."},
            {".tc", ".tc ( — )\nOutputs the total number of allocated cells into the standard error stream."},
            {"/", "/ ( x y — q:= ⌊x/y⌋ )\nComputes the floor-rounded quotient ⌊x/y⌋ of two Integer s, cf. p:arith.op."},
            {"/*", "/* ❬multiline-comment❭ */ ( — )\nSkips a multi-line comment delimited by word “ */ ” (followed by a blank or an end-of-line character), cf. p:comments."},
            {"//", "// ❬comment-to-eol❭ ( — )\nSkips a single-line comment until the end of the current line, cf. p:comments."},
            {"/c", "/c ( x y — q:= ⌈x/y⌉ )\nComputes the ceiling-rounded quotient ⌈x/y⌉ of two Integer s, cf. p:arith.op."},
            {"/cmod", "/cmod ( x y — q r )\nComputes both the ceiling-rounded quotient q:= ⌈x/y⌉ and the remainder r:=x-qy, cf. p:arith.op."},
            {"/mod", "/mod ( x y — q r )\nComputes both the floor-rounded quotient q:= ⌊x/y⌋ and the remainder r:=x-qy, cf. p:arith.op."},
            {"/r", "/r ( x y — q )\nComputes the nearest-integer-rounded quotient ⌊x/y+½⌋ of two Integer s, cf. p:arith.op."},
            {"/rmod", "/rmod ( x y — q r )\nComputes both the nearest-integer-rounded quotient q:= ⌊x/y+½⌋ and the remainder r:=x-qy, cf. p:arith.op."},
            {"0", "0 ( — 0 )\nPushes Integer 0."},
            {"0!", "0! ( p — )\nStores Integer 0 into Box p, cf. p:variables. Equivalent to 0 swap !."},
            {"0<", "0< ( x — ? )\nChecks whether x<0 (i.e., pushes -1 if x is negative, 0 otherwise), cf. p:int.comp. Equivalent to 0 <."},
            {"0<=", "0<= ( x — ? )\nChecks whether x≤0 (i.e., pushes -1 if x is non-positive, 0 otherwise), cf. p:int.comp. Equivalent to 0 <=."},
            {"0<>", "0<> ( x — ? )\nChecks whether x≠0 (i.e., pushes -1 if x is non-zero, 0 otherwise), cf. p:int.comp. Equivalent to 0 <>."},
            {"0=", "0= ( x — ? )\nChecks whether x=0 (i.e., pushes -1 if x is zero, 0 otherwise), cf. p:int.comp. Equivalent to 0 =."},
            {"0>", "0> ( x — ? )\nChecks whether x>0 (i.e., pushes -1 if x is positive, 0 otherwise), cf. p:int.comp. Equivalent to 0 >."},
            {"0>=", "0>= ( x — ? )\nChecks whether x≥0 (i.e., pushes -1 if x is non-negative, 0 otherwise), cf. p:int.comp. Equivalent to 0 >=."},
            {"1", "1 ( — 1 )\nPushes Integer 1."},
            {"1+", "1+ ( x — x+1 )\nComputes x+1. Equivalent to 1 +."},
            {"1+!", "1+! ( p — )\nIncreases the integer value stored in Box p by one, cf. p:variables. Equivalent to 1 swap +!."},
            {"1-", "1- ( x — x-1 )\nComputes x-1. Equivalent to 1 -."},
            {"1-!", "1-! ( p — )\nDecreases the integer value stored in Box p by one. Equivalent to -1 swap +!."},
            {"1<<", "1<< ( x — 2ˣ )\nComputes 2ˣ for 0≤ x≤ 255. Equivalent to 1 swap <<."},
            {"1<<1-", "1<<1- ( x — 2ˣ -1 )\nComputes 2ˣ -1 for 0≤ x≤ 256. Almost equivalent to 1<< 1-, but works for x=256."},
            {"2", "2 ( — 2 )\nPushes Integer 2."},
            {"2*", "2* ( x — 2x )\nComputes 2x. Equivalent to 2 *."},
            {"2+", "2+ ( x — x+2 )\nComputes x+2. Equivalent to 2 +."},
            {"2-", "2- ( x — x-2 )\nComputes x-2. Equivalent to 2 -."},
            {"2/", "2/ ( x — ⌊x/2⌋ )\nComputes ⌊x/2⌋ . Equivalent to 2 / or to 1 >>."},
            {"2=:", "2=: ❬word-name❭ ( x y — )\nAn active variant of 2constant: defines a new ordinary word ❬word-name❭ that would push the given values x and y when invoked, cf. p:constants."},
            {"2constant", "2constant ( x y — )\nScans a blank-delimited word name S from the remainder of the input, and defines a new ordinary word S as a double constant, which will push the given values x and y (of arbitrary types) when invoked, cf. p:dict.create."},
            {"2drop", "2drop ( x y — )\nRemoves the two topmost stack entries, cf. p:stack.ops. Equivalent to drop drop."},
            {"2dup", "2dup ( x y — x y x y )\nDuplicates the topmost pair of stack entries, cf. p:stack.ops. Equivalent to over over."},
            {"2over", "2over ( x y z w — x y z w x y )\nDuplicates the second topmost pair of stack entries."},
            {"2swap", "2swap ( a b c d — c d a b )\nInterchanges the two topmost pairs of stack entries, cf. p:stack.ops."},
            {":", ": ❬word-name❭ ( e — )\nDefines a new ordinary word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"::", ":: ❬word-name❭ ( e — )\nDefines a new active word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"::_", "::_ ❬word-name❭ ( e — )\nDefines a new active prefix word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {":_", ":_ ❬word-name❭ ( e — )\nDefines a new ordinary prefix word ❬word-name❭ in the dictionary using WordDef e as its definition, cf. p:dict.create. If the specified word is already present in the dictionary, it is tacitly redefined."},
            {"<", "< ( x y — ? )\nChecks whether x<y (i.e., pushes -1 if Integer x is less than Integer y, 0 otherwise), cf. p:int.comp."},
            {"<#", "<# ( — S )\nPushes an empty String. Typically used for starting the conversion of an Integer into its human-readable representation, decimal or in another base. Equivalent to \"\"."},
            {"<<", "<< ( x y — x⋅ 2ʸ )\nComputes an arithmetic left shift of binary number x by y≥0 positions, yielding x⋅ 2ʸ , cf. p:arith.op."},
            {"<</", "<</ ( x y z — q )\nComputes q:= ⌊2ᶻ x/y⌋ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */, cf. p:arith.op. Equivalent to 1<< swap */."},
            {"<</c", "<</c ( x y z — q )\nComputes q:= ⌈2ᶻ x/y⌉ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */c, cf. p:arith.op. Equivalent to 1<< swap */c."},
            {"<</r", "<</r ( x y z — q )\nComputes q:= ⌊2ᶻ x/y+½⌋ for 0≤ z≤ 256 producing a 513-bit intermediate result, similarly to */r, cf. p:arith.op. Equivalent to 1<< swap */r."},
            {"<=", "<= ( x y — ? )\nChecks whether x≤ y (i.e., pushes -1 if Integer x is less than or equal to Integer y, 0 otherwise), cf. p:int.comp."},
            {"<>", "<> ( x y — ? )\nChecks whether x≠ y (i.e., pushes -1 if Integer s x and y are not equal, 0 otherwise), cf. p:int.comp."},
            {"<b", "<b ( — b )\nCreates a new empty Builder, cf. p:builder.ops."},
            {"<s", "<s ( c — s )\nTransforms a Cell c into a Slice s containing the same data, cf. p:slice.ops. It usually marks the start of the deserialization of a cell."},
            {"=", "= ( x y — ? )\nChecks whether x=y (i.e., pushes -1 if Integer s x and y are equal, 0 otherwise), cf. p:int.comp."},
            {"=:", "=: ❬word-name❭ ( x — )\nAn active variant of constant: defines a new ordinary word ❬word-name❭ that would push the given value x when invoked, cf. p:constants."},
            {">", "> ( x y — ? )\nChecks whether x>y (i.e., pushes -1 if Integer x is greater than Integer y, 0 otherwise), cf. p:int.comp."},
            {">=", ">= ( x y — ? )\nChecks whether x≥ y (i.e., pushes -1 if Integer x is greater than or equal to Integer y, 0 otherwise), cf. p:int.comp."},
            {">>", ">> ( x y — q:= ⌊x⋅ 2⁻ʸ ⌋ )\nComputes an arithmetic right shift of binary number x by 0≤ y≤ 256 positions, cf. p:arith.op. Equivalent to 1<< /."},
            {">>c", ">>c ( x y — q:= ⌈x⋅ 2⁻ʸ ⌉ )\nComputes the ceiling-rounded quotient q of x by 2ʸ for 0≤ y≤ 256, cf. p:arith.op. Equivalent to 1<< /c."},
            {">>r", ">>r ( x y — q:= ⌊x⋅ 2⁻ʸ +½⌋ )\nComputes the nearest-integer-rounded quotient q of x by 2ʸ for 0≤ y≤ 256, cf. p:arith.op. Equivalent to 1<< /r."},
            {"?dup", "?dup ( x — x x or 0 )\nDuplicates an Integer x, but only if it is non-zero, cf. p:stack.ops. Otherwise leaves it intact."},
            {"@", "@ ( p — x )\nFetches the value currently stored in Box p, cf. p:variables."},
            {"@'", "@' ❬word-name❭ ( — e )\nRecovers the definition of the specified word at execution time, performing a dictionary lookup each time it is invoked, and then executes this definition, cf. p:constants and p:dict.lookup. May be used to recover current values of constants inside word definitions and other blocks by using the phrase @' ❬word-name❭, equivalent to (') ❬word-name❭ execute."},
            {"B+", "B+ ( B' B” — B )\nConcatenates two Bytes values, cf. p:bytes.ops."},
            {"B,", "B, ( b B — b' )\nAppends Bytes B to Builder b, cf. p:builder.ops. If there is no room in b for B, throws an exception."},
            {"B=", "B= ( B B' — ? )\nChecks whether two Bytes sequences are equal, and returns -1 or 0 depending on the comparison outcome, cf. p:bytes.ops."},
            {"B>Li@", "B>Li@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as a signed little-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>Li@+", "B>Li@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as a signed little-endian x -bit Integer y similarly to B>Li@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>Lu@", "B>Lu@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as an unsigned little-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>Lu@+", "B>Lu@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as an unsigned little-endian x -bit Integer y similarly to B>Lu@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>boc", "B>boc ( B — c )\nDeserializes a “standard” bag of cells (i.e., a bag of cells with exactly one root cell) represented by Bytes B, and returns the root Cell c, cf. p:boc.ops."},
            {"B>file", "B>file ( B S — )\nCreates a new (binary) file with the name specified in String S and writes data from Bytes B into the new file, cf. p:bytes.ops. If the specified file already exists, it is overwritten."},
            {"B>i@", "B>i@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as a signed big-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>i@+", "B>i@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as a signed big-endian x -bit Integer y similarly to B>i@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B>u@", "B>u@ ( B x — y )\nDeserializes the first x/8 bytes of a Bytes value B as an unsigned big-endian x -bit Integer y, cf. p:bytes.ops."},
            {"B>u@+", "B>u@+ ( B x — B' y )\nDeserializes the first x/8 bytes of B as an unsigned big-endian x -bit Integer y similarly to B>u@, but also returns the remaining bytes of B, cf. p:bytes.ops."},
            {"B@", "B@ ( s x — B )\nFetches the first x bytes (i.e., 8x bits) from Slice s, and returns them as a Bytes value B, cf. p:slice.ops. If there are not enough data bits in s, throws an exception."},
            {"B@+", "B@+ ( s x — B s' )\nSimilar to B@, but returns the remainder of Slice s as well, cf. p:slice.ops."},
            {"B@?", "B@? ( s x — B -1 or 0 )\nSimilar to B@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"B@?+", "B@?+ ( s x — B s' -1 or s 0 )\nSimilar to B@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"Bcmp", "Bcmp ( B B' — x )\nLexicographically compares two Bytes sequences, and returns -1, 0, or 1, depending on the comparison result, cf. p:bytes.ops."},
            {"Bhash", "Bhash ( B — x )\nDeprecated version of Bhashu. Use Bhashu or BhashB instead."},
            {"BhashB", "BhashB ( B — B' )\nComputes the SHA256 hash of a Bytes value, cf. p:bytes.ops. The hash is returned as a 32-byte Bytes value."},
            {"Bhashu", "Bhashu ( B — x )\nComputes the SHA256 hash of a Bytes value, cf. p:bytes.ops. The hash is returned as a big-endian unsigned 256-bit Integer value."},
            {"Blen", "Blen ( B — x )\nReturns the length of a Bytes value B in bytes, cf. p:bytes.ops."},
            {"Bx.", "Bx. ( B — )\nPrints the hexadecimal representation of a Bytes value, cf. p:bytes.ops. Each byte is represented by exactly two uppercase hexadecimal digits."},
            {"B{", "B{❬{hex-digits}❭} ( — B )\nPushes a Bytes literal containing data represented by an even number of hexadecimal digits, cf. p:bytes.ops."},
            {"B|", "B| ( B x — B' B” )\nCuts the first x bytes from a Bytes value B, and returns both the first x bytes ( B' ) and the remainder ( B” ) as new Bytes values, cf. p:bytes.ops."},
            {"Li>B", "Li>B ( x y — B )\nStores a signed little-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"Lu>B", "Lu>B ( x y — B )\nStores an unsigned little-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"[", "[ ( — )\nOpens an internal interpreter session even if state is greater than zero, i.e., all subsequent words are executed immediately instead of being compiled."},
            {"[ ]", "[ ] ( t i — x )\nReturns the (i+1) -st component t_{i+1} of Tuple t, where 0≤ i<|t|, cf. p:tuples."},
            {"[compile]", "[ compile] ❬word-name❭ ( — )\nCompiles ❬word-name❭ as if it were an ordinary word, even if it is active, cf. p:dict.lookup. Essentially equivalent to ' ❬word-name❭ execute."},
            {"]", "] ( x₁ … xₙ n — )\nCloses an internal interpreter session opened by [ and invokes (compile) or (execute) afterwards depending on whether state is greater than zero. For instance, { [ 2 3 + 1 ] * } is equivalent to { 5 * }."},
            {"`", "`❬word❭ ( — a )\nIntroduces an Atom literal, equal to the only Atom with the name equal to ❬word❭, cf. p:atoms. Equivalent to \"❬word❭\" atom."},
            {"abort", "abort ( S — )\nThrows an exception with an error message taken from String S, cf. p:exception.ops."},
            {"abort\"", "abort\"❬message❭\" ( x — )\nThrows an exception with the error message ❬message❭ if the Integer x is non-zero, cf. p:exception.ops."},
            {"abs", "abs ( x — |x| )\nComputes the absolute value |x|=max(x,-x) of Integer x. Equivalent to dup negate max."},
            {"allot", "allot ( n — t )\nCreates a new array, i.e., a Tuple that consists of n new empty Box es, cf. p:tuples. Equivalent to | { hole, } rot times."},
            {"and", "and ( x y — x& y )\nComputes the bitwise AND of two Integer s, cf. p:arith.op."},
            {"anon", "anon ( — a )\nCreates a new unique anonymous Atom, cf. p:atoms."},
            {"atom", "atom ( S — a )\nReturns the only Atom a with the name S, creating such an atom if necessary, cf. p:atoms. Equivalent to true (atom) drop."},
            {"atom?", "atom? ( u — ? )\nChecks whether u is an Atom, cf. p:atoms."},
            {"b+", "b+ ( b b' — b” )\nConcatenates two Builders b and b', cf. p:builder.ops."},
            {"b.", "b. ( x — )\nPrints the binary representation of an Integer x, followed by a single space. Equivalent to b._ space."},
            {"b._", "b._ ( x — )\nPrints the binary representation of an Integer x without any spaces. Equivalent to (b.) type."},
            {"b>", "b> ( b — c )\nTransforms a Builder b into a new Cell c containing the same data as b, cf. p:builder.ops."},
            {"b>idict!", "b>idict! ( v x s n — s' -1 or s 0 )\nAdds a new value v (represented by a Builder ) with key given by signed big-endian n -bit integer x into dictionary s with n -bit keys, and returns the new dictionary s' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary s and 0 are returned."},
            {"b>idict!+", "b>idict!+ ( v x s n — s' -1 or s 0 )\nAdds a new key-value pair (x,v) into dictionary s similarly to b>idict!, but fails if the key already exists by returning the unchanged dictionary s and 0, cf. p:hashmap.ops."},
            {"b>udict!", "b>udict! ( v x s n — s' -1 or s 0 )\nAdds a new value v (represented by a Builder ) with key given by unsigned big-endian n -bit integer x into dictionary s with n -bit keys, and returns the new dictionary s' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary s and 0 are returned."},
            {"b>udict!+", "b>udict!+ ( v x s n — s' -1 or s 0 )\nAdds a new key-value pair (x,v) into dictionary s similarly to b>udict!, but fails if the key already exists by returning the unchanged dictionary s and 0, cf. p:hashmap.ops."},
            {"bbitrefs", "bbitrefs ( b — x y )\nReturns both the number of data bits x and the number of references y already stored in Builder b, cf. p:builder.ops."},
            {"bbits", "bbits ( b — x )\nReturns the number of data bits already stored in Builder b. The result x is an Integer in the range 0…1023, cf. p:builder.ops."},
            {"bl", "bl ( — x )\nPushes the Unicode codepoint of a space, i.e., 32, cf. p:string.ops."},
            {"boc+>B", "boc+>B ( c x — B )\nCreates and serializes a “standard” bag of cells, containing one root Cell c along with all its descendants, cf. p:boc.ops. An Integer parameter 0≤ x≤ 31 is used to pass flags indicating the additional options for bag-of-cells serialization, with individual bits having the following effect: +1 enables bag-of-cells index creation (useful for lazy deserialization of large bags of cells). +2 includes the CRC32-C of all data into the serialization (useful for checking data integrity). +4 explicitly stores the hash of the root cell into the serialization (so that it can be quickly recovered afterwards without a complete deserialization). +8 stores hashes of some intermediate (non-leaf) cells (useful for lazy deserialization of large bags of cells). +16 stores cell cache bits to control caching of deserialized cells. Typical values of x are x=0 or x=2 for very small bags of cells (e.g., TON Blockchain external messages) and x=31 for large bags of cells (e.g., TON Blockchain blocks)."},
            {"boc>B", "boc>B ( c — B )\nSerializes a small “standard” bag of cells with root Cell c and all its descendants, cf. p:boc.ops. Equivalent to 0 boc+>B."},
            {"box", "box ( x — p )\nCreates a new Box containing specified value x, cf. p:variables. Equivalent to hole tuck !."},
            {"brefs", "brefs ( b — x )\nReturns the number of references already stored in Builder b, cf. p:builder.ops. The result x is an Integer in the range 0…4."},
            {"brembitrefs", "brembitrefs ( b — x y )\nReturns both the maximum number of additional data bits 0≤ x≤ 1023 and the maximum number of additional cell references 0≤ y≤ 4 that can be stored in Builder b, cf. p:builder.ops."},
            {"brembits", "brembits ( b — x )\nReturns the maximum number of additional data bits that can be stored in Builder b, cf. p:builder.ops. Equivalent to bbits 1023 swap -."},
            {"bremrefs", "bremrefs ( b — x )\nReturns the maximum number of additional cell references that can be stored in Builder b, cf. p:builder.ops."},
            {"bye", "bye ( — )\nQuits the Fift interpreter to the operating system with a zero exit code, cf. p:exit.fift. Equivalent to 0 halt."},
            {"b{", "b{❬binary-data❭} ( — s )\nCreates a Slice s that contains no references and up to 1023 data bits specified in ❬binary-data❭, which must be a string consisting only of the characters ` 0 ' and ` 1 ', cf. p:slice.lit."},
            {"caddr", "caddr ( l — h” )\nReturns the third element of a list. Equivalent to cddr car."},
            {"cadr", "cadr ( l — h' )\nReturns the second element of a list, cf. p:lists. Equivalent to cdr car."},
            {"car", "car ( l — h )\nReturns the head of a list, cf. p:lists. Equivalent to first."},
            {"cddr", "cddr ( l — t' )\nReturns the tail of the tail of a list. Equivalent to cdr cdr."},
            {"cdr", "cdr ( l — t )\nReturns the tail of a list, cf. p:lists. Equivalent to second."},
            {"char", "char ❬string❭ ( — x )\nPushes an Integer with the Unicode codepoint of the first character of ❬string❭, cf. p:string.ops. For instance, char * is equivalent to 42."},
            {"chr", "chr ( x — S )\nReturns a new String S consisting of one UTF-8 encoded character with Unicode codepoint x."},
            {"cmp", "cmp ( x y — z )\nCompares two Integer s x and y, and pushes 1 if x>y, -1 if x<y, and 0 if x=y, cf. p:int.comp. Approximately equivalent to - sgn."},
            {"cond", "cond ( x e e' — )\nIf Integer x is non-zero, executes e, otherwise executes e', cf. p:cond.ops."},
            {"cons", "cons ( h t — l )\nConstructs a list from its head (first element) h and its tail (the list consisting of all remaining elements) t, cf. p:lists. Equivalent to pair."},
            {"constant", "constant ( x — )\nScans a blank-delimited word name S from the remainder of the input, and defines a new ordinary word S as a constant, which will push the given value x (of arbitrary type) when invoked, cf. p:dict.create and p:constants."},
            {"count", "count ( t — n )\nReturns the length n=|t| of Tuple t, cf. p:tuples."},
            {"cr", "cr ( — )\nOutputs a carriage return (or a newline character) into the standard output, cf. p:string.ops."},
            {"create", "create ( e — )\nDefines a new ordinary word with the name equal to the next word scanned from the input, using WordDef e as its definition, cf. p:dict.create. If the word already exists, it is tacitly redefined."},
            {"csr.", "csr. ( s — )\nRecursively prints a Slice s, cf. p:slice.ops. On the first line, the data bits of s are displayed in hexadecimal form embedded into an x{…} construct similar to the one used for Slice literals (cf. p:slice.lit ). On the next lines, the cells referred to by s are printed with larger indentation."},
            {"def?", "def? ❬word-name❭ ( — ? )\nChecks whether the word ❬word-name❭ is defined at execution time, and returns -1 or 0 accordingly."},
            {"depth", "depth ( — n )\nReturns the current depth (the total number of entries) of the Fift stack as an Integer n≥0."},
            {"dictmap", "dictmap ( D n e — D' )\nApplies execution token e (i.e., an anonymous function) to each of the key-value pairs stored in a dictionary D with n -bit keys, cf. p:hashmap.ops. The execution token is executed once for each key-value pair, with a Builder b and a Slice v (containing the value) pushed into the stack before executing e. After the execution e must leave in the stack either a modified Builder b' (containing all data from b along with the new value v' ) and -1, or 0 indicating failure. In the latter case, the corresponding key is omitted from the new dictionary."},
            {"dictmerge", "dictmerge ( D D' n e — D” )\nCombines two dictionaries D and D' with n -bit keys into one dictionary D” with the same keys, cf. p:hashmap.ops. If a key is present in only one of the dictionaries D and D', this key and the corresponding value are copied verbatim to the new dictionary D”. Otherwise the execution token (anonymous function) e is invoked to merge the two values v and v' corresponding to the same key k in D and D', respectively. Before e is invoked, a Builder b and two Slice s v and v' representing the two values to be merged are pushed. After the execution e leaves either a modified Builder b' (containing the original data from b along with the combined value) and -1, or 0 on failure. In the latter case, the corresponding key is omitted from the new dictionary."},
            {"dictnew", "dictnew ( — D )\nPushes the Null value that represents a new empty dictionary, cf. p:hashmap.ops. Equivalent to null."},
            {"does", "does ( x₁ … xₙ n e — e' )\nCreates a new execution token e' that would push n values x₁, …, xₙ into the stack and then execute e when invoked, cf. p:wordlist.ops. It is roughly equivalent to a combination of ({), (compile), and (})."},
            {"drop", "drop ( x — )\nRemoves the top-of-stack entry, cf. p:stack.ops."},
            {"dup", "dup ( x — x x )\nDuplicates the top-of-stack entry, cf. p:stack.ops. If the stack is empty, throws an exception."},
            {"ed25519_chksign", "ed25519_chksign ( B B' B” — ? )\nChecks whether B' is a valid Ed25519-signature of data B with the public key B”, cf. p:ed25519.ops."},
            {"ed25519_sign", "ed25519_sign ( B B' — B” )\nSigns data B with the Ed25519 private key B' (a 32-byte Bytes value) and returns the signature as a 64-byte Bytes value B”, cf. p:ed25519.ops."},
            {"ed25519_sign_uint", "ed25519_sign_uint ( x B' — B” )\nConverts a big-endian unsigned 256-bit integer x into a 32-byte sequence and signs it using the Ed25519 private key B' similarly to ed25519_sign, cf. p:ed25519.ops. Equivalent to swap 256 u>B swap ed25519_sign. The integer x to be signed is typically computed as the hash of some data."},
            {"emit", "emit ( x — )\nPrints a UTF-8 encoded character with Unicode codepoint given by Integer x into the standard output, cf. p:string.ops. For instance, 42 emit prints an asterisk “ * ”, and 916 emit prints a Greek Delta “ Δ ”. Equivalent to chr type."},
            {"empty?", "empty? ( s — ? )\nChecks whether a Slice is empty (i.e., has no data bits and no references left), and returns -1 or 0 accordingly, cf. p:slice.ops."},
            {"eq?", "eq? ( u v — ? )\nChecks whether u and v are equal Integer s, Atom s, or Null s, cf. p:atoms. If they are not equal, or if they are of different types, or not of one of the types listed, returns zero."},
            {"exch", "exch ( xₙ … x₀ n — x₀ … xₙ )\nInterchanges the top of the stack with the n -th stack entry from the top, where n≥0 is also taken from the stack, cf. p:stack.ops. In particular, 1 exch is equivalent to swap, and 2 exch to swap rot."},
            {"exch2", "exch2 ( … n m — … )\nInterchanges the n -th stack entry from the top with the m -th stack entry from the top, where n≥0, m≥0 are taken from the stack, cf. p:stack.ops."},
            {"execute", "execute ( e — … )\nExecutes the execution token ( WordDef ) e, cf. p:blocks."},
            {"explode", "explode ( t — x₁ … xₙ n )\nUnpacks a Tuple t=(x₁,…,xₙ) of unknown length n, and returns that length, cf. p:tuples."},
            {"false", "false ( — 0 )\nPushes 0 into the stack, cf. p:bool. Equivalent to 0."},
            {"file-exists?", "file-exists? ( S — ? )\nChecks whether the file with the name specified in String S exists, cf. p:bytes.ops."},
            {"file>B", "file>B ( S — B )\nReads the (binary) file with the name specified in String S and returns its contents as a Bytes value, cf. p:bytes.ops. If the file does not exist, an exception is thrown."},
            {"find", "find ( S — e -1 or e 1 or 0 )\nLooks up String S in the dictionary and returns its definition as a WordDef e if found, followed by -1 for ordinary words or 1 for active words, cf. p:dict.lookup. Otherwise pushes 0."},
            {"first", "first ( t — x )\nReturns the first component of a Tuple, cf. p:tuples. Equivalent to 0 [ ] ."},
            {"fits", "fits ( x y — ? )\nChecks whether Integer x is a signed y -bit integer (i.e., whether -2ʸ⁻¹ ≤ x<2ʸ⁻¹ for 0≤ y≤ 1023 ), and returns -1 or 0 accordingly."},
            {"forget", "forget ( — )\nForgets (removes from the dictionary) the definition of the next word scanned from the input, cf. p:dict.create."},
            {"gasrunvm", "gasrunvm ( … s c z — … x c' z' )\nA gas-aware version of runvm, cf. p:tvm.ops: invokes a new instance of TVM with both the current continuation cc and the special register c3 initialized from Slice s, and initializes special register c4 (the “root of persistent data”, cf. [ 1.4 ] ) with Cell c. Then starts the new TVM instance with the gas limit set to z. The actually consumed gas z' is returned at the top of the final Fift stack, and the final value of c4 is returned immediately below the top of the final Fift stack as another Cell c'."},
            {"gasrunvmcode", "gasrunvmcode ( … s z — … x z' )\nA gas-aware version of runvmcode, cf. p:tvm.ops: invokes a new instance of TVM with the current continuation cc initialized from Slice s and with the gas limit set to z, thus executing code s in TVM. The original Fift stack (without s ) is passed in its entirety as the initial stack of the new TVM instance. When TVM terminates, its resulting stack is used as the new Fift stack, with the exit code x and the actually consumed gas z' pushed at its top. If x is non-zero, indicating that TVM has been terminated by an unhandled exception, the next stack entry from the top contains the parameter of this exception, and x is the exception code. All other entries are removed from the stack in this case."},
            {"gasrunvmctx", "gasrunvmctx ( … s c t z — … x c' z' )\nA gas-aware version of runvmctx, cf. p:tvm.ops. Differs from gasrunmv in that it initializes c7 with Tuple t."},
            {"gasrunvmdict", "gasrunvmdict ( … s z — … x z' )\nA gas-aware version of runvmdict, cf. p:tvm.ops: invokes a new instance of TVM with the current continuation cc initialized from Slice s and sets the gas limit to z similarly to gasrunvmcode, but also initializes the special register c3 with the same value, and pushes a zero into the initial TVM stack before the TVM execution begins. The actually consumed gas is returned as an Integer z'. In a typical application Slice s consists of a subroutine selection code that uses the top-of-stack Integer to select the subroutine to be executed, thus enabling the definition and execution of several mutually-recursive subroutines (cf. [ 4.6 ] and p:asm.prog ). The selector equal to zero corresponds to the main() subroutine in a large TVM program."},
            {"halt", "halt ( x — )\nQuits to the operating system similarly to bye, but uses Integer x as the exit code, cf. p:exit.fift."},
            {"hash", "hash ( c — x )\nA deprecated version of hashu. Use hashu or hashB instead."},
            {"hashB", "hashB ( c — B )\nComputes the SHA256 -based representation hash of Cell c (cf. [ 3.1 ] ), which unambiguously defines c and all its descendants (provided there are no collisions for SHA256 ), cf. p:hash.ops. The result is returned as a Bytes value consisting of exactly 32 bytes."},
            {"hashu", "hashu ( c — x )\nComputes the SHA256 -based representation hash of Cell c similarly to hashB, but returns the result as a big-endian unsigned 256-bit Integer."},
            {"hold", "hold ( S x — S' )\nAppends to String S one UTF-8 encoded character with Unicode codepoint x. Equivalent to chr $+."},
            {"hole", "hole ( — p )\nCreates a new Box p that does not hold any value, cf. p:variables. Equivalent to null box."},
            {"i,", "i, ( b x y — b' )\nAppends the big-endian binary representation of a signed y -bit integer x to Builder b, where 0≤ y≤ 257, cf. p:builder.ops. If there is not enough room in b (i.e., if b already contains more than 1023-y data bits), or if Integer x does not fit into y bits, an exception is thrown."},
            {"i>B", "i>B ( x y — B )\nStores a signed big-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"i@", "i@ ( s x — y )\nFetches a signed big-endian x -bit integer from the first x bits of Slice s, cf. p:slice.ops. If s contains less than x data bits, an exception is thrown."},
            {"i@+", "i@+ ( s x — y s' )\nFetches a signed big-endian x -bit integer from the first x bits of Slice s similarly to i@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"i@?", "i@? ( s x — y -1 or 0 )\nFetches a signed big-endian integer from a Slice similarly to i@, but pushes integer -1 afterwards on success, cf. p:slice.ops. If there are less than x bits left in s, pushes integer 0 to indicate failure."},
            {"i@?+", "i@?+ ( s x — y s' -1 or s 0 )\nFetches a signed big-endian integer from Slice s and computes the remainder of this Slice similarly to i@+, but pushes -1 afterwards to indicate success, cf. p:slice.ops. On failure, pushes the unchanged Slice s and 0 to indicate failure."},
            {"idict!", "idict! ( v x D n — D' -1 or D 0 )\nAdds a new value v (represented by a Slice ) with key given by signed big-endian n -bit integer x into dictionary D with n -bit keys, and returns the new dictionary D' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary D and 0 are returned."},
            {"idict!+", "idict!+ ( v x D n — D' -1 or D 0 )\nAdds a new key-value pair (x,v) into dictionary D similarly to idict!, but fails if the key already exists by returning the unchanged dictionary D and 0, cf. p:hashmap.ops."},
            {"idict@", "idict@ ( x D n — v -1 or 0 )\nLooks up key represented by signed big-endian n -bit Integer x in the dictionary represented by Cell or Null D, cf. p:hashmap.ops. If the key is found, returns the corresponding value as a Slice v and -1. Otherwise returns 0."},
            {"if", "if ( x e — )\nExecutes execution token (i.e., a WordDef ) e, but only if Integer x is non-zero, cf. p:cond.ops."},
            {"ifnot", "ifnot ( x e — )\nExecutes execution token e, but only if Integer x is zero, cf. p:cond.ops."},
            {"include", "include ( S — )\nLoads and interprets a Fift source file from the path given by String S, cf. p:asm.load. If the filename S does not begin with a slash, the Fift include search path, typically taken from the FIFTPATH environment variable or the -I command-line argument of the Fift interpreter (and equal to /usr/lib/fift if both are absent), is used to locate S."},
            {"list", "list ( x₁ … xₙ n — l )\nConstructs a list l of length n with elements x₁, …, xₙ, in that order, cf. p:lists. Equivalent to null ' cons rot times."},
            {"max", "max ( x y — z )\nComputes the maximum z:=max(x,y) of two Integer s x and y. Equivalent to minmax nip."},
            {"min", "min ( x y — z )\nComputes the minimum z:=min(x,y) of two Integer s x and y. Equivalent to minmax drop."},
            {"minmax", "minmax ( x y — z t )\nComputes both the minimum z:=min(x,y) and the maximum t:=max(x,y) of two Integer s x and y."},
            {"mod", "mod ( x y — r:=x mod y )\nComputes the remainder x mod y=x-y⋅ ⌊x/y⌋ of division of x by y, cf. p:arith.op."},
            {"negate", "negate ( x — -x )\nChanges the sign of an Integer, cf. p:arith.op."},
            {"newkeypair", "newkeypair ( — B B' )\nGenerates a new Ed25519 private/public key pair, and returns both the private key B and the public key B' as 32-byte Bytes values, cf. p:ed25519.ops. The quality of the keys is good enough for testing purposes. Real applications must feed enough entropy into OpenSSL PRNG before generating Ed25519 keypairs."},
            {"nil", "nil ( — t )\nPushes the empty Tuple t=(). Equivalent to 0 tuple."},
            {"nip", "nip ( x y — y )\nRemoves the second stack entry from the top, cf. p:stack.ops. Equivalent to swap drop."},
            {"nop", "nop ( — )\nDoes nothing, cf. p:dict.lookup."},
            {"not", "not ( x — -1-x )\nComputes the bitwise complement of an Integer, cf. p:arith.op."},
            {"now", "now ( — x )\nReturns the current Unixtime as an Integer, cf. p:ed25519.ops."},
            {"null", "null ( — ot )\nPushes the Null value, cf. p:lists"},
            {"null!", "null! ( p — )\nStores a Null value into Box p. Equivalent to null swap !."},
            {"null?", "null? ( x — ? )\nChecks whether x is Null, cf. p:lists."},
            {"or", "or ( x y — x|y )\nComputes the bitwise OR of two Integer s, cf. p:arith.op."},
            {"over", "over ( x y — x y x )\nCreates a copy of the second stack entry from the top over the top-of-stack entry, cf. p:stack.ops."},
            {"pair", "pair ( x y — t )\nCreates new pair t=(x,y), cf. p:tuples. Equivalent to 2 tuple or to | rot, swap,."},
            {"pfxdict!", "pfxdict! ( v k s n — s' -1 or s 0 )\nAdds key-value pair (k,v), both represented by Slice s, into a prefix dictionary s with keys of length at most n, cf. p:hashmap.ops. On success, returns the modified dictionary s' and -1. On failure, returns the original dictionary s and 0."},
            {"pfxdict!+", "pfxdict!+ ( v k s n — s' -1 or s 0 )\nAdds key-value pair (k,v) into prefix dictionary s similarly to pfxdict!, but fails if the key already exists, cf. p:hashmap.ops."},
            {"pfxdict@", "pfxdict@ ( k s n — v -1 or 0 )\nLooks up key k (represented by a Slice ) in the prefix dictionary s with the length of keys limited by n bits, cf. p:hashmap.ops. On success, returns the value found as a Slice v and -1. On failure, returns 0."},
            {"pick", "pick ( xₙ … x₀ n — xₙ … x₀ xₙ )\nCreates a copy of the n -th entry from the top of the stack, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 0 pick is equivalent to dup, and 1 pick to over."},
            {"priv>pub", "priv>pub ( B — B' )\nComputes the public key corresponding to a private Ed25519 key, cf. p:ed25519.ops. Both the public key B' and the private key B are represented by 32-byte Bytes values."},
            {"quit", "quit ( … — )\nExits to the topmost level of the Fift interpreter (without printing an ok in interactive mode) and clears the stack, cf. p:exit.fift."},
            {"ref,", "ref, ( b c — b' )\nAppends to Builder b a reference to Cell c, cf. p:builder.ops. If b already contains four references, an exception is thrown."},
            {"ref@", "ref@ ( s — c )\nFetches the first reference from the Slice s and returns the Cell c referred to, cf. p:slice.ops. If there are no references left, throws an exception."},
            {"ref@+", "ref@+ ( s — s' c )\nFetches the first reference from the Slice s similarly to ref@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"ref@?", "ref@? ( s — c -1 or 0 )\nFetches the first reference from the Slice s similarly to ref@, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"ref@?+", "ref@?+ ( s — s' c -1 or s 0 )\nSimilar to ref@+, but uses a flag to indicate failure instead of throwing an exception, cf. p:slice.ops."},
            {"remaining", "remaining ( s — x y )\nReturns both the number of data bits x and the number of cell references y remaining in the Slice s, cf. p:slice.ops."},
            {"reverse", "reverse ( x₁ … xₙ y₁ … yₘ n m — xₙ … x₁ y₁ … yₘ )\nReverses the order of n stack entries located immediately below the topmost m elements, where both 0≤ m,n≤ 255 are passed in the stack."},
            {"roll", "roll ( xₙ … x₀ n — x_{n-1} … x₀ xₙ )\nRotates the top n stack entries, where n≥0 is also passed in the stack, cf. p:stack.ops. In particular, 1 roll is equivalent to swap, and 2 roll to rot."},
            {"rot", "rot ( x y z — y z x )\nRotates the three topmost stack entries."},
            {"runvm", "runvm ( … s c — … x c' )\nInvokes a new instance of TVM with both the current continuation cc and the special register c3 initialized from Slice s, and initializes special register c4 (the “root of persistent data”, cf. [ 1.4 ] ) with Cell c, cf. p:tvm.ops. In contrast with runvmdict, does not push an implicit zero into the initial TVM stack; if necessary, it can be explicitly passed under s. The final value of c4 is returned at the top of the final Fift stack as another Cell c'. In this way one can emulate the execution of smart contracts that inspect or modify their persistent storage."},
            {"runvmcode", "runvmcode ( … s — … x )\nInvokes a new instance of TVM with the current continuation cc initialized from Slice s, thus executing code s in TVM, cf. p:tvm.ops. The original Fift stack (without s ) is passed in its entirety as the initial stack of the new TVM instance. When TVM terminates, its resulting stack is used as the new Fift stack, with the exit code x pushed at its top. If x is non-zero, indicating that TVM has been terminated by an unhandled exception, the next stack entry from the top contains the parameter of this exception, and x is the exception code. All other entries are removed from the stack in this case."},
            {"runvmctx", "runvmctx ( … s c t — … x c' )\nA variant of runvm that also initializes c7 (the “context register” of TVM) with Tuple t, cf. p:tvm.ops."},
            {"runvmdict", "runvmdict ( … s — … x )\nInvokes a new instance of TVM with the current continuation cc initialized from Slice s similarly to runvmcode, but also initializes the special register c3 with the same value, and pushes a zero into the initial TVM stack before start, cf. p:tvm.ops. In a typical application Slice s consists of a subroutine selection code that uses the top-of-stack Integer to select the subroutine to be executed, thus enabling the definition and execution of several mutually-recursive subroutines (cf. [ 4.6 ] and p:asm.prog ). The selector equal to zero corresponds to the main() subroutine in a large TVM program."},
            {"s,", "s, ( b s — b' )\nAppends data bits and references taken from Slice s to Builder b, cf. p:builder.ops."},
            {"s>", "s> ( s — )\nThrows an exception if Slice s is non-empty, cf. p:slice.ops. It usually marks the end of the deserialization of a cell, checking whether there are any unprocessed data bits or references left."},
            {"s>c", "s>c ( s — c )\nCreates a Cell c directly from a Slice s, cf. p:slice.ops. Equivalent to <b swap s, b>."},
            {"sbitrefs", "sbitrefs ( s — x y )\nReturns both the number of data bits x and the number of cell references y remaining in Slice s, cf. p:slice.ops. Equivalent to remaining."},
            {"sbits", "sbits ( s — x )\nReturns the number of data bits x remaining in Slice s, cf. p:slice.ops."},
            {"second", "second ( t — x )\nReturns the second component of a Tuple, cf. p:tuples. Equivalent to 1 [ ] ."},
            {"sgn", "sgn ( x — y )\nComputes the sign of an Integer x (i.e., pushes 1 if x>0, -1 if x<0, and 0 if x=0 ), cf. p:int.comp. Equivalent to 0 cmp."},
            {"shash", "shash ( s — B )\nComputes the SHA256 -based representation hash of a Slice by first transforming it into a cell, cf. p:hash.ops. Equivalent to s>c hashB."},
            {"sign", "sign ( S x — S' )\nAppends a minus sign “ - ” to String S if Integer x is negative. Otherwise leaves S intact."},
            {"single", "single ( x — t )\nCreates new singleton t=(x), i.e., a one-element Tuple. Equivalent to 1 tuple."},
            {"skipspc", "skipspc ( — )\nSkips blank characters from the current input line until a non-blank or an end-of-line character is found."},
            {"smca>$", "smca>$ ( x y z — S )\nPacks a standard TON smart-contract address with workchain x (a signed 32-bit Integer ) and in-workchain address y (an unsigned 256-bit Integer ) into a 48-character string S (the human-readable representation of the address) according to flags z, cf. p:smc.addr.ops. Possible individual flags in z are: +1 for non-bounceable addresses, +2 for testnet-only addresses, and +4 for base64url output instead of base64."},
            {"space", "space ( — )\nOutputs a single space. Equivalent to bl emit or to .\" \"."},
            {"sr,", "sr, ( b s — b' )\nConstructs a new Cell containing all data and references from Slice s, and appends a reference to this cell to Builder b, cf. p:builder.ops. Equivalent to s>c ref,."},
            {"srefs", "srefs ( s — x )\nReturns the number of cell references x remaining in Slice s, cf. p:slice.ops."},
            {"swap", "swap ( x y — y x )\nInterchanges the two topmost stack entries, cf. p:stack.ops."},
            {"ten", "ten ( — 10 )\nPushes Integer constant 10."},
            {"third", "third ( t — x )\nReturns the third component of a Tuple, cf. p:tuples. Equivalent to 2 [ ] ."},
            {"times", "times ( e n — )\nExecutes execution token ( WordDef ) e exactly n times, if n≥0, cf. p:simple.loops. If n is negative, throws an exception."},
            {"triple", "triple ( x y z — t )\nCreates new triple t=(x,y,z), cf. p:tuples. Equivalent to 3 tuple."},
            {"true", "true ( — -1 )\nPushes -1 into the stack, cf. p:bool. Equivalent to -1."},
            {"tuck", "tuck ( x y — y x y )\nEquivalent to swap over, cf. p:stack.ops."},
            {"tuple", "tuple ( x₁ … xₙ n — t )\nCreates new Tuple t:=(x₁,…,xₙ) from n≥0 topmost stack values, cf. p:tuples. Equivalent to dup 1 reverse | { swap, } rot times, but more efficient."},
            {"tuple?", "tuple? ( t — ? )\nChecks whether t is a Tuple, and returns -1 or 0 accordingly."},
            {"type", "type ( s — )\nPrints a String s taken from the top of the stack into the standard output, cf. p:string.ops."},
            {"u,", "u, ( b x y — b' )\nAppends the big-endian binary representation of an unsigned y -bit integer x to Builder b, where 0≤ y≤ 256, cf. p:builder.ops. If the operation is impossible, an exception is thrown."},
            {"u>B", "u>B ( x y — B )\nStores an unsigned big-endian y -bit Integer x into a Bytes value B consisting of exactly y/8 bytes. Integer y must be a multiple of eight in the range 0…256, cf. p:bytes.ops."},
            {"u@", "u@ ( s x — y )\nFetches an unsigned big-endian x -bit integer from the first x bits of Slice s, cf. p:slice.ops. If s contains less than x data bits, an exception is thrown."},
            {"u@+", "u@+ ( s x — y s' )\nFetches an unsigned big-endian x -bit integer from the first x bits of Slice s similarly to u@, but returns the remainder of s as well, cf. p:slice.ops."},
            {"u@?", "u@? ( s x — y -1 or 0 )\nFetches an unsigned big-endian integer from a Slice similarly to u@, but pushes integer -1 afterwards on success, cf. p:slice.ops. If there are less than x bits left in s, pushes integer 0 to indicate failure."},
            {"u@?+", "u@?+ ( s x — y s' -1 or s 0 )\nFetches an unsigned big-endian integer from Slice s and computes the remainder of this Slice similarly to u@+, but pushes -1 afterwards to indicate success, cf. p:slice.ops. On failure, pushes the unchanged Slice s and 0 to indicate failure."},
            {"udict!", "udict! ( v x D n — D' -1 or D 0 )\nAdds a new value v (represented by a Slice ) with key given by big-endian unsigned n -bit integer x into dictionary D with n -bit keys, and returns the new dictionary D' and -1 on success, cf. p:hashmap.ops. Otherwise the unchanged dictionary D and 0 are returned."},
            {"udict!+", "udict!+ ( v x D n — D' -1 or D 0 )\nAdds a new key-value pair (x,v) into dictionary D similarly to udict!, but fails if the key already exists by returning the unchanged dictionary D and 0, cf. p:hashmap.ops."},
            {"udict@", "udict@ ( x D n — v -1 or 0 )\nLooks up key represented by unsigned big-endian n -bit Integer x in the dictionary represented by Cell or Null D, cf. p:hashmap.ops. If the key is found, returns the corresponding value as a Slice v and -1. Otherwise returns 0."},
            {"ufits", "ufits ( x y — ? )\nChecks whether Integer x is an unsigned y -bit integer (i.e., whether 0≤ x<2ʸ for 0≤ y≤ 1023 ), and returns -1 or 0 accordingly."},
            {"uncons", "uncons ( l — h t )\nDecomposes a non-empty list into its head and its tail, cf. p:lists. Equivalent to unpair."},
            {"undef?", "undef? ❬word-name❭ ( — ? )\nChecks whether the word ❬word-name❭ is undefined at execution time, and returns -1 or 0 accordingly."},
            {"unpair", "unpair ( t — x y )\nUnpacks a pair t=(x,y), cf. p:tuples. Equivalent to 2 untuple."},
            {"unsingle", "unsingle ( t — x )\nUnpacks a singleton t=(x). Equivalent to 1 untuple."},
            {"until", "until ( e — )\nAn until loop, cf. p:loops: executes WordDef e, then removes the top-of-stack integer and checks whether it is zero. If it is, then begins a new iteration of the loop by executing e. Otherwise exits the loop."},
            {"untriple", "untriple ( t — x y z )\nUnpacks a triple t=(x,y,z), cf. p:tuples. Equivalent to 3 untuple."},
            {"untuple", "untuple ( t n — x₁ … xₙ )\nReturns all components of a Tuple t=(x₁,…,xₙ), but only if its length is equal to n, cf. p:tuples. Otherwise throws an exception."},
            {"variable", "variable ( — )\nScans a blank-delimited word name S from the remainder of the input, allocates an empty Box, and defines a new ordinary word S as a constant, which will push the new Box when invoked, cf. p:variables. Equivalent to hole constant."},
            {"while", "while ( e e' — )\nA while loop, cf. p:loops: executes WordDef e, then removes and checks the top-of-stack integer. If it is zero, exits the loop. Otherwise executes WordDef e', then begins a new loop iteration by executing e and checking the exit condition afterwards."},
            {"word", "word ( x — s )\nParses a word delimited by the character with the Unicode codepoint x from the remainder of the current input line and pushes the result as a String, cf. p:string.ops. For instance, bl word abracadabra type will print the string “ abracadabra ”. If x=0, skips leading spaces, and then scans until the end of the current input line. If x=32, skips leading spaces before parsing the next word."},
            {"words", "words ( — )\nPrints the names of all words currently defined in the dictionary, cf. p:dict.lookup."},
            {"x.", "x. ( x — )\nPrints the hexadecimal representation (without the 0x prefix) of an Integer x, followed by a single space. Equivalent to x._ space."},
            {"x._", "x._ ( x — )\nPrints the hexadecimal representation (without the 0x prefix) of an Integer x without any spaces. Equivalent to (x.) type."},
            {"xor", "xor ( x y — x⊕ y )\nComputes the bitwise eXclusive OR of two Integer s, cf. p:arith.op."},
            {"x{", "x{❬hex-data❭} ( — s )\nCreates a Slice s that contains no references and up to 1023 data bits specified in ❬hex-data❭, cf. p:slice.lit. More precisely, each hex digit from ❬hex-data❭ is transformed into four binary digits in the usual fashion. After that, if the last character of ❬hex-data❭ is an underscore _, then all trailing binary zeroes and the binary one immediately preceding them are removed from the resulting binary string (cf. [ 1.0 ] for more details). For instance, x{6C_} is equivalent to b{01101}."},
            {"{", "{ ( — l )\nAn active word that increases internal variable state by one and pushes a new empty WordList into the stack, cf. p:wordlist.ops."},
            {"|", "| ( — t )\nCreates an empty Tuple t=(), cf. p:tuples. Equivalent to nil and to 0 tuple."},
            {"|+", "|+ ( s s' — s” )\nConcatenates two Slice s and s', cf. p:slice.lit. This means that the data bits of the new Slice s” are obtained by concatenating the data bits of s and s', and the list of Cell references of s” is constructed similarly by concatenating the corresponding lists for s and s'. Equivalent to <b rot s, swap s, b> <s."},
            {"|_", "|_ ( s s' — s” )\nGiven two Slice s s and s', creates a new Slice s”, which is obtained from s by appending a new reference to a Cell containing s', cf. p:slice.lit. Equivalent to <b rot s, swap s>c ref, b> <s."},
            {"}", "} ( l — e )\nAn active word that transforms a WordList l into a WordDef (an execution token) e, thus making all further modifications of l impossible, and decreases internal variable state by one; then pushes the integer 1, followed by a 'nop, cf. p:wordlist.ops. The net effect is to transform the constructed WordList into an execution token and push this execution token into the stack, either immediately or during the execution of an outer block."},
            {"NOP", "x{00} — NOP, does nothing."},
            {"XCHG", "x{01} — XCHG s1, also known as SWAP.\nx{0i} — XCHG s(i) or XCHG s0,s(i), interchanges the top of the stack with s(i), 1≤ i≤ 15.\nx{0i} — XCHG s(i) or XCHG s0,s(i), interchanges the top of the stack with s(i), 1≤ i≤ 15.\nx{10ij} — XCHG s(i),s(j), 1≤ i<j≤15, interchanges s(i) with s(j).\nx{11ii} — XCHG s0,s(ii)\\nWith 0≤ ii≤255.\nx{1i} — XCHG s1,s(i), 2≤ i≤ 15."},
            {"SWAP", "x{01} — XCHG s1, also known as SWAP."},
            {"PUSH", "x{2i} — PUSH s(i), 0≤ i≤ 15, pushes a copy of the old s(i) into the stack.\nx{20} — PUSH s0, also known as DUP.\nx{21} — PUSH s1, also known as OVER.\nx{56ii} — PUSH s(ii) for 0≤ ii≤ 255.\nx{ED4i} — PUSH c(i) or PUSHCTR c(i) ( — x ), pushes the current value of control register c(i). If the control register is not supported in the current codepage, or if it does not have a value, an exception is triggered.\nx{ED44} — PUSH c4 or PUSHROOT, pushes the “global data root” cell reference, thus enabling access to persistent smart-contract data."},
            {"DUP", "x{20} — PUSH s0, also known as DUP."},
            {"OVER", "x{21} — PUSH s1, also known as OVER."},
            {"POP", "x{3i} — POP s(i), 0≤ i≤ 15, pops the old top-of-stack value into the old s(i).\nx{30} — POP s0, also known as DROP, discards the top-of-stack value.\nx{31} — POP s1, also known as NIP.\nx{57ii} — POP s(ii) for 0≤ ii≤ 255.\nx{ED5i} — POP c(i) or POPCTR c(i) ( x — ), pops a value x from the stack and stores it into control register c(i), if supported in the current codepage. Notice that if a control register accepts only values of a specific type, a type-checking exception may occur.\nx{ED54} — POP c4 or POPROOT, sets the “global data root” cell reference, thus allowing modification of persistent smart-contract data."},
            {"DROP", "x{30} — POP s0, also known as DROP, discards the top-of-stack value."},
            {"NIP", "x{31} — POP s1, also known as NIP."},
            {"XCHG3", "x{4ijk} — XCHG3 s(i),s(j),s(k), equivalent to XCHG s2,s(i); XCHG s1, s(j); XCHG s0,s(k), with 0≤ i,j,k≤ 15.\nx{540ijk} — XCHG3 s(i),s(j),s(k) (long form)."},
            {"XCHG2", "x{50ij} — XCHG2 s(i),s(j), equivalent to XCHG s1,s(i); XCHG s(j)."},
            {"XCPU", "x{51ij} — XCPU s(i),s(j), equivalent to XCHG s(i); PUSH s(j)."},
            {"PUXC", "x{52ij} — PUXC s(i),s(j-1), equivalent to PUSH s(i); SWAP; XCHG s(j)."},
            {"PUSH2", "x{53ij} — PUSH2 s(i),s(j), equivalent to PUSH s(i); PUSH s(j+1)."},
            {"XC2PU", "x{541ijk} — XC2PU s(i),s(j),s(k), equivalent to XCHG2 s(i),s(j); PUSH s(k)."},
            {"XCPUXC", "x{542ijk} — XCPUXC s(i),s(j),s(k-1), equivalent to XCHG s1,s(i); PUXC s(j),s(k-1)."},
            {"XCPU2", "x{543ijk} — XCPU2 s(i),s(j),s(k), equivalent to XCHG s(i); PUSH2 s(j), s(k)."},
            {"PUXC2", "x{544ijk} — PUXC2 s(i),s(j-1),s(k-1), equivalent to PUSH s(i); XCHG s2; XCHG2 s(j),s(k)."},
            {"PUXCPU", "x{545ijk} — PUXCPU s(i),s(j-1),s(k-1), equivalent to PUXC s(i),s(j-1); PUSH s(k)."},
            {"PU2XC", "x{546ijk} — PU2XC s(i),s(j-1),s(k-2), equivalent to PUSH s(i); SWAP; PUXC s(j),s(k-1)."},
            {"PUSH3", "x{547ijk} — PUSH3 s(i),s(j),s(k), equivalent to PUSH s(i); PUSH2 s(j+1),s(k+1)."},
            {"BLKSWAP", "x{55ij} — BLKSWAP i+1,j+1, permutes two blocks s(j+i+1) … and s(j) …, for 0≤ i,j≤15. Equivalent to REVERSE i+1,j+1; REVERSE j+1,0; REVERSE i+j+2,0."},
            {"ROT2", "x{5513} — ROT2 or 2ROT ( a b c d e f — c d e f a b )\\nRotates the three topmost pairs of stack entries."},
            {"2ROT", "x{5513} — ROT2 or 2ROT ( a b c d e f — c d e f a b )\\nRotates the three topmost pairs of stack entries."},
            {"ROLL", "x{550i} — ROLL i+1, rotates the top i+1 stack entries. Equivalent to BLKSWAP 1,i+1."},
            {"ROLLREV", "x{55i0} — ROLLREV i+1 or -ROLL i+1, rotates the top i+1 stack entries in the other direction. Equivalent to BLKSWAP i+1,1."},
            {"-ROLL", "x{55i0} — ROLLREV i+1 or -ROLL i+1, rotates the top i+1 stack entries in the other direction. Equivalent to BLKSWAP i+1,1."},
            {"ROT", "x{58} — ROT ( a b c — b c a )\\nEquivalent to BLKSWAP 1,2 or to XCHG2 s2,s1."},
            {"ROTREV", "x{59} — ROTREV or -ROT ( a b c — c a b )\\nEquivalent to BLKSWAP 2,1 or to XCHG2 s2,s2."},
            {"-ROT", "x{59} — ROTREV or -ROT ( a b c — c a b )\\nEquivalent to BLKSWAP 2,1 or to XCHG2 s2,s2."},
            {"SWAP2", "x{5A} — SWAP2 or 2SWAP ( a b c d — c d a b )\\nEquivalent to BLKSWAP 2,2 or to XCHG2 s3,s2."},
            {"2SWAP", "x{5A} — SWAP2 or 2SWAP ( a b c d — c d a b )\\nEquivalent to BLKSWAP 2,2 or to XCHG2 s3,s2."},
            {"DROP2", "x{5B} — DROP2 or 2DROP ( a b — )\\nEquivalent to DROP; DROP."},
            {"2DROP", "x{5B} — DROP2 or 2DROP ( a b — )\\nEquivalent to DROP; DROP."},
            {"DUP2", "x{5C} — DUP2 or 2DUP ( a b — a b a b )\\nEquivalent to PUSH2 s1,s0."},
            {"2DUP", "x{5C} — DUP2 or 2DUP ( a b — a b a b )\\nEquivalent to PUSH2 s1,s0."},
            {"OVER2", "x{5D} — OVER2 or 2OVER ( a b c d — a b c d a b )\\nEquivalent to PUSH2 s3,s2."},
            {"2OVER", "x{5D} — OVER2 or 2OVER ( a b c d — a b c d a b )\\nEquivalent to PUSH2 s3,s2."},
            {"REVERSE", "x{5Eij} — REVERSE i+2,j, reverses the order of s(j+i+1) … for 0≤ i,j≤ 15; equivalent to a sequence of ⌊i/2⌋ +1 XCHG s."},
            {"BLKDROP", "x{5F0i} — BLKDROP i, equivalent to DROP performed i times."},
            {"BLKPUSH", "x{5Fij} — BLKPUSH i,j, equivalent to PUSH s(j) performed i times, 1≤ i≤ 15, 0≤ j≤ 15."},
            {"PICK", "x{60} — PICK or PUSHX, pops integer i from the stack, then performs PUSH s(i)."},
            {"PUSHX", "x{60} — PICK or PUSHX, pops integer i from the stack, then performs PUSH s(i)."},
            {"ROLLX", "x{61} — ROLLX, pops integer i from the stack, then performs BLKSWAP 1,i."},
            {"-ROLLX", "x{62} — -ROLLX or ROLLREVX, pops integer i from the stack, then performs BLKSWAP i,1."},
            {"ROLLREVX", "x{62} — -ROLLX or ROLLREVX, pops integer i from the stack, then performs BLKSWAP i,1."},
            {"BLKSWX", "x{63} — BLKSWX, pops integers i, j from the stack, then performs BLKSWAP i,j."},
            {"REVX", "x{64} — REVX, pops integers i, j from the stack, then performs REVERSE i,j."},
            {"DROPX", "x{65} — DROPX, pops integer i from the stack, then performs BLKDROP i."},
            {"TUCK", "x{66} — TUCK ( a b - b a b )\\nEquivalent to SWAP; OVER or to XCPU s1,s1."},
            {"XCHGX", "x{67} — XCHGX, pops integer i from the stack, then performs XCHG s(i)."},
            {"DEPTH", "x{68} — DEPTH, pushes the current depth of the stack."},
            {"CHKDEPTH", "x{69} — CHKDEPTH, pops integer i from the stack, then checks whether there are at least i elements, generating a stack underflow exception otherwise."},
            {"ONLYTOPX", "x{6A} — ONLYTOPX, pops integer i from the stack, then removes all but the top i elements."},
            {"ONLYX", "x{6B} — ONLYX, pops integer i from the stack, then leaves only the bottom i elements. Approximately equivalent to DEPTH; SWAP; SUB; DROPX."},
            {"NULL", "x{6D} — NULL or PUSHNULL ( — ot )\\nPushes the only value of type Null."},
            {"PUSHNULL", "x{6D} — NULL or PUSHNULL ( — ot )\\nPushes the only value of type Null."},
            {"ISNULL", "x{6E} — ISNULL ( x — ? )\\nChecks whether x is a Null, and returns -1 or 0 accordingly."},
            {"TUPLE", "x{6F0n} — TUPLE n ( x₁ … xₙ — t )\\nCreates a new Tuple t=(x₁,…,xₙ) containing n values x₁, …, xₙ, where 0≤ n≤ 15."},
            {"NIL", "x{6F00} — NIL ( — t )\\nPushes the only Tuple t=() of length zero."},
            {"SINGLE", "x{6F01} — SINGLE ( x — t )\\nCreates a singleton t:=(x), i.e., a Tuple of length one."},
            {"PAIR", "x{6F02} — PAIR or CONS ( x y — t )\\nCreates pair t:=(x,y)."},
            {"CONS", "x{6F02} — PAIR or CONS ( x y — t )\\nCreates pair t:=(x,y)."},
            {"TRIPLE", "x{6F03} — TRIPLE ( x y z — t )\\nCreates triple t:=(x,y,z)."},
            {"INDEX", "x{6F1k} — INDEX k ( t — x )\\nReturns the k -th element of a Tuple t, where 0≤ k≤ 15. In other words, returns x_{k+1} if t=(x₁,…,xₙ). If k≥ n, throws a range check exception."},
            {"FIRST", "x{6F10} — FIRST or CAR ( t — x )\\nReturns the first element of a Tuple."},
            {"CAR", "x{6F10} — FIRST or CAR ( t — x )\\nReturns the first element of a Tuple."},
            {"SECOND", "x{6F11} — SECOND or CDR ( t — y )\\nReturns the second element of a Tuple."},
            {"CDR", "x{6F11} — SECOND or CDR ( t — y )\\nReturns the second element of a Tuple."},
            {"THIRD", "x{6F12} — THIRD ( t — z )\\nReturns the third element of a Tuple."},
            {"UNTUPLE", "x{6F2n} — UNTUPLE n ( t — x₁ … xₙ )\\nUnpacks a Tuple t=(x₁,…,xₙ) of length equal to 0≤ n≤ 15. If t is not a Tuple, of if |t|≠ n, a type check exception is thrown."},
            {"UNSINGLE", "x{6F21} — UNSINGLE ( t — x )\\nUnpacks a singleton t=(x)."},
            {"UNPAIR", "x{6F22} — UNPAIR or UNCONS ( t — x y )\\nUnpacks a pair t=(x,y)."},
            {"UNCONS", "x{6F22} — UNPAIR or UNCONS ( t — x y )\\nUnpacks a pair t=(x,y)."},
            {"UNTRIPLE", "x{6F23} — UNTRIPLE ( t — x y z )\\nUnpacks a triple t=(x,y,z)."},
            {"UNPACKFIRST", "x{6F3k} — UNPACKFIRST k ( t — x₁ … x_k )\\nUnpacks first 0≤ k≤ 15 elements of a Tuple t. If |t|<k, throws a type check exception."},
            {"CHKTUPLE", "x{6F30} — CHKTUPLE ( t — )\\nChecks whether t is a Tuple."},
            {"EXPLODE", "x{6F4n} — EXPLODE n ( t — x₁ … xₘ m )\\nUnpacks a Tuple t=(x₁,…,xₘ) and returns its length m, but only if m≤ n≤ 15. Otherwise throws a type check exception."},
            {"SETINDEX", "x{6F5k} — SETINDEX k ( t x — t' )\\nComputes Tuple t' that differs from t only at position t'_{k+1}, which is set to x. In other words, |t'|=|t|, t'_i=t_i for i≠ k+1, and t'_{k+1}=x, for given 0≤ k≤15. If k≥|t|, throws a range check exception."},
            {"SETFIRST", "x{6F50} — SETFIRST ( t x — t' )\\nSets the first component of Tuple t to x and returns the resulting Tuple t'."},
            {"SETSECOND", "x{6F51} — SETSECOND ( t x — t' )\\nSets the second component of Tuple t to x and returns the resulting Tuple t'."},
            {"SETTHIRD", "x{6F52} — SETTHIRD ( t x — t' )\\nSets the third component of Tuple t to x and returns the resulting Tuple t'."},
            {"INDEXQ", "x{6F6k} — INDEXQ k ( t — x )\\nReturns the k -th element of a Tuple t, where 0≤ k≤ 15. In other words, returns x_{k+1} if t=(x₁,…,xₙ). If k≥ n, or if t is Null, returns a Null instead of x."},
            {"SETINDEXQ", "x{6F7k} — SETINDEXQ k ( t x — t' )\\nSets the k -th component of Tuple t to x, where 0≤ k<16, and returns the resulting Tuple t'. If |t|≤ k, first extends the original Tuple to length k+1 by setting all new components to Null. If the original value of t is Null, treats it as an empty Tuple. If t is not Null or Tuple, throws an exception. If x is Null and either |t|≤ k or t is Null, then always returns t'=t (and does not consume tuple creation gas)."},
            {"TUPLEVAR", "x{6F80} — TUPLEVAR ( x₁ … xₙ n — t )\\nCreates a new Tuple t of length n similarly to TUPLE, but with 0≤ n≤ 255 taken from the stack."},
            {"INDEXVAR", "x{6F81} — INDEXVAR ( t k — x )\\nSimilar to INDEX k, but with 0≤ k≤ 254 taken from the stack."},
            {"UNTUPLEVAR", "x{6F82} — UNTUPLEVAR ( t n — x₁ … xₙ )\\nSimilar to UNTUPLE n, but with 0≤ n≤ 255 taken from the stack."},
            {"UNPACKFIRSTVAR", "x{6F83} — UNPACKFIRSTVAR ( t n — x₁ … xₙ )\\nSimilar to UNPACKFIRST n, but with 0≤ n≤ 255 taken from the stack."},
            {"EXPLODEVAR", "x{6F84} — EXPLODEVAR ( t n — x₁ … xₘ m )\\nSimilar to EXPLODE n, but with 0≤ n≤ 255 taken from the stack."},
            {"SETINDEXVAR", "x{6F85} — SETINDEXVAR ( t x k — t' )\\nSimilar to SETINDEX k, but with 0≤ k≤ 254 taken from the stack."},
            {"INDEXVARQ", "x{6F86} — INDEXVARQ ( t k — x )\\nSimilar to INDEXQ n, but with 0≤ k≤ 254 taken from the stack."},
            {"SETINDEXVARQ", "x{6F87} — SETINDEXVARQ ( t x k — t' )\\nSimilar to SETINDEXQ k, but with 0≤ k≤ 254 taken from the stack."},
            {"TLEN", "x{6F88} — TLEN ( t — n )\\nReturns the length of a Tuple."},
            {"QTLEN", "x{6F89} — QTLEN ( t — n or -1 )\\nSimilar to TLEN, but returns -1 if t is not a Tuple."},
            {"ISTUPLE", "x{6F8A} — ISTUPLE ( t — ? )\\nReturns -1 or 0 depending on whether t is a Tuple."},
            {"LAST", "x{6F8B} — LAST ( t — x )\\nReturns the last element t_{|t|} of a non-empty Tuple t."},
            {"TPUSH", "x{6F8C} — TPUSH or COMMA ( t x — t' )\\nAppends a value x to a Tuple t=(x₁,…,xₙ), but only if the resulting Tuple t'=(x₁,…,xₙ,x) is of length at most 255. Otherwise throws a type check exception."},
            {"COMMA", "x{6F8C} — TPUSH or COMMA ( t x — t' )\\nAppends a value x to a Tuple t=(x₁,…,xₙ), but only if the resulting Tuple t'=(x₁,…,xₙ,x) is of length at most 255. Otherwise throws a type check exception."},
            {"TPOP", "x{6F8D} — TPOP ( t — t' x )\\nDetaches the last element x=xₙ from a non-empty Tuple t=(x₁,…,xₙ), and returns both the resulting Tuple t'=(x₁,…,x_{n-1}) and the original last element x."},
            {"NULLSWAPIF", "x{6FA0} — NULLSWAPIF ( x — x or ot x )\\nPushes a Null under the topmost Integer x, but only if x≠0."},
            {"NULLSWAPIFNOT", "x{6FA1} — NULLSWAPIFNOT ( x — x or ot x )\\nPushes a Null under the topmost Integer x, but only if x=0. May be used for stack alignment after quiet primitives such as PLDUXQ."},
            {"NULLROTRIF", "x{6FA2} — NULLROTRIF ( x y — x y or ot x y )\\nPushes a Null under the second stack entry from the top, but only if the topmost Integer y is non-zero."},
            {"NULLROTRIFNOT", "x{6FA3} — NULLROTRIFNOT ( x y — x y or ot x y )\\nPushes a Null under the second stack entry from the top, but only if the topmost Integer y is zero. May be used for stack alignment after quiet primitives such as LDUXQ."},
            {"INDEX2", "x{6FBij} — INDEX2 i,j ( t — x )\\nRecovers x=(t_{i+1})_{j+1} for 0≤ i,j≤ 3. Equivalent to INDEX i; INDEX j."},
            {"CADR", "x{6FB4} — CADR ( t — x )\\nRecovers x=(t_2)₁."},
            {"CDDR", "x{6FB5} — CDDR ( t — x )\\nRecovers x=(t_2)_2."},
            {"INDEX3", "x{6FE_ijk} — INDEX3 i,j,k ( t — x )\\nRecovers x= ((t_{i+1})_{j+1} )_{k+1} for 0≤ i,j,k≤3. Equivalent to INDEX2 i,j; INDEX k."},
            {"CADDR", "x{6FD4} — CADDR ( t — x )\\nRecovers x= ((t_2)_2 )₁."},
            {"CDDDR", "x{6FD5} — CDDDR ( t — x )\\nRecovers x= ((t_2)_2 )_2."},
            {"PUSHINT", "x{7i} — PUSHINT x with -5≤ x≤ 10, pushes integer x into the stack; here i equals four lower-order bits of x (i.e., i=x mod 16 ).\nx{71} — ONE or PUSHINT 1.\nx{72} — TWO or PUSHINT 2.\nx{7A} — TEN or PUSHINT 10.\nx{7F} — TRUE or PUSHINT -1.\nx{80xx} — PUSHINT xx with -128≤ xx≤127.\nx{81xxxx} — PUSHINT xxxx with -2^{15}≤ xxxx<2^{15} a signed 16-bit big-endian integer.\nx{81FC18} — PUSHINT -1000.\nx{82lxxx} — PUSHINT xxx, where 5-bit 0≤ l≤30 determines the length n=8l+19 of signed big-endian integer xxx. The total length of this instruction is l+4 bytes or n+13=8l+32 bits.\nx{821005F5E100} — PUSHINT 10^8."},
            {"ZERO", "x{70} — ZERO, FALSE, or PUSHINT 0, pushes a zero."},
            {"ONE", "x{71} — ONE or PUSHINT 1."},
            {"TWO", "x{72} — TWO or PUSHINT 2."},
            {"TEN", "x{7A} — TEN or PUSHINT 10."},
            {"TRUE", "x{7F} — TRUE or PUSHINT -1."},
            {"PUSHPOW2", "x{83xx} — PUSHPOW2 xx+1, (quietly) pushes 2^{xx+1} for 0≤ xx≤255."},
            {"PUSHNAN", "x{83FF} — PUSHNAN, pushes a NaN."},
            {"PUSHPOW2DEC", "x{84xx} — PUSHPOW2DEC xx+1, pushes 2^{xx+1}-1 for 0≤ xx≤ 255."},
            {"PUSHNEGPOW2", "x{85xx} — PUSHNEGPOW2 xx+1, pushes -2^{xx+1} for 0≤ xx≤ 255."},
            {"PUSHREF", "x{88} — PUSHREF, pushes the first reference of cc.code into the stack as a Cell (and removes this reference from the current continuation)."},
            {"PUSHREFSLICE", "x{89} — PUSHREFSLICE, similar to PUSHREF, but converts the cell into a Slice."},
            {"PUSHREFCONT", "x{8A} — PUSHREFCONT, similar to PUSHREFSLICE, but makes a simple ordinary Continuation out of the cell."},
            {"PUSHSLICE", "x{8Bxsss} — PUSHSLICE sss, pushes the (prefix) subslice of cc.code consisting of its first 8x+4 bits and no references (i.e., essentially a bitstring), where 0≤ x≤15. A completion tag is assumed, meaning that all trailing zeroes and the last binary one (if present) are removed from this bitstring. If the original bitstring consists only of zeroes, an empty slice will be pushed.\nx{8B08} — PUSHSLICE x8_, pushes an empty slice (bitstring `' ).\nx{8B04} — PUSHSLICE x4_, pushes bitstring `0'.\nx{8B0C} — PUSHSLICE xC_, pushes bitstring `1'.\nx{8Crxxssss} — PUSHSLICE ssss, pushes the (prefix) subslice of cc.code consisting of its first 1≤ r+1≤ 4 references and up to first 8xx+1 bits of data, with 0≤ xx≤ 31. A completion tag is also assumed.\nx{8Drxxsssss} — PUSHSLICE sssss, pushes the subslice of cc.code consisting of 0≤ r≤ 4 references and up to 8xx+6 bits of data, with 0≤ xx≤ 127. A completion tag is assumed."},
            {"PUSHCONT", "x{8F_rxxcccc} — PUSHCONT cccc, where cccc is the simple ordinary continuation made from the first 0≤ r≤ 3 references and the first 0≤ xx≤ 127 bytes of cc.code.\nx{9xccc} — PUSHCONT ccc, pushes an x -byte continuation for 0≤ x≤ 15."},
            {"ADD", "x{A0} — ADD ( x y — x+y )\\nAdds together two integers."},
            {"SUB", "x{A1} — SUB ( x y — x-y )."},
            {"SUBR", "x{A2} — SUBR ( x y — y-x )\\nEquivalent to SWAP; SUB."},
            {"NEGATE", "x{A3} — NEGATE ( x — -x )\\nEquivalent to MULCONST -1 or to ZERO; SUBR. Notice that it triggers an integer overflow exception if x=-2^{256}."},
            {"INC", "x{A4} — INC ( x — x+1 )\\nEquivalent to ADDCONST 1."},
            {"DEC", "x{A5} — DEC ( x — x-1 )\\nEquivalent to ADDCONST -1."},
            {"ADDCONST", "x{A6cc} — ADDCONST cc ( x — x+cc ), -128≤ cc≤127."},
            {"MULCONST", "x{A7cc} — MULCONST cc ( x — x⋅ cc ), -128≤ cc≤127."},
            {"MUL", "x{A8} — MUL ( x y — xy )."},
            {"DIV", "x{A904} — DIV ( x y — q:= ⌊x/y⌋ )."},
            {"DIVR", "x{A905} — DIVR ( x y — q':= ⌊x/y+½⌋ )."},
            {"DIVC", "x{A906} — DIVC ( x y — q”:= ⌈x/y⌉ )."},
            {"MOD", "x{A908} — MOD ( x y — r )\\nWhere q:= ⌊x/y⌋ , r:=x mod y:=x-yq."},
            {"DIVMOD", "x{A90C} — DIVMOD ( x y — q r )\\nWhere q:= ⌊x/y⌋ , r:=x-yq."},
            {"DIVMODR", "x{A90D} — DIVMODR ( x y — q' r' )\\nWhere q':= ⌊x/y+½⌋ , r':=x-yq'."},
            {"DIVMODC", "x{A90E} — DIVMODC ( x y — q” r” )\\nWhere q”:= ⌈x/y⌉ , r”:=x-yq”."},
            {"MODPOW2", "x{A938tt} — MODPOW2 tt+1: ( x — x mod 2^{tt+1} )."},
            {"MULDIVR", "x{A985} — MULDIVR ( x y z — q' )\\nWhere q'= ⌊xy/z+½⌋ ."},
            {"MULDIVMOD", "x{A98C} — MULDIVMOD ( x y z — q r )\\nWhere q:= ⌊x⋅ y/z⌋ , r:=x⋅ y mod z (same as */MOD in Forth)."},
            {"LSHIFT", "x{AAcc} — LSHIFT cc+1 ( x — x⋅2^{cc+1} ), 0≤ cc≤255.\nx{AA00} — LSHIFT 1, equivalent to MULCONST 2 or to Forth's 2*.\nx{AC} — LSHIFT ( x y — x⋅ 2ʸ ), 0≤ y≤ 1023."},
            {"RSHIFT", "x{ABcc} — RSHIFT cc+1 ( x — ⌊x⋅2^{-cc-1}⌋ ), 0≤ cc≤255.\nx{AD} — RSHIFT ( x y — ⌊x⋅ 2⁻ʸ ⌋ ), 0≤ y≤ 1023."},
            {"POW2", "x{AE} — POW2 ( y — 2ʸ ), 0≤ y≤1023, equivalent to ONE; SWAP; LSHIFT."},
            {"AND", "x{B0} — AND ( x y — x&y )\\nBitwise “and” of two signed integers x and y, sign-extended to infinity."},
            {"OR", "x{B1} — OR ( x y — x∨ y )\\nBitwise “or” of two integers."},
            {"XOR", "x{B2} — XOR ( x y — x⊕ y )\\nBitwise “xor” of two integers."},
            {"NOT", "x{B3} — NOT ( x — x⊕-1=-1-x )\\nBitwise “not” of an integer."},
            {"FITS", "x{B4cc} — FITS cc+1 ( x — x )\\nChecks whether x is a cc+1 -bit signed integer for 0≤ cc≤ 255 (i.e., whether -2^{cc}≤ x<2^{cc} ). If not, either triggers an integer overflow exception, or replaces x with a NaN (quiet version).\nx{B400} — FITS 1 or CHKBOOL ( x — x )\\nChecks whether x is a “boolean value” (i.e., either 0 or -1)."},
            {"CHKBOOL", "x{B400} — FITS 1 or CHKBOOL ( x — x )\\nChecks whether x is a “boolean value” (i.e., either 0 or -1)."},
            {"UFITS", "x{B5cc} — UFITS cc+1 ( x — x )\\nChecks whether x is a cc+1 -bit unsigned integer for 0≤ cc≤ 255 (i.e., whether 0≤ x<2^{cc+1} ).\nx{B500} — UFITS 1 or CHKBIT, checks whether x is a binary digit (i.e., zero or one)."},
            {"CHKBIT", "x{B500} — UFITS 1 or CHKBIT, checks whether x is a binary digit (i.e., zero or one)."},
            {"FITSX", "x{B600} — FITSX ( x c — x )\\nChecks whether x is a c -bit signed integer for 0≤ c≤ 1023."},
            {"UFITSX", "x{B601} — UFITSX ( x c — x )\\nChecks whether x is a c -bit unsigned integer for 0≤ c≤ 1023."},
            {"BITSIZE", "x{B602} — BITSIZE ( x — c )\\nComputes smallest c≥0 such that x fits into a c -bit signed integer ( -2^{c-1}≤ c<2^{c-1} )."},
            {"UBITSIZE", "x{B603} — UBITSIZE ( x — c )\\nComputes smallest c≥0 such that x fits into a c -bit unsigned integer ( 0≤ x<2^c ), or throws a range check exception."},
            {"MIN", "x{B608} — MIN ( x y — x or y )\\nComputes the minimum of two integers x and y."},
            {"MAX", "x{B609} — MAX ( x y — x or y )\\nComputes the maximum of two integers x and y."},
            {"MINMAX", "x{B60A} — MINMAX or INTSORT2 ( x y — x y or y x )\\nSorts two integers. Quiet version of this operation returns two NaN s if any of the arguments are NaN s."},
            {"INTSORT2", "x{B60A} — MINMAX or INTSORT2 ( x y — x y or y x )\\nSorts two integers. Quiet version of this operation returns two NaN s if any of the arguments are NaN s."},
            {"ABS", "x{B60B} — ABS ( x — |x| )\\nComputes the absolute value of an integer x."},
            {"QUIET", "x{B7xx} — QUIET prefix, transforming any arithmetic operation into its “quiet” variant, indicated by prefixing a Q to its mnemonic. Such operations return NaN s instead of throwing integer overflow exceptions if the results do not fit in it Integer s, or if one of their arguments is a NaN. Notice that this does not extend to shift amounts and other parameters that must be within a small range (e.g., 0—1023). Also notice that this does not disable type-checking exceptions if a value of a type other than it Integer is supplied."},
            {"QADD", "x{B7A0} — QADD ( x y — x+y )\\nAlways works if x and y are it Integer s, but returns a NaN if the addition cannot be performed."},
            {"QDIV", "x{B7A904} — QDIV ( x y — ⌊x/y⌋ )\\nReturns a NaN if y=0, or if y=-1 and x=-2^{256}, or if either of x or y is a NaN."},
            {"QAND", "x{B7B0} — QAND ( x y — x&y )\\nBitwise “and” (similar to AND ), but returns a NaN if either x or y is a NaN instead of throwing an integer overflow exception. However, if one of the arguments is zero, and the other is a NaN, the result is zero."},
            {"QOR", "x{B7B1} — QOR ( x y — x∨ y )\\nBitwise “or”. If x=-1 or y=-1, the result is always -1, even if the other argument is a NaN."},
            {"QUFITS", "x{B7B507} — QUFITS 8 ( x — x' )\\nChecks whether x is an unsigned byte (i.e., whether 0≤ x<2^8 ), and replaces x with a NaN if this is not the case; leaves x intact otherwise (i.e., if x is an unsigned byte)."},
            {"SGN", "x{B8} — SGN ( x — sgn(x) ), computes the sign of an integer x: -1 if x<0, 0 if x=0, 1 if x>0."},
            {"LESS", "x{B9} — LESS ( x y — x<y )\\nReturns -1 if x<y, 0 otherwise."},
            {"EQUAL", "x{BA} — EQUAL ( x y — x=y )\\nReturns -1 if x=y, 0 otherwise."},
            {"LEQ", "x{BB} — LEQ ( x y — x≤ y )."},
            {"GREATER", "x{BC} — GREATER ( x y — x>y )."},
            {"NEQ", "x{BD} — NEQ ( x y — x≠ y )\\nEquivalent to EQUAL; NOT."},
            {"GEQ", "x{BE} — GEQ ( x y — x≥ y )\\nEquivalent to LESS; NOT."},
            {"CMP", "x{BF} — CMP ( x y — sgn(x-y) ), computes the sign of x-y: -1 if x<y, 0 if x=y, 1 if x>y. No integer overflow can occur here unless x or y is a NaN."},
            {"EQINT", "x{C0yy} — EQINT yy ( x — x=yy ) for -2^7≤ yy<2^7."},
            {"ISZERO", "x{C000} — ISZERO, checks whether an integer is zero. Corresponds to Forth's 0=."},
            {"LESSINT", "x{C1yy} — LESSINT yy ( x — x<yy ) for -2^7≤ yy<2^7."},
            {"ISNEG", "x{C100} — ISNEG, checks whether an integer is negative. Corresponds to Forth's 0<."},
            {"ISNPOS", "x{C101} — ISNPOS, checks whether an integer is non-positive."},
            {"GTINT", "x{C2yy} — GTINT yy ( x — x>yy ) for -2^7≤ yy<2^7."},
            {"ISPOS", "x{C200} — ISPOS, checks whether an integer is positive. Corresponds to Forth's 0>."},
            {"ISNNEG", "x{C2FF} — ISNNEG, checks whether an integer is non-negative."},
            {"NEQINT", "x{C3yy} — NEQINT yy ( x — x≠ yy ) for -2^7≤ yy<2^7."},
            {"ISNAN", "x{C4} — ISNAN ( x — x=NaN )\\nChecks whether x is a NaN."},
            {"CHKNAN", "x{C5} — CHKNAN ( x — x )\\nThrows an arithmetic overflow exception if x is a NaN."},
            {"SEMPTY", "x{C700} — SEMPTY ( s — s=∅ )\\nChecks whether a Slice s is empty (i.e., contains no bits of data and no cell references)."},
            {"SDEMPTY", "x{C701} — SDEMPTY ( s — s≈∅ )\\nChecks whether Slice s has no bits of data."},
            {"SREMPTY", "x{C702} — SREMPTY ( s — r(s)=0 ), checks whether Slice s has no references."},
            {"SDFIRST", "x{C703} — SDFIRST ( s — s₀=1 )\\nChecks whether the first bit of Slice s is a one."},
            {"SDLEXCMP", "x{C704} — SDLEXCMP ( s s' — c )\\nCompares the data of s lexicographically with the data of s', returning -1, 0, or 1 depending on the result."},
            {"SDEQ", "x{C705} — SDEQ ( s s' — s≈ s' )\\nChecks whether the data parts of s and s' coincide, equivalent to SDLEXCMP; ISZERO."},
            {"SDPFX", "x{C708} — SDPFX ( s s' — ? )\\nChecks whether s is a prefix of s'."},
            {"SDPFXREV", "x{C709} — SDPFXREV ( s s' — ? )\\nChecks whether s' is a prefix of s, equivalent to SWAP; SDPFX."},
            {"SDPPFX", "x{C70A} — SDPPFX ( s s' — ? )\\nChecks whether s is a proper prefix of s' (i.e., a prefix distinct from s' )."},
            {"SDPPFXREV", "x{C70B} — SDPPFXREV ( s s' — ? )\\nChecks whether s' is a proper prefix of s."},
            {"SDSFX", "x{C70C} — SDSFX ( s s' — ? )\\nChecks whether s is a suffix of s'."},
            {"SDSFXREV", "x{C70D} — SDSFXREV ( s s' — ? )\\nChecks whether s' is a suffix of s."},
            {"SDPSFX", "x{C70E} — SDPSFX ( s s' — ? )\\nChecks whether s is a proper suffix of s'."},
            {"SDPSFXREV", "x{C70F} — SDPSFXREV ( s s' — ? )\\nChecks whether s' is a proper suffix of s."},
            {"SDCNTLEAD0", "x{C710} — SDCNTLEAD0 ( s — n )\\nReturns the number of leading zeroes in s."},
            {"SDCNTLEAD1", "x{C711} — SDCNTLEAD1 ( s — n )\\nReturns the number of leading ones in s."},
            {"SDCNTTRAIL0", "x{C712} — SDCNTTRAIL0 ( s — n )\\nReturns the number of trailing zeroes in s."},
            {"SDCNTTRAIL1", "x{C713} — SDCNTTRAIL1 ( s — n )\\nReturns the number of trailing ones in s."},
            {"NEWC", "x{C8} — NEWC ( — b )\\nCreates a new empty Builder."},
            {"ENDC", "x{C9} — ENDC ( b — c )\\nConverts a Builder into an ordinary Cell."},
            {"STI", "x{CAcc} — STI cc+1 ( x b — b' )\\nStores a signed cc+1 -bit integer x into Builder b for 0≤ cc≤ 255, throws a range check exception if x does not fit into cc+1 bits."},
            {"STU", "x{CBcc} — STU cc+1 ( x b — b' )\\nStores an unsigned cc+1 -bit integer x into Builder b. In all other respects it is similar to STI."},
            {"STREF", "x{CC} — STREF ( c b — b' )\\nStores a reference to Cell c into Builder b."},
            {"STBREFR", "x{CD} — STBREFR or ENDCST ( b b” — b )\\nEquivalent to ENDC; SWAP; STREF.\nx{CF15} — STBREFR ( b b' — b” )\\nA longer encoding of STBREFR."},
            {"ENDCST", "x{CD} — STBREFR or ENDCST ( b b” — b )\\nEquivalent to ENDC; SWAP; STREF."},
            {"STSLICE", "x{CE} — STSLICE ( s b — b' )\\nStores Slice s into Builder b."},
            {"STIX", "x{CF00} — STIX ( x b l — b' )\\nStores a signed l -bit integer x into b for 0≤ l≤ 257."},
            {"STUX", "x{CF01} — STUX ( x b l — b' )\\nStores an unsigned l -bit integer x into b for 0≤ l≤ 256."},
            {"STIXR", "x{CF02} — STIXR ( b x l — b' )\\nSimilar to STIX, but with arguments in a different order."},
            {"STUXR", "x{CF03} — STUXR ( b x l — b' )\\nSimilar to STUX, but with arguments in a different order."},
            {"STIXQ", "x{CF04} — STIXQ ( x b l — x b f or b' 0 )\\nA quiet version of STIX. If there is no space in b, sets b'=b and f=-1. If x does not fit into l bits, sets b'=b and f=1. If the operation succeeds, b' is the new Builder and f=0. However, 0≤ l≤ 257, with a range check exception if this is not so."},
            {"STUXQ", "x{CF05} — STUXQ ( x b l — b' f )."},
            {"STIXRQ", "x{CF06} — STIXRQ ( b x l — b x f or b' 0 )."},
            {"STUXRQ", "x{CF07} — STUXRQ ( b x l — b x f or b' 0 )."},
            {"STIR", "x{CF0Acc} — STIR cc+1 ( b x — b' )\\nEquivalent to SWAP; STI cc+1."},
            {"STUR", "x{CF0Bcc} — STUR cc+1 ( b x — b' )\\nEquivalent to SWAP; STU cc+1."},
            {"STIQ", "x{CF0Ccc} — STIQ cc+1 ( x b — x b f or b' 0 )."},
            {"STUQ", "x{CF0Dcc} — STUQ cc+1 ( x b — x b f or b' 0 )."},
            {"STIRQ", "x{CF0Ecc} — STIRQ cc+1 ( b x — b x f or b' 0 )."},
            {"STURQ", "x{CF0Fcc} — STURQ cc+1 ( b x — b x f or b' 0 )."},
            {"STBREF", "x{CF11} — STBREF ( b' b — b” )\\nEquivalent to SWAP; STBREFREV."},
            {"STB", "x{CF13} — STB ( b' b — b” )\\nAppends all data from Builder b' to Builder b."},
            {"STREFR", "x{CF14} — STREFR ( b c — b' )."},
            {"STSLICER", "x{CF16} — STSLICER ( b s — b' )."},
            {"STBR", "x{CF17} — STBR ( b b' — b” )\\nConcatenates two Builder s, equivalent to SWAP; STB."},
            {"STREFQ", "x{CF18} — STREFQ ( c b — c b -1 or b' 0 )."},
            {"STBREFQ", "x{CF19} — STBREFQ ( b' b — b' b -1 or b” 0 )."},
            {"STSLICEQ", "x{CF1A} — STSLICEQ ( s b — s b -1 or b' 0 )."},
            {"STBQ", "x{CF1B} — STBQ ( b' b — b' b -1 or b” 0 )."},
            {"STREFRQ", "x{CF1C} — STREFRQ ( b c — b c -1 or b' 0 )."},
            {"STBREFRQ", "x{CF1D} — STBREFRQ ( b b' — b b' -1 or b” 0 )."},
            {"STSLICERQ", "x{CF1E} — STSLICERQ ( b s — b s -1 or b” 0 )."},
            {"STBRQ", "x{CF1F} — STBRQ ( b b' — b b' -1 or b” 0 )."},
            {"STREFCONST", "x{CF20} — STREFCONST, equivalent to PUSHREF; STREFR."},
            {"STREF2CONST", "x{CF21} — STREF2CONST, equivalent to STREFCONST; STREFCONST."},
            {"ENDXC", "x{CF23} — ENDXC ( b x — c )\\nIf x≠0, creates a special or exotic cell (cf. sp:exotic.cells ) from Builder b. The type of the exotic cell must be stored in the first 8 bits of b. If x=0, it is equivalent to ENDC. Otherwise some validity checks on the data and references of b are performed before creating the exotic cell."},
            {"STILE4", "x{CF28} — STILE4 ( x b — b' )\\nStores a little-endian signed 32-bit integer."},
            {"STULE4", "x{CF29} — STULE4 ( x b — b' )\\nStores a little-endian unsigned 32-bit integer."},
            {"STILE8", "x{CF2A} — STILE8 ( x b — b' )\\nStores a little-endian signed 64-bit integer."},
            {"STULE8", "x{CF2B} — STULE8 ( x b — b' )\\nStores a little-endian unsigned 64-bit integer."},
            {"BBITS", "x{CF31} — BBITS ( b — x )\\nReturns the number of data bits already stored in Builder b."},
            {"BREFS", "x{CF32} — BREFS ( b — y )\\nReturns the number of cell references already stored in b."},
            {"BBITREFS", "x{CF33} — BBITREFS ( b — x y )\\nReturns the numbers of both data bits and cell references in b."},
            {"BREMBITS", "x{CF35} — BREMBITS ( b — x' )\\nReturns the number of data bits that can still be stored in b."},
            {"BREMREFS", "x{CF36} — BREMREFS ( b — y' )."},
            {"BREMBITREFS", "x{CF37} — BREMBITREFS ( b — x' y' )."},
            {"BCHKBITS", "x{CF38cc} — BCHKBITS cc+1 ( b —)\\nChecks whether cc+1 bits can be stored into b, where 0≤ cc≤ 255.\nx{CF39} — BCHKBITS ( b x — )\\nChecks whether x bits can be stored into b, 0≤ x≤ 1023. If there is no space for x more bits in b, or if x is not within the range 0…1023, throws an exception."},
            {"BCHKREFS", "x{CF3A} — BCHKREFS ( b y — )\\nChecks whether y references can be stored into b, 0≤ y≤ 7."},
            {"BCHKBITREFS", "x{CF3B} — BCHKBITREFS ( b x y — )\\nChecks whether x bits and y references can be stored into b, 0≤ x≤ 1023, 0≤ y≤ 7."},
            {"BCHKBITSQ", "x{CF3Ccc} — BCHKBITSQ cc+1 ( b — ? )\\nChecks whether cc+1 bits can be stored into b, where 0≤ cc≤ 255.\nx{CF3D} — BCHKBITSQ ( b x — ? )\\nChecks whether x bits can be stored into b, 0≤ x≤ 1023."},
            {"BCHKREFSQ", "x{CF3E} — BCHKREFSQ ( b y — ? )\\nChecks whether y references can be stored into b, 0≤ y≤ 7."},
            {"BCHKBITREFSQ", "x{CF3F} — BCHKBITREFSQ ( b x y — ? )\\nChecks whether x bits and y references can be stored into b, 0≤ x≤ 1023, 0≤ y≤ 7."},
            {"STZEROES", "x{CF40} — STZEROES ( b n — b' )\\nStores n binary zeroes into Builder b."},
            {"STONES", "x{CF41} — STONES ( b n — b' )\\nStores n binary ones into Builder b."},
            {"STSAME", "x{CF42} — STSAME ( b n x — b' )\\nStores n binary x es ( 0≤ x≤1 ) into Builder b."},
            {"STSLICECONST", "x{CFC0_xysss} — STSLICECONST sss ( b — b' )\\nStores a constant subslice sss consisting of 0≤ x≤ 3 references and up to 8y+1 data bits, with 0≤ y≤ 7. Completion bit is assumed.\nx{CF81} — STSLICECONST `0' or STZERO ( b — b' )\\nStores one binary zero.\nx{CF83} — STSLICECONST `1' or STONE ( b — b' )\\nStores one binary one."},
            {"STZERO", "x{CF81} — STSLICECONST `0' or STZERO ( b — b' )\\nStores one binary zero."},
            {"STONE", "x{CF83} — STSLICECONST `1' or STONE ( b — b' )\\nStores one binary one."},
            {"STREF3CONST", "x{CFE2} — STREF3CONST."},
            {"CTOS", "x{D0} — CTOS ( c — s )\\nConverts a Cell into a Slice. Notice that c must be either an ordinary cell, or an exotic cell (cf. sp:exotic.cells ) which is automatically loaded to yield an ordinary cell c', converted into a Slice afterwards."},
            {"ENDS", "x{D1} — ENDS ( s — )\\nRemoves a Slice s from the stack, and throws an exception if it is not empty."},
            {"LDI", "x{D2cc} — LDI cc+1 ( s — x s' )\\nLoads (i.e., parses) a signed cc+1 -bit integer x from Slice s, and returns the remainder of s as s'.\nx{D708cc} — LDI cc+1 ( s — x s' )\\nA longer encoding for LDI."},
            {"LDU", "x{D3cc} — LDU cc+1 ( s — x s' )\\nLoads an unsigned cc+1 -bit integer x from Slice s.\nx{D709cc} — LDU cc+1 ( s — x s' )\\nA longer encoding for LDU."},
            {"LDREF", "x{D4} — LDREF ( s — c s' )\\nLoads a cell reference c from s."},
            {"LDREFRTOS", "x{D5} — LDREFRTOS ( s — s' s” )\\nEquivalent to LDREF; SWAP; CTOS."},
            {"LDSLICE", "x{D6cc} — LDSLICE cc+1 ( s — s” s' )\\nCuts the next cc+1 bits of s into a separate Slice s”.\nx{D71Ccc} — LDSLICE cc+1 ( s — s” s' )\\nA longer encoding for LDSLICE."},
            {"LDIX", "x{D700} — LDIX ( s l — x s' )\\nLoads a signed l -bit ( 0≤ l≤ 257 ) integer x from Slice s, and returns the remainder of s as s'."},
            {"LDUX", "x{D701} — LDUX ( s l — x s' )\\nLoads an unsigned l -bit integer x from (the first l bits of) s, with 0≤ l≤ 256."},
            {"PLDIX", "x{D702} — PLDIX ( s l — x )\\nPreloads a signed l -bit integer from Slice s, for 0≤ l≤ 257."},
            {"PLDUX", "x{D703} — PLDUX ( s l — x )\\nPreloads an unsigned l -bit integer from s, for 0≤ l≤ 256."},
            {"LDIXQ", "x{D704} — LDIXQ ( s l — x s' -1 or s 0 )\\nQuiet version of LDIX: loads a signed l -bit integer from s similarly to LDIX, but returns a success flag, equal to -1 on success or to 0 on failure (if s does not have l bits), instead of throwing a cell underflow exception."},
            {"LDUXQ", "x{D705} — LDUXQ ( s l — x s' -1 or s 0 )\\nQuiet version of LDUX."},
            {"PLDIXQ", "x{D706} — PLDIXQ ( s l — x -1 or 0 )\\nQuiet version of PLDIX."},
            {"PLDUXQ", "x{D707} — PLDUXQ ( s l — x -1 or 0 )\\nQuiet version of PLDUX."},
            {"PLDI", "x{D70Acc} — PLDI cc+1 ( s — x )\\nPreloads a signed cc+1 -bit integer from Slice s."},
            {"PLDU", "x{D70Bcc} — PLDU cc+1 ( s — x )\\nPreloads an unsigned cc+1 -bit integer from s."},
            {"LDIQ", "x{D70Ccc} — LDIQ cc+1 ( s — x s' -1 or s 0 )\\nA quiet version of LDI."},
            {"LDUQ", "x{D70Dcc} — LDUQ cc+1 ( s — x s' -1 or s 0 )\\nA quiet version of LDU."},
            {"PLDIQ", "x{D70Ecc} — PLDIQ cc+1 ( s — x -1 or 0 )\\nA quiet version of PLDI."},
            {"PLDUQ", "x{D70Fcc} — PLDUQ cc+1 ( s — x -1 or 0 )\\nA quiet version of PLDU."},
            {"PLDUZ", "x{D714_c} — PLDUZ 32(c+1) ( s — s x ), preloads the first 32(c+1) bits of Slice s into an unsigned integer x, for 0≤ c≤ 7. If s is shorter than necessary, missing bits are assumed to be zero. This operation is intended to be used along with IFBITJMP and similar instructions."},
            {"LDSLICEX", "x{D718} — LDSLICEX ( s l — s” s' )\\nLoads the first 0≤ l≤ 1023 bits from Slice s into a separate Slice s”, returning the remainder of s as s'."},
            {"PLDSLICEX", "x{D719} — PLDSLICEX ( s l — s” )\\nReturns the first 0≤ l≤ 1023 bits of s as s”."},
            {"LDSLICEXQ", "x{D71A} — LDSLICEXQ ( s l — s” s' -1 or s 0 )\\nA quiet version of LDSLICEX."},
            {"PLDSLICEXQ", "x{D71B} — PLDSLICEXQ ( s l — s' -1 or 0 )\\nA quiet version of LDSLICEXQ."},
            {"PLDSLICE", "x{D71Dcc} — PLDSLICE cc+1 ( s — s” )\\nReturns the first 0<cc+1≤ 256 bits of s as s”."},
            {"LDSLICEQ", "x{D71Ecc} — LDSLICEQ cc+1 ( s — s” s' -1 or s 0 )\\nA quiet version of LDSLICE."},
            {"PLDSLICEQ", "x{D71Fcc} — PLDSLICEQ cc+1 ( s — s” -1 or 0 )\\nA quiet version of PLDSLICE."},
            {"SDCUTFIRST", "x{D720} — SDCUTFIRST ( s l — s' )\\nReturns the first 0≤ l≤ 1023 bits of s. It is equivalent to PLDSLICEX."},
            {"SDSKIPFIRST", "x{D721} — SDSKIPFIRST ( s l — s' )\\nReturns all but the first 0≤ l≤ 1023 bits of s. It is equivalent to LDSLICEX; NIP."},
            {"SDCUTLAST", "x{D722} — SDCUTLAST ( s l — s' )\\nReturns the last 0≤ l≤ 1023 bits of s."},
            {"SDSKIPLAST", "x{D723} — SDSKIPLAST ( s l — s' )\\nReturns all but the last 0≤ l≤ 1023 bits of s."},
            {"SDSUBSTR", "x{D724} — SDSUBSTR ( s l l' — s' )\\nReturns 0≤ l'≤ 1023 bits of s starting from offset 0≤ l≤ 1023, thus extracting a bit substring out of the data of s."},
            {"SDBEGINSX", "x{D726} — SDBEGINSX ( s s' — s” )\\nChecks whether s begins with (the data bits of) s', and removes s' from s on success. On failure throws a cell deserialization exception. Primitive SDPFXREV can be considered a quiet version of SDBEGINSX."},
            {"SDBEGINSXQ", "x{D727} — SDBEGINSXQ ( s s' — s” -1 or s 0 )\\nA quiet version of SDBEGINSX."},
            {"SDBEGINS", "x{D72A_xsss} — SDBEGINS ( s — s” )\\nChecks whether s begins with constant bitstring sss of length 8x+3 (with continuation bit assumed), where 0≤ x≤ 127, and removes sss from s on success.\nx{D72802} — SDBEGINS `0' ( s — s” )\\nChecks whether s begins with a binary zero.\nx{D72806} — SDBEGINS `1' ( s — s” )\\nChecks whether s begins with a binary one."},
            {"SDBEGINSQ", "x{D72E_xsss} — SDBEGINSQ ( s — s” -1 or s 0 )\\nA quiet version of SDBEGINS."},
            {"SCUTFIRST", "x{D730} — SCUTFIRST ( s l r — s' )\\nReturns the first 0≤ l≤ 1023 bits and first 0≤ r≤ 4 references of s."},
            {"SSKIPFIRST", "x{D731} — SSKIPFIRST ( s l r — s' )."},
            {"SCUTLAST", "x{D732} — SCUTLAST ( s l r — s' )\\nReturns the last 0≤ l≤ 1023 data bits and last 0≤ r≤ 4 references of s."},
            {"SSKIPLAST", "x{D733} — SSKIPLAST ( s l r — s' )."},
            {"SUBSLICE", "x{D734} — SUBSLICE ( s l r l' r' — s' )\\nReturns 0≤ l'≤ 1023 bits and 0≤ r'≤ 4 references from Slice s, after skipping the first 0≤ l≤ 1023 bits and first 0≤ r≤ 4 references."},
            {"SPLIT", "x{D736} — SPLIT ( s l r — s' s” )\\nSplits the first 0≤ l≤ 1023 data bits and first 0≤ r≤ 4 references from s into s', returning the remainder of s as s”."},
            {"SPLITQ", "x{D737} — SPLITQ ( s l r — s' s” -1 or s 0 )\\nA quiet version of SPLIT."},
            {"XCTOS", "x{D739} — XCTOS ( c — s ? )\\nTransforms an ordinary or exotic cell into a Slice, as if it were an ordinary cell. A flag is returned indicating whether c is exotic. If that be the case, its type can later be deserialized from the first eight bits of s."},
            {"XLOAD", "x{D73A} — XLOAD ( c — c' )\\nLoads an exotic cell c and returns an ordinary cell c'. If c is already ordinary, does nothing. If c cannot be loaded, throws an exception."},
            {"XLOADQ", "x{D73B} — XLOADQ ( c — c' -1 or c 0 )\\nLoads an exotic cell c as XLOAD, but returns 0 on failure."},
            {"SCHKBITS", "x{D741} — SCHKBITS ( s l — )\\nChecks whether there are at least l data bits in Slice s. If this is not the case, throws a cell deserialisation (i.e., cell underflow) exception."},
            {"SCHKREFS", "x{D742} — SCHKREFS ( s r — )\\nChecks whether there are at least r references in Slice s."},
            {"SCHKBITREFS", "x{D743} — SCHKBITREFS ( s l r — )\\nChecks whether there are at least l data bits and r references in Slice s."},
            {"SCHKBITSQ", "x{D745} — SCHKBITSQ ( s l — ? )\\nChecks whether there are at least l data bits in Slice s."},
            {"SCHKREFSQ", "x{D746} — SCHKREFSQ ( s r — ? )\\nChecks whether there are at least r references in Slice s."},
            {"SCHKBITREFSQ", "x{D747} — SCHKBITREFSQ ( s l r — ? )\\nChecks whether there are at least l data bits and r references in Slice s."},
            {"PLDREFVAR", "x{D748} — PLDREFVAR ( s n — c )\\nReturns the n -th cell reference of Slice s for 0≤ n≤ 3."},
            {"SBITS", "x{D749} — SBITS ( s — l )\\nReturns the number of data bits in Slice s."},
            {"SREFS", "x{D74A} — SREFS ( s — r )\\nReturns the number of references in Slice s."},
            {"SBITREFS", "x{D74B} — SBITREFS ( s — l r )\\nReturns both the number of data bits and the number of references in s."},
            {"PLDREFIDX", "x{D74E}ₙ — PLDREFIDX n ( s — c )\\nReturns the n -th cell reference of Slice s, where 0≤ n≤ 3."},
            {"PLDREF", "x{D74C} — PLDREF ( s — c )\\nPreloads the first cell reference of a Slice."},
            {"LDILE4", "x{D750} — LDILE4 ( s — x s' )\\nLoads a little-endian signed 32-bit integer."},
            {"LDULE4", "x{D751} — LDULE4 ( s — x s' )\\nLoads a little-endian unsigned 32-bit integer."},
            {"LDILE8", "x{D752} — LDILE8 ( s — x s' )\\nLoads a little-endian signed 64-bit integer."},
            {"LDULE8", "x{D753} — LDULE8 ( s — x s' )\\nLoads a little-endian unsigned 64-bit integer."},
            {"PLDILE4", "x{D754} — PLDILE4 ( s — x )\\nPreloads a little-endian signed 32-bit integer."},
            {"PLDULE4", "x{D755} — PLDULE4 ( s — x )\\nPreloads a little-endian unsigned 32-bit integer."},
            {"PLDILE8", "x{D756} — PLDILE8 ( s — x )\\nPreloads a little-endian signed 64-bit integer."},
            {"PLDULE8", "x{D757} — PLDULE8 ( s — x )\\nPreloads a little-endian unsigned 64-bit integer."},
            {"LDILE4Q", "x{D758} — LDILE4Q ( s — x s' -1 or s 0 )\\nQuietly loads a little-endian signed 32-bit integer."},
            {"LDULE4Q", "x{D759} — LDULE4Q ( s — x s' -1 or s 0 )\\nQuietly loads a little-endian unsigned 32-bit integer."},
            {"LDILE8Q", "x{D75A} — LDILE8Q ( s — x s' -1 or s 0 )\\nQuietly loads a little-endian signed 64-bit integer."},
            {"LDULE8Q", "x{D75B} — LDULE8Q ( s — x s' -1 or s 0 )\\nQuietly loads a little-endian unsigned 64-bit integer."},
            {"PLDILE4Q", "x{D75C} — PLDILE4Q ( s — x -1 or 0 )\\nQuietly preloads a little-endian signed 32-bit integer."},
            {"PLDULE4Q", "x{D75D} — PLDULE4Q ( s — x -1 or 0 )\\nQuietly preloads a little-endian unsigned 32-bit integer."},
            {"PLDILE8Q", "x{D75E} — PLDILE8Q ( s — x -1 or 0 )\\nQuietly preloads a little-endian signed 64-bit integer."},
            {"PLDULE8Q", "x{D75F} — PLDULE8Q ( s — x -1 or 0 )\\nQuietly preloads a little-endian unsigned 64-bit integer."},
            {"LDZEROES", "x{D760} — LDZEROES ( s — n s' )\\nReturns the count n of leading zero bits in s, and removes these bits from s."},
            {"LDONES", "x{D761} — LDONES ( s — n s' )\\nReturns the count n of leading one bits in s, and removes these bits from s."},
            {"LDSAME", "x{D762} — LDSAME ( s x — n s' )\\nReturns the count n of leading bits equal to 0≤ x≤ 1 in s, and removes these bits from s."},
            {"EXECUTE", "x{D8} — EXECUTE or CALLX ( c — )\\nCalls or executes continuation c (i.e., cc🡐 c◦₀cc )."},
            {"CALLX", "x{D8} — EXECUTE or CALLX ( c — )\\nCalls or executes continuation c (i.e., cc🡐 c◦₀cc )."},
            {"JMPX", "x{D9} — JMPX ( c — )\\nJumps, or transfers control, to continuation c (i.e., cc🡐 c◦₀c0, or rather cc🡐(c◦₀c0)◦₁c1 ). The remainder of the previous current continuation cc is discarded."},
            {"CALLXARGS", "x{DApr} — CALLXARGS p,r ( c — )\\nCalls continuation c with p parameters and expecting r return values, 0≤ p≤15, 0≤ r≤ 15.\nx{DB0p} — CALLXARGS p,-1 ( c — )\\nCalls continuation c with 0≤ p≤15 parameters, expecting an arbitrary number of return values."},
            {"JMPXARGS", "x{DB1p} — JMPXARGS p ( c — )\\nJumps to continuation c, passing only the top 0≤ p≤ 15 values from the current stack to it (the remainder of the current stack is discarded)."},
            {"RETARGS", "x{DB2r} — RETARGS r, returns to c0, with 0≤ r≤ 15 return values taken from the current stack."},
            {"RET", "x{DB30} — RET or RETTRUE, returns to the continuation at c0 (i.e., performs cc🡐c0 ). The remainder of the current continuation cc is discarded. Approximately equivalent to PUSH c0; JMPX."},
            {"RETTRUE", "x{DB30} — RET or RETTRUE, returns to the continuation at c0 (i.e., performs cc🡐c0 ). The remainder of the current continuation cc is discarded. Approximately equivalent to PUSH c0; JMPX."},
            {"RETALT", "x{DB31} — RETALT or RETFALSE, returns to the continuation at c1 (i.e., cc🡐c1 ). Approximately equivalent to PUSH c1; JMPX."},
            {"RETFALSE", "x{DB31} — RETALT or RETFALSE, returns to the continuation at c1 (i.e., cc🡐c1 ). Approximately equivalent to PUSH c1; JMPX."},
            {"BRANCH", "x{DB32} — BRANCH or RETBOOL ( f — )\\nPerforms RETTRUE if integer f≠ 0, or RETFALSE if f=0."},
            {"RETBOOL", "x{DB32} — BRANCH or RETBOOL ( f — )\\nPerforms RETTRUE if integer f≠ 0, or RETFALSE if f=0."},
            {"CALLCC", "x{DB34} — CALLCC ( c — )\\nCall with current continuation, transfers control to c, pushing the old value of cc into c 's stack (instead of discarding it or writing it into new c0 ).\nx{F1A}ₙ — PREPARE n or PREPAREDICT n ( — n c )\\nEquivalent to PUSHINT n; PUSH c3, for 0≤ n<2^{14}. In this way, CALL n is approximately equivalent to PREPARE n; EXECUTE, and JMP n is approximately equivalent to PREPARE n; JMPX. One might use, for instance, CALLARGS or CALLCC instead of EXECUTE here."},
            {"JMPXDATA", "x{DB35} — JMPXDATA ( c — )\\nSimilar to CALLCC, but the remainder of the current continuation (the old value of cc ) is converted into a Slice before pushing it into the stack of c."},
            {"CALLCCARGS", "x{DB36pr} — CALLCCARGS p,r ( c — )\\nSimilar to CALLXARGS, but pushes the old value of cc (along with the top 0≤ p≤ 15 values from the original stack) into the stack of newly-invoked continuation c, setting cc.nargs to -1≤ r≤ 14."},
            {"CALLXVARARGS", "x{DB38} — CALLXVARARGS ( c p r — )\\nSimilar to CALLXARGS, but takes -1≤ p,r≤254 from the stack. The next three operations also take p and r from the stack, both in the range -1…254."},
            {"RETVARARGS", "x{DB39} — RETVARARGS ( p r — )\\nSimilar to RETARGS."},
            {"JMPXVARARGS", "x{DB3A} — JMPXVARARGS ( c p r — )\\nSimilar to JMPXARGS."},
            {"CALLCCVARARGS", "x{DB3B} — CALLCCVARARGS ( c p r — )\\nSimilar to CALLCCARGS."},
            {"CALLREF", "x{DB3C} — CALLREF, equivalent to PUSHREFCONT; CALLX."},
            {"JMPREF", "x{DB3D} — JMPREF, equivalent to PUSHREFCONT; JMPX."},
            {"JMPREFDATA", "x{DB3E} — JMPREFDATA, equivalent to PUSHREFCONT; JMPXDATA."},
            {"RETDATA", "x{DB3F} — RETDATA, equivalent to PUSH c0; JMPXDATA. In this way, the remainder of the current continuation is converted into a Slice and returned to the caller."},
            {"IFRET", "x{DC} — IFRET ( f — )\\nPerforms a RET, but only if integer f is non-zero. If f is a NaN, throws an integer overflow exception."},
            {"IFNOTRET", "x{DD} — IFNOTRET ( f — )\\nPerforms a RET, but only if integer f is zero."},
            {"IF", "x{DE} — IF ( f c — )\\nPerforms EXECUTE for c (i.e., executes c ), but only if integer f is non-zero. Otherwise simply discards both values."},
            {"IFNOT", "x{DF} — IFNOT ( f c — )\\nExecutes continuation c, but only if integer f is zero. Otherwise simply discards both values."},
            {"IFJMP", "x{E0} — IFJMP ( f c — )\\nJumps to c (similarly to JMPX ), but only if f is non-zero."},
            {"IFNOTJMP", "x{E1} — IFNOTJMP ( f c — )\\nJumps to c (similarly to JMPX ), but only if f is zero."},
            {"IFELSE", "x{E2} — IFELSE ( f c c' — )\\nIf integer f is non-zero, executes c, otherwise executes c'. Equivalent to CONDSELCHK; EXECUTE."},
            {"IFREF", "x{E300} — IFREF ( f — )\\nEquivalent to PUSHREFCONT; IF."},
            {"IFNOTREF", "x{E301} — IFNOTREF ( f — )\\nEquivalent to PUSHREFCONT; IFNOT."},
            {"IFJMPREF", "x{E302} — IFJMPREF ( f — )\\nEquivalent to PUSHREFCONT; IFJMP."},
            {"IFNOTJMPREF", "x{E303} — IFNOTJMPREF ( f — )\\nEquivalent to PUSHREFCONT; IFNOTJMP."},
            {"CONDSEL", "x{E304} — CONDSEL ( f x y — x or y )\\nIf integer f is non-zero, returns x, otherwise returns y. Notice that no type checks are performed on x and y; as such, it is more like a conditional stack operation. Roughly equivalent to ROT; ISZERO; INC; ROLLX; NIP."},
            {"CONDSELCHK", "x{E305} — CONDSELCHK ( f x y — x or y )\\nSame as CONDSEL, but first checks whether x and y have the same type."},
            {"IFRETALT", "x{E308} — IFRETALT ( f —)\\nPerforms RETALT if integer f≠0."},
            {"IFNOTRETALT", "x{E309} — IFNOTRETALT ( f —)\\nPerforms RETALT if integer f=0."},
            {"IFBITJMP", "x{E39}ₙ — IFBITJMP n ( x c — x )\\nChecks whether bit 0≤ n≤ 31 is set in integer x, and if so, performs JMPX to continuation c. Value x is left in the stack."},
            {"IFNBITJMP", "x{E3B}ₙ — IFNBITJMP n ( x c — x )\\nJumps to c if bit 0≤ n≤ 31 is not set in integer x."},
            {"IFBITJMPREF", "x{E3D}ₙ — IFBITJMPREF n ( x — x )\\nPerforms a JMPREF if bit 0≤ n≤ 31 is set in integer x."},
            {"IFNBITJMPREF", "x{E3F}ₙ — IFNBITJMPREF n ( x — x )\\nPerforms a JMPREF if bit 0≤ n≤ 31 is not set in integer x."},
            {"REPEAT", "x{E4} — REPEAT ( n c — )\\nExecutes continuation c n times, if integer n is non-negative. If n≥2^{31} or n<-2^{31}, generates a range check exception. Notice that a RET inside the code of c works as a continue, not as a break. One should use either alternative (experimental) loops or alternative RETALT (along with a SETEXITALT before the loop) to break out of a loop."},
            {"REPEATEND", "x{E5} — REPEATEND ( n — )\\nSimilar to REPEAT, but it is applied to the current continuation cc."},
            {"UNTIL", "x{E6} — UNTIL ( c — )\\nExecutes continuation c, then pops an integer x from the resulting stack. If x is zero, performs another iteration of this loop. The actual implementation of this primitive involves an extraordinary continuation ec_until (cf. sp:extraord.cont ) with its arguments set to the body of the loop (continuation c ) and the original current continuation cc. This extraordinary continuation is then saved into the savelist of c as c.c0 and the modified c is then executed. The other loop primitives are implemented similarly with the aid of suitable extraordinary continuations."},
            {"UNTILEND", "x{E7} — UNTILEND ( — )\\nSimilar to UNTIL, but executes the current continuation cc in a loop. When the loop exit condition is satisfied, performs a RET."},
            {"WHILE", "x{E8} — WHILE ( c' c — )\\nExecutes c' and pops an integer x from the resulting stack. If x is zero, exists the loop and transfers control to the original cc. If x is non-zero, executes c, and then begins a new iteration."},
            {"WHILEEND", "x{E9} — WHILEEND ( c' — )\\nSimilar to WHILE, but uses the current continuation cc as the loop body."},
            {"AGAIN", "x{EA} — AGAIN ( c — )\\nSimilar to REPEAT, but executes c infinitely many times. A RET only begins a new iteration of the infinite loop, which can be exited only by an exception, or a RETALT (or an explicit JMPX )."},
            {"AGAINEND", "x{EB} — AGAINEND ( — )\\nSimilar to AGAIN, but performed with respect to the current continuation cc."},
            {"SETCONTARGS", "x{ECrn} — SETCONTARGS r,n ( x₁ x_2 … x_r c — c' )\\nSimilar to SETCONTARGS r, but sets c.nargs to the final size of the stack of c' plus n. In other words, transforms c into a closure or a partially applied function, with 0≤ n≤ 14 arguments missing.\nx{EC0n} — SETNUMARGS n or SETCONTARGS 0,n ( c — c' )\\nSets c.nargs to n plus the current depth of c 's stack, where 0≤ n≤ 14. If c.nargs is already set to a non-negative value, does nothing.\nx{ECrF} — SETCONTARGS r or SETCONTARGS r,-1 ( x₁ x_2 … x_r c — c' )\\nPushes 0≤ r≤ 15 values x₁… x_r into the stack of (a copy of) the continuation c, starting with x₁. If the final depth of c 's stack turns out to be greater than c.nargs, a stack overflow exception is generated.\nx{ECrF} — SETCONTARGS r or SETCONTARGS r,-1 ( x₁ x_2 … x_r c — c' )\\nPushes 0≤ r≤ 15 values x₁… x_r into the stack of (a copy of) the continuation c, starting with x₁. If the final depth of c 's stack turns out to be greater than c.nargs, a stack overflow exception is generated."},
            {"SETNUMARGS", "x{EC0n} — SETNUMARGS n or SETCONTARGS 0,n ( c — c' )\\nSets c.nargs to n plus the current depth of c 's stack, where 0≤ n≤ 14. If c.nargs is already set to a non-negative value, does nothing."},
            {"RETURNARGS", "x{ED0p} — RETURNARGS p ( — )\\nLeaves only the top 0≤ p≤ 15 values in the current stack (somewhat similarly to ONLYTOPX ), with all the unused bottom values not discarded, but saved into continuation c0 in the same way as SETCONTARGS does."},
            {"RETURNVARARGS", "x{ED10} — RETURNVARARGS ( p — )\\nSimilar to RETURNARGS, but with Integer 0≤ p≤ 255 taken from the stack."},
            {"SETCONTVARARGS", "x{ED11} — SETCONTVARARGS ( x₁ x_2 … x_r c r n — c' )\\nSimilar to SETCONTARGS, but with 0≤ r≤ 255 and -1≤ n≤ 255 taken from the stack."},
            {"SETNUMVARARGS", "x{ED12} — SETNUMVARARGS ( c n — c' )\\nWhere -1≤ n≤ 255. If n=-1, this operation does nothing ( c'=c ). Otherwise its action is similar to SETNUMARGS n, but with n taken from the stack."},
            {"BLESS", "x{ED1E} — BLESS ( s — c )\\nTransforms a Slice s into a simple ordinary continuation c, with c.code=s and an empty stack and savelist."},
            {"BLESSVARARGS", "x{ED1F} — BLESSVARARGS ( x₁ … x_r s r n — c )\\nEquivalent to ROT; BLESS; ROTREV; SETCONTVARARGS."},
            {"BLESSARGS", "x{EErn} — BLESSARGS r,n ( x₁ … x_r s — c )\\nWhere 0≤ r≤ 15, -1≤ n≤ 14, equivalent to BLESS; SETCONTARGS r,n. The value of n is represented inside the instruction by the 4-bit integer n mod16.\nx{EE0n} — BLESSNUMARGS n or BLESSARGS 0,n ( s — c )\\nAlso transforms a Slice s into a Continuation c, but sets c.nargs to 0≤ n≤ 14.\nx{EErn} — BLESSARGS r,n ( x₁ … x_r s — c )\\nDescribed in sp:cont.stk.manip."},
            {"BLESSNUMARGS", "x{EE0n} — BLESSNUMARGS n or BLESSARGS 0,n ( s — c )\\nAlso transforms a Slice s into a Continuation c, but sets c.nargs to 0≤ n≤ 14."},
            {"PUSHCTR", "x{ED4i} — PUSH c(i) or PUSHCTR c(i) ( — x ), pushes the current value of control register c(i). If the control register is not supported in the current codepage, or if it does not have a value, an exception is triggered."},
            {"PUSHROOT", "x{ED44} — PUSH c4 or PUSHROOT, pushes the “global data root” cell reference, thus enabling access to persistent smart-contract data."},
            {"POPCTR", "x{ED5i} — POP c(i) or POPCTR c(i) ( x — ), pops a value x from the stack and stores it into control register c(i), if supported in the current codepage. Notice that if a control register accepts only values of a specific type, a type-checking exception may occur."},
            {"POPROOT", "x{ED54} — POP c4 or POPROOT, sets the “global data root” cell reference, thus allowing modification of persistent smart-contract data."},
            {"SETCONT", "x{ED6i} — SETCONT c(i) or SETCONTCTR c(i) ( x c — c' ), stores x into the savelist of continuation c as c(i), and returns the resulting continuation c'. Almost all operations with continuations may be expressed in terms of SETCONTCTR, POPCTR, and PUSHCTR."},
            {"SETCONTCTR", "x{ED6i} — SETCONT c(i) or SETCONTCTR c(i) ( x c — c' ), stores x into the savelist of continuation c as c(i), and returns the resulting continuation c'. Almost all operations with continuations may be expressed in terms of SETCONTCTR, POPCTR, and PUSHCTR."},
            {"SETRETCTR", "x{ED7i} — SETRETCTR c(i) ( x — ), equivalent to PUSH c0; SETCONTCTR c(i); POP c0."},
            {"SETALTCTR", "x{ED8i} — SETALTCTR c(i) ( x — ), equivalent to PUSH c1; SETCONTCTR c(i); POP c0."},
            {"POPSAVE", "x{ED9i} — POPSAVE c(i) or POPCTRSAVE c(i) ( x —), similar to POP c(i), but also saves the old value of c(i) into continuation c0. Equivalent (up to exceptions) to SAVECTR c(i); POP c(i)."},
            {"POPCTRSAVE", "x{ED9i} — POPSAVE c(i) or POPCTRSAVE c(i) ( x —), similar to POP c(i), but also saves the old value of c(i) into continuation c0. Equivalent (up to exceptions) to SAVECTR c(i); POP c(i)."},
            {"SAVE", "x{EDAi} — SAVE c(i) or SAVECTR c(i) ( — ), saves the current value of c(i) into the savelist of continuation c0. If an entry for c(i) is already present in the savelist of c0, nothing is done. Equivalent to PUSH c(i); SETRETCTR c(i)."},
            {"SAVECTR", "x{EDAi} — SAVE c(i) or SAVECTR c(i) ( — ), saves the current value of c(i) into the savelist of continuation c0. If an entry for c(i) is already present in the savelist of c0, nothing is done. Equivalent to PUSH c(i); SETRETCTR c(i)."},
            {"SAVEALT", "x{EDBi} — SAVEALT c(i) or SAVEALTCTR c(i) ( — ), similar to SAVE c(i), but saves the current value of c(i) into the savelist of c1, not c0."},
            {"SAVEALTCTR", "x{EDBi} — SAVEALT c(i) or SAVEALTCTR c(i) ( — ), similar to SAVE c(i), but saves the current value of c(i) into the savelist of c1, not c0."},
            {"SAVEBOTH", "x{EDCi} — SAVEBOTH c(i) or SAVEBOTHCTR c(i) ( — ), equivalent to DUP; SAVE c(i); SAVEALT c(i)."},
            {"SAVEBOTHCTR", "x{EDCi} — SAVEBOTH c(i) or SAVEBOTHCTR c(i) ( — ), equivalent to DUP; SAVE c(i); SAVEALT c(i)."},
            {"PUSHCTRX", "x{EDE0} — PUSHCTRX ( i — x )\\nSimilar to PUSHCTR c(i), but with i, 0≤ i≤255, taken from the stack. Notice that this primitive is one of the few “exotic” primitives, which are not polymorphic like stack manipulation primitives, and at the same time do not have well-defined types of parameters and return values, because the type of x depends on i."},
            {"POPCTRX", "x{EDE1} — POPCTRX ( x i — )\\nSimilar to POPCTR c(i), but with 0≤ i≤255 from the stack."},
            {"SETCONTCTRX", "x{EDE2} — SETCONTCTRX ( x c i — c' )\\nSimilar to SETCONTCTR c(i), but with 0≤ i≤ 255 from the stack."},
            {"COMPOS", "x{EDF0} — COMPOS or BOOLAND ( c c' — c” )\\nComputes the composition c◦₀c', which has the meaning of “perform c, and, if successful, perform c' ” (if c is a boolean circuit) or simply “perform c, then c' ”. Equivalent to SWAP; SETCONT c0."},
            {"BOOLAND", "x{EDF0} — COMPOS or BOOLAND ( c c' — c” )\\nComputes the composition c◦₀c', which has the meaning of “perform c, and, if successful, perform c' ” (if c is a boolean circuit) or simply “perform c, then c' ”. Equivalent to SWAP; SETCONT c0."},
            {"COMPOSALT", "x{EDF1} — COMPOSALT or BOOLOR ( c c' — c” )\\nComputes the alternative composition c◦₁ c', which has the meaning of “perform c, and, if not successful, perform c' ” (if c is a boolean circuit). Equivalent to SWAP; SETCONT c1."},
            {"BOOLOR", "x{EDF1} — COMPOSALT or BOOLOR ( c c' — c” )\\nComputes the alternative composition c◦₁ c', which has the meaning of “perform c, and, if not successful, perform c' ” (if c is a boolean circuit). Equivalent to SWAP; SETCONT c1."},
            {"COMPOSBOTH", "x{EDF2} — COMPOSBOTH ( c c' — c” )\\nComputes (c◦₀c')◦₁c', which has the meaning of “compute boolean circuit c, then compute c', regardless of the result of c ”."},
            {"ATEXIT", "x{EDF3} — ATEXIT ( c — )\\nSets c0🡐 c◦₀c0. In other words, c will be executed before exiting current subroutine."},
            {"ATEXITALT", "x{EDF4} — ATEXITALT ( c — )\\nSets c1🡐 c◦₁c1. In other words, c will be executed before exiting current subroutine by its alternative return path."},
            {"SETEXITALT", "x{EDF5} — SETEXITALT ( c — )\\nSets c1🡐 (c◦₀c0)◦₁c1. In this way, a subsequent RETALT will first execute c, then transfer control to the original c0. This can be used, for instance, to exit from nested loops."},
            {"THENRET", "x{EDF6} — THENRET ( c — c' )\\nComputes c':=c◦₀c0"},
            {"THENRETALT", "x{EDF7} — THENRETALT ( c — c' )\\nComputes c':=c◦₀c1"},
            {"INVERT", "x{EDF8} — INVERT ( — )\\nInterchanges c0 and c1."},
            {"BOOLEVAL", "x{EDF9} — BOOLEVAL ( c — ? )\\nPerforms cc🡐 (c◦₀((PUSH-1)◦₀cc) )◦₁((PUSH0)◦₀cc). If c represents a boolean circuit, the net effect is to evaluate it and push either -1 or 0 into the stack before continuing."},
            {"CALL", "x{F0n} — CALL n or CALLDICT n ( — n )\\nCalls the continuation in c3, pushing integer 0≤ n≤ 255 into its stack as an argument. Approximately equivalent to PUSHINT n; PUSH c3; EXECUTE.\nx{F12}ₙ — CALL n for 0≤ n<2^{14} ( — n )\\nAn encoding of CALL n for larger values of n."},
            {"CALLDICT", "x{F0n} — CALL n or CALLDICT n ( — n )\\nCalls the continuation in c3, pushing integer 0≤ n≤ 255 into its stack as an argument. Approximately equivalent to PUSHINT n; PUSH c3; EXECUTE."},
            {"JMP", "x{F16}ₙ — JMP n or JMPDICT n ( — n )\\nJumps to the continuation in c3, pushing integer 0≤ n<2^{14} as its argument. Approximately equivalent to PUSHINT n; PUSH c3; JMPX."},
            {"JMPDICT", "x{F16}ₙ — JMP n or JMPDICT n ( — n )\\nJumps to the continuation in c3, pushing integer 0≤ n<2^{14} as its argument. Approximately equivalent to PUSHINT n; PUSH c3; JMPX."},
            {"PREPARE", "x{F1A}ₙ — PREPARE n or PREPAREDICT n ( — n c )\\nEquivalent to PUSHINT n; PUSH c3, for 0≤ n<2^{14}. In this way, CALL n is approximately equivalent to PREPARE n; EXECUTE, and JMP n is approximately equivalent to PREPARE n; JMPX. One might use, for instance, CALLARGS or CALLCC instead of EXECUTE here."},
            {"PREPAREDICT", "x{F1A}ₙ — PREPARE n or PREPAREDICT n ( — n c )\\nEquivalent to PUSHINT n; PUSH c3, for 0≤ n<2^{14}. In this way, CALL n is approximately equivalent to PREPARE n; EXECUTE, and JMP n is approximately equivalent to PREPARE n; JMPX. One might use, for instance, CALLARGS or CALLCC instead of EXECUTE here."},
            {"THROW", "x{F22}ₙn — THROW nn ( — 0 nn )\\nThrows exception 0≤ nn≤ 63 with parameter zero. In other words, it transfers control to the continuation in c2, pushing 0 and nn into its stack, and discarding the old stack altogether.\nx{F2C4}ₙn — THROW nn for 0≤ nn<2^{11}, an encoding of THROW nn for larger values of nn."},
            {"THROWIF", "x{F26}ₙn — THROWIF nn ( f — )\\nThrows exception 0≤ nn≤ 63 with parameter zero only if integer f≠0.\nx{F2D4}ₙn — THROWIF nn ( f — ) for 0≤ nn<2^{11}."},
            {"THROWIFNOT", "x{F2A}ₙn — THROWIFNOT nn ( f — )\\nThrows exception 0≤ nn≤ 63 with parameter zero only if integer f=0.\nx{F2E4}ₙn — THROWIFNOT nn ( f — ) for 0≤ nn<2^{11}."},
            {"THROWARG", "x{F2CC}ₙn — THROWARG nn ( x — x nn )\\nThrows exception 0≤ nn<2^{11} with parameter x, by copying x and nn into the stack of c2 and transferring control to c2."},
            {"THROWARGIF", "x{F2DC}ₙn — THROWARGIF nn ( x f — )\\nThrows exception 0≤ nn<2^{11} with parameter x only if integer f≠0."},
            {"THROWARGIFNOT", "x{F2EC}ₙn — THROWARGIFNOT nn ( x f — )\\nThrows exception 0≤ nn<2^{11} with parameter x only if integer f=0."},
            {"THROWANY", "x{F2F0} — THROWANY ( n — 0 n )\\nThrows exception 0≤ n<2^{16} with parameter zero. Approximately equivalent to PUSHINT 0; SWAP; THROWARGANY."},
            {"THROWARGANY", "x{F2F1} — THROWARGANY ( x n — x n )\\nThrows exception 0≤ n<2^{16} with parameter x, transferring control to the continuation in c2. Approximately equivalent to PUSH c2; JMPXARGS 2."},
            {"THROWANYIF", "x{F2F2} — THROWANYIF ( n f — )\\nThrows exception 0≤ n<2^{16} with parameter zero only if f≠0."},
            {"THROWARGANYIF", "x{F2F3} — THROWARGANYIF ( x n f — )\\nThrows exception 0≤ n<2^{16} with parameter x only if f≠0."},
            {"THROWANYIFNOT", "x{F2F4} — THROWANYIFNOT ( n f — )\\nThrows exception 0≤ n<2^{16} with parameter zero only if f=0."},
            {"THROWARGANYIFNOT", "x{F2F5} — THROWARGANYIFNOT ( x n f — )\\nThrows exception 0≤ n<2^{16} with parameter x only if f=0."},
            {"TRY", "x{F2FF} — TRY ( c c' — )\\nSets c2 to c', first saving the old value of c2 both into the savelist of c' and into the savelist of the current continuation, which is stored into c.c0 and c'.c0. Then runs c similarly to EXECUTE. If c does not throw any exceptions, the original value of c2 is automatically restored on return from c. If an exception occurs, the execution is transferred to c', but the original value of c2 is restored in the process, so that c' can re-throw the exception by THROWANY if it cannot handle it by itself."},
            {"TRYARGS", "x{F3pr} — TRYARGS p,r ( c c' — )\\nSimilar to TRY, but with CALLARGS p,r internally used instead of EXECUTE. In this way, all but the top 0≤ p≤ 15 stack elements will be saved into current continuation's stack, and then restored upon return from either c or c', with the top 0≤ r≤ 15 values of the resulting stack of c or c' copied as return values."},
            {"NEWDICT", "x{6D} — NEWDICT ( — D )\\nReturns a new empty dictionary. It is an alternative mnemonics for PUSHNULL, cf. sp:null.ops."},
            {"DICTEMPTY", "x{6E} — DICTEMPTY ( D — ? )\\nChecks whether dictionary D is empty, and returns -1 or 0 accordingly. It is an alternative mnemonics for ISNULL, cf. sp:null.ops."},
            {"STDICTS", "x{CE} — STDICTS ( s b — b' )\\nStores a Slice -represented dictionary s into Builder b. It is actually a synonym for STSLICE."},
            {"STDICT", "x{F400} — STDICT or STOPTREF ( D b — b' )\\nStores dictionary D into Builder b, returing the resulting Builder b'. In other words, if D is a cell, performs STONE and STREF; if D is Null, performs NIP and STZERO; otherwise throws a type checking exception."},
            {"STOPTREF", "x{F400} — STDICT or STOPTREF ( D b — b' )\\nStores dictionary D into Builder b, returing the resulting Builder b'. In other words, if D is a cell, performs STONE and STREF; if D is Null, performs NIP and STZERO; otherwise throws a type checking exception."},
            {"SKIPDICT", "x{F401} — SKIPDICT or SKIPOPTREF ( s — s' )\\nEquivalent to LDDICT; NIP."},
            {"SKIPOPTREF", "x{F401} — SKIPDICT or SKIPOPTREF ( s — s' )\\nEquivalent to LDDICT; NIP."},
            {"LDDICTS", "x{F402} — LDDICTS ( s — s' s” )\\nLoads (parses) a ( Slice -represented) dictionary s' from Slice s, and returns the remainder of s as s”. This is a “split function” for all HashmapE(n,X) dictionary types."},
            {"PLDDICTS", "x{F403} — PLDDICTS ( s — s' )\\nPreloads a ( Slice -represented) dictionary s' from Slice s. Approximately equivalent to LDDICTS; DROP."},
            {"LDDICT", "x{F404} — LDDICT or LDOPTREF ( s — D s' )\\nLoads (parses) a dictionary D from Slice s, and returns the remainder of s as s'. May be applied to dictionaries or to values of arbitrary (^Y)^? types."},
            {"LDOPTREF", "x{F404} — LDDICT or LDOPTREF ( s — D s' )\\nLoads (parses) a dictionary D from Slice s, and returns the remainder of s as s'. May be applied to dictionaries or to values of arbitrary (^Y)^? types."},
            {"PLDDICT", "x{F405} — PLDDICT or PLDOPTREF ( s — D )\\nPreloads a dictionary D from Slice s. Approximately equivalent to LDDICT; DROP."},
            {"PLDOPTREF", "x{F405} — PLDDICT or PLDOPTREF ( s — D )\\nPreloads a dictionary D from Slice s. Approximately equivalent to LDDICT; DROP."},
            {"LDDICTQ", "x{F406} — LDDICTQ ( s — D s' -1 or s 0 )\\nA quiet version of LDDICT."},
            {"PLDDICTQ", "x{F407} — PLDDICTQ ( s — D -1 or 0 )\\nA quiet version of PLDDICT."},
            {"DICTGET", "x{F40A} — DICTGET ( k D n — x -1 or 0 )\\nLooks up key k (represented by a Slice, the first 0≤ n≤ 1023 data bits of which are used as a key) in dictionary D of type HashmapE(n,X) with n -bit keys. On success, returns the value found as a Slice x."},
            {"DICTGETREF", "x{F40B} — DICTGETREF ( k D n — c -1 or 0 )\\nSimilar to DICTGET, but with a LDREF; ENDS applied to x on success. This operation is useful for dictionaries of type HashmapE(n,^Y)."},
            {"DICTIGET", "x{F40C} — DICTIGET ( i D n — x -1 or 0 )\\nSimilar to DICTGET, but with a signed (big-endian) n -bit Integer i as a key. If i does not fit into n bits, returns 0. If i is a NaN, throws an integer overflow exception."},
            {"DICTIGETREF", "x{F40D} — DICTIGETREF ( i D n — c -1 or 0 )\\nCombines DICTIGET with DICTGETREF: it uses signed n -bit Integer i as a key and returns a Cell instead of a Slice on success."},
            {"DICTUGET", "x{F40E} — DICTUGET ( i D n — x -1 or 0 )\\nSimilar to DICTIGET, but with unsigned (big-endian) n -bit Integer i used as a key."},
            {"DICTUGETREF", "x{F40F} — DICTUGETREF ( i D n — c -1 or 0 )\\nSimilar to DICTIGETREF, but with an unsigned n -bit Integer key i."},
            {"DICTSET", "x{F412} — DICTSET ( x k D n — D' )\\nSets the value associated with n -bit key k (represented by a Slice as in DICTGET ) in dictionary D (also represented by a Slice ) to value x (again a Slice ), and returns the resulting dictionary as D'."},
            {"DICTSETREF", "x{F413} — DICTSETREF ( c k D n — D' )\\nSimilar to DICTSET, but with the value set to a reference to Cell c."},
            {"DICTISET", "x{F414} — DICTISET ( x i D n — D' )\\nSimilar to DICTSET, but with the key represented by a (big-endian) signed n -bit integer i. If i does not fit into n bits, a range check exception is generated."},
            {"DICTISETREF", "x{F415} — DICTISETREF ( c i D n — D' )\\nSimilar to DICTSETREF, but with the key a signed n -bit integer as in DICTISET."},
            {"DICTUSET", "x{F416} — DICTUSET ( x i D n — D' )\\nSimilar to DICTISET, but with i an unsigned n -bit integer."},
            {"DICTUSETREF", "x{F417} — DICTUSETREF ( c i D n — D' )\\nSimilar to DICTISETREF, but with i unsigned."},
            {"DICTSETGET", "x{F41A} — DICTSETGET ( x k D n — D' y -1 or D' 0 )\\nCombines DICTSET with DICTGET: it sets the value corresponding to key k to x, but also returns the old value y associated with the key in question, if present."},
            {"DICTSETGETREF", "x{F41B} — DICTSETGETREF ( c k D n — D' c' -1 or D' 0 )\\nCombines DICTSETREF with DICTGETREF similarly to DICTSETGET."},
            {"DICTISETGET", "x{F41C} — DICTISETGET ( x i D n — D' y -1 or D' 0 )\\nSimilar to DICTSETGET, but with the key represented by a big-endian signed n -bit Integer i."},
            {"DICTISETGETREF", "x{F41D} — DICTISETGETREF ( c i D n — D' c' -1 or D' 0 )\\nA version of DICTSETGETREF with signed Integer i as a key."},
            {"DICTUSETGET", "x{F41E} — DICTUSETGET ( x i D n — D' y -1 or D' 0 )\\nSimilar to DICTISETGET, but with i an unsigned n -bit integer."},
            {"DICTUSETGETREF", "x{F41F} — DICTUSETGETREF ( c i D n — D' c' -1 or D' 0 )."},
            {"DICTREPLACE", "x{F422} — DICTREPLACE ( x k D n — D' -1 or D 0 )\\nA sc Replace operation, which is similar to DICTSET, but sets the value of key k in dictionary D to x only if the key k was already present in D."},
            {"DICTREPLACEREF", "x{F423} — DICTREPLACEREF ( c k D n — D' -1 or D 0 )\\nA sc Replace counterpart of DICTSETREF."},
            {"DICTIREPLACE", "x{F424} — DICTIREPLACE ( x i D n — D' -1 or D 0 )\\nA version of DICTREPLACE with signed n -bit Integer i used as a key."},
            {"DICTIREPLACEREF", "x{F425} — DICTIREPLACEREF ( c i D n — D' -1 or D 0 )."},
            {"DICTUREPLACE", "x{F426} — DICTUREPLACE ( x i D n — D' -1 or D 0 )."},
            {"DICTUREPLACEREF", "x{F427} — DICTUREPLACEREF ( c i D n — D' -1 or D 0 )."},
            {"DICTREPLACEGET", "x{F42A} — DICTREPLACEGET ( x k D n — D' y -1 or D 0 )\\nA sc Replace counterpart of DICTSETGET: on success, also returns the old value associated with the key in question."},
            {"DICTREPLACEGETREF", "x{F42B} — DICTREPLACEGETREF ( c k D n — D' c' -1 or D 0 )."},
            {"DICTIREPLACEGET", "x{F42C} — DICTIREPLACEGET ( x i D n — D' y -1 or D 0 )."},
            {"DICTIREPLACEGETREF", "x{F42D} — DICTIREPLACEGETREF ( c i D n — D' c' -1 or D 0 )."},
            {"DICTUREPLACEGET", "x{F42E} — DICTUREPLACEGET ( x i D n — D' y -1 or D 0 )."},
            {"DICTUREPLACEGETREF", "x{F42F} — DICTUREPLACEGETREF ( c i D n — D' c' -1 or D 0 )."},
            {"DICTADD", "x{F432} — DICTADD ( x k D n — D' -1 or D 0 )\\nAn sc Add counterpart of DICTSET: sets the value associated with key k in dictionary D to x, but only if it is not already present in D."},
            {"DICTADDREF", "x{F433} — DICTADDREF ( c k D n — D' -1 or D 0 )."},
            {"DICTIADD", "x{F434} — DICTIADD ( x i D n — D' -1 or D 0 )."},
            {"DICTIADDREF", "x{F435} — DICTIADDREF ( c i D n — D' -1 or D 0 )."},
            {"DICTUADD", "x{F436} — DICTUADD ( x i D n — D' -1 or D 0 )."},
            {"DICTUADDREF", "x{F437} — DICTUADDREF ( c i D n — D' -1 or D 0 )."},
            {"DICTADDGET", "x{F43A} — DICTADDGET ( x k D n — D' -1 or D y 0 )\\nAn sc Add counterpart of DICTSETGET: sets the value associated with key k in dictionary D to x, but only if key k is not already present in D. Otherwise, just returns the old value y without changing the dictionary."},
            {"DICTADDGETREF", "x{F43B} — DICTADDGETREF ( c k D n — D' -1 or D c' 0 )\\nAn sc Add counterpart of DICTSETGETREF."},
            {"DICTIADDGET", "x{F43C} — DICTIADDGET ( x i D n — D' -1 or D y 0 )."},
            {"DICTIADDGETREF", "x{F43D} — DICTIADDGETREF ( c i D n — D' -1 or D c' 0 )."},
            {"DICTUADDGET", "x{F43E} — DICTUADDGET ( x i D n — D' -1 or D y 0 )."},
            {"DICTUADDGETREF", "x{F43F} — DICTUADDGETREF ( c i D n — D' -1 or D c' 0 )."},
            {"DICTSETB", "x{F441} — DICTSETB ( b k D n — D' )."},
            {"DICTISETB", "x{F442} — DICTISETB ( b i D n — D' )."},
            {"DICTUSETB", "x{F443} — DICTUSETB ( b i D n — D' )."},
            {"DICTSETGETB", "x{F445} — DICTSETGETB ( b k D n — D' y -1 or D' 0 )."},
            {"DICTISETGETB", "x{F446} — DICTISETGETB ( b i D n — D' y -1 or D' 0 )."},
            {"DICTUSETGETB", "x{F447} — DICTUSETGETB ( b i D n — D' y -1 or D' 0 )."},
            {"DICTREPLACEB", "x{F449} — DICTREPLACEB ( b k D n — D' -1 or D 0 )."},
            {"DICTIREPLACEB", "x{F44A} — DICTIREPLACEB ( b i D n — D' -1 or D 0 )."},
            {"DICTUREPLACEB", "x{F44B} — DICTUREPLACEB ( b i D n — D' -1 or D 0 )."},
            {"DICTREPLACEGETB", "x{F44D} — DICTREPLACEGETB ( b k D n — D' y -1 or D 0 )."},
            {"DICTIREPLACEGETB", "x{F44E} — DICTIREPLACEGETB ( b i D n — D' y -1 or D 0 )."},
            {"DICTUREPLACEGETB", "x{F44F} — DICTUREPLACEGETB ( b i D n — D' y -1 or D 0 )."},
            {"DICTADDB", "x{F451} — DICTADDB ( b k D n — D' -1 or D 0 )."},
            {"DICTIADDB", "x{F452} — DICTIADDB ( b i D n — D' -1 or D 0 )."},
            {"DICTUADDB", "x{F453} — DICTUADDB ( b i D n — D' -1 or D 0 )."},
            {"DICTADDGETB", "x{F455} — DICTADDGETB ( b k D n — D' -1 or D y 0 )."},
            {"DICTIADDGETB", "x{F456} — DICTIADDGETB ( b i D n — D' -1 or D y 0 )."},
            {"DICTUADDGETB", "x{F457} — DICTUADDGETB ( b i D n — D' -1 or D y 0 )."},
            {"DICTDEL", "x{F459} — DICTDEL ( k D n — D' -1 or D 0 )\\nDeletes n -bit key, represented by a Slice k, from dictionary D. If the key is present, returns the modified dictionary D' and the success flag -1. Otherwise, returns the original dictionary D and 0."},
            {"DICTIDEL", "x{F45A} — DICTIDEL ( i D n — D' ? )\\nA version of DICTDEL with the key represented by a signed n -bit Integer i. If i does not fit into n bits, simply returns D 0 (“key not found, dictionary unmodified”)."},
            {"DICTUDEL", "x{F45B} — DICTUDEL ( i D n — D' ? )\\nSimilar to DICTIDEL, but with i an unsigned n -bit integer."},
            {"DICTDELGET", "x{F462} — DICTDELGET ( k D n — D' x -1 or D 0 )\\nDeletes n -bit key, represented by a Slice k, from dictionary D. If the key is present, returns the modified dictionary D', the original value x associated with the key k (represented by a Slice ), and the success flag -1. Otherwise, returns the original dictionary D and 0."},
            {"DICTDELGETREF", "x{F463} — DICTDELGETREF ( k D n — D' c -1 or D 0 )\\nSimilar to DICTDELGET, but with LDREF; ENDS applied to x on success, so that the value returned c is a Cell."},
            {"DICTIDELGET", "x{F464} — DICTIDELGET ( i D n — D' x -1 or D 0 )\\nA variant of primitive DICTDELGET with signed n -bit integer i as a key."},
            {"DICTIDELGETREF", "x{F465} — DICTIDELGETREF ( i D n — D' c -1 or D 0 )\\nA variant of primitive DICTIDELGET returning a Cell instead of a Slice."},
            {"DICTUDELGET", "x{F466} — DICTUDELGET ( i D n — D' x -1 or D 0 )\\nA variant of primitive DICTDELGET with unsigned n -bit integer i as a key."},
            {"DICTUDELGETREF", "x{F467} — DICTUDELGETREF ( i D n — D' c -1 or D 0 )\\nA variant of primitive DICTUDELGET returning a Cell instead of a Slice."},
            {"DICTGETOPTREF", "x{F469} — DICTGETOPTREF ( k D n — c^? )\\nA variant of DICTGETREF that returns Null instead of the value c^? if the key k is absent from dictionary D."},
            {"DICTIGETOPTREF", "x{F46A} — DICTIGETOPTREF ( i D n — c^? )\\nSimilar to DICTGETOPTREF, but with the key given by signed n -bit Integer i. If the key i is out of range, also returns Null."},
            {"DICTUGETOPTREF", "x{F46B} — DICTUGETOPTREF ( i D n — c^? )\\nSimilar to DICTGETOPTREF, but with the key given by unsigned n -bit Integer i."},
            {"DICTSETGETOPTREF", "x{F46D} — DICTSETGETOPTREF ( c^? k D n — D' ć^? )\\nA variant of both DICTGETOPTREF and DICTSETGETREF that sets the value corresponding to key k in dictionary D to c^? (if c^? is Null, then the key is deleted instead), and returns the old value ć^? (if the key k was absent before, returns Null instead)."},
            {"DICTISETGETOPTREF", "x{F46E} — DICTISETGETOPTREF ( c^? i D n — D' ć^? )\\nSimilar to primitive DICTSETGETOPTREF, but using signed n -bit Integer i as a key. If i does not fit into n bits, throws a range checking exception."},
            {"DICTUSETGETOPTREF", "x{F46F} — DICTUSETGETOPTREF ( c^? i D n — D' ć^? )\\nSimilar to primitive DICTSETGETOPTREF, but using unsigned n -bit Integer i as a key."},
            {"PFXDICTSET", "x{F470} — PFXDICTSET ( x k D n — D' -1 or D 0 )."},
            {"PFXDICTREPLACE", "x{F471} — PFXDICTREPLACE ( x k D n — D' -1 or D 0 )."},
            {"PFXDICTADD", "x{F472} — PFXDICTADD ( x k D n — D' -1 or D 0 )."},
            {"PFXDICTDEL", "x{F473} — PFXDICTDEL ( k D n — D' -1 or D 0 )."},
            {"DICTGETNEXT", "x{F474} — DICTGETNEXT ( k D n — x' k' -1 or 0 )\\nComputes the minimal key k' in dictionary D that is lexicographically greater than k, and returns k' (represented by a Slice ) along with associated value x' (also represented by a Slice )."},
            {"DICTGETNEXTEQ", "x{F475} — DICTGETNEXTEQ ( k D n — x' k' -1 or 0 )\\nSimilar to DICTGETNEXT, but computes the minimal key k' that is lexicographically greater than or equal to k."},
            {"DICTGETPREV", "x{F476} — DICTGETPREV ( k D n — x' k' -1 or 0 )\\nSimilar to DICTGETNEXT, but computes the maximal key k' lexicographically smaller than k."},
            {"DICTGETPREVEQ", "x{F477} — DICTGETPREVEQ ( k D n — x' k' -1 or 0 )\\nSimilar to DICTGETPREV, but computes the maximal key k' lexicographically smaller than or equal to k."},
            {"DICTIGETNEXT", "x{F478} — DICTIGETNEXT ( i D n — x' i' -1 or 0 )\\nSimilar to DICTGETNEXT, but interprets all keys in dictionary D as big-endian signed n -bit integers, and computes the minimal key i' that is larger than Integer i (which does not necessarily fit into n bits)."},
            {"DICTIGETNEXTEQ", "x{F479} — DICTIGETNEXTEQ ( i D n — x' i' -1 or 0 )."},
            {"DICTIGETPREV", "x{F47A} — DICTIGETPREV ( i D n — x' i' -1 or 0 )."},
            {"DICTIGETPREVEQ", "x{F47B} — DICTIGETPREVEQ ( i D n — x' i' -1 or 0 )."},
            {"DICTUGETNEXT", "x{F47C} — DICTUGETNEXT ( i D n — x' i' -1 or 0 )\\nSimilar to DICTGETNEXT, but interprets all keys in dictionary D as big-endian unsigned n -bit integers, and computes the minimal key i' that is larger than Integer i (which does not necessarily fit into n bits, and is not necessarily non-negative)."},
            {"DICTUGETNEXTEQ", "x{F47D} — DICTUGETNEXTEQ ( i D n — x' i' -1 or 0 )."},
            {"DICTUGETPREV", "x{F47E} — DICTUGETPREV ( i D n — x' i' -1 or 0 )."},
            {"DICTUGETPREVEQ", "x{F47F} — DICTUGETPREVEQ ( i D n — x' i' -1 or 0 )."},
            {"DICTMIN", "x{F482} — DICTMIN ( D n — x k -1 or 0 )\\nComputes the minimal key k (represented by a Slice with n data bits) in dictionary D, and returns k along with the associated value x."},
            {"DICTMINREF", "x{F483} — DICTMINREF ( D n — c k -1 or 0 )\\nSimilar to DICTMIN, but returns the only reference in the value as a Cell c."},
            {"DICTIMIN", "x{F484} — DICTIMIN ( D n — x i -1 or 0 )\\nSomewhat similar to DICTMIN, but computes the minimal key i under the assumption that all keys are big-endian signed n -bit integers. Notice that the key and value returned may differ from those computed by DICTMIN and DICTUMIN."},
            {"DICTIMINREF", "x{F485} — DICTIMINREF ( D n — c i -1 or 0 )."},
            {"DICTUMIN", "x{F486} — DICTUMIN ( D n — x i -1 or 0 )\\nSimilar to DICTMIN, but returns the key as an unsigned n -bit Integer i."},
            {"DICTUMINREF", "x{F487} — DICTUMINREF ( D n — c i -1 or 0 )."},
            {"DICTMAX", "x{F48A} — DICTMAX ( D n — x k -1 or 0 )\\nComputes the maximal key k (represented by a Slice with n data bits) in dictionary D, and returns k along with the associated value x."},
            {"DICTMAXREF", "x{F48B} — DICTMAXREF ( D n — c k -1 or 0 )."},
            {"DICTIMAX", "x{F48C} — DICTIMAX ( D n — x i -1 or 0 )."},
            {"DICTIMAXREF", "x{F48D} — DICTIMAXREF ( D n — c i -1 or 0 )."},
            {"DICTUMAX", "x{F48E} — DICTUMAX ( D n — x i -1 or 0 )."},
            {"DICTUMAXREF", "x{F48F} — DICTUMAXREF ( D n — c i -1 or 0 )."},
            {"DICTREMMIN", "x{F492} — DICTREMMIN ( D n — D' x k -1 or D 0 )\\nComputes the minimal key k (represented by a Slice with n data bits) in dictionary D, removes k from the dictionary, and returns k along with the associated value x and the modified dictionary D'."},
            {"DICTREMMINREF", "x{F493} — DICTREMMINREF ( D n — D' c k -1 or D 0 )\\nSimilar to DICTREMMIN, but returns the only reference in the value as a Cell c."},
            {"DICTIREMMIN", "x{F494} — DICTIREMMIN ( D n — D' x i -1 or D 0 )\\nSomewhat similar to DICTREMMIN, but computes the minimal key i under the assumption that all keys are big-endian signed n -bit integers. Notice that the key and value returned may differ from those computed by DICTREMMIN and DICTUREMMIN."},
            {"DICTIREMMINREF", "x{F495} — DICTIREMMINREF ( D n — D' c i -1 or D 0 )."},
            {"DICTUREMMIN", "x{F496} — DICTUREMMIN ( D n — D' x i -1 or D 0 )\\nSimilar to DICTREMMIN, but returns the key as an unsigned n -bit Integer i."},
            {"DICTUREMMINREF", "x{F497} — DICTUREMMINREF ( D n — D' c i -1 or D 0 )."},
            {"DICTREMMAX", "x{F49A} — DICTREMMAX ( D n — D' x k -1 or D 0 )\\nComputes the maximal key k (represented by a Slice with n data bits) in dictionary D, removes k from the dictionary, and returns k along with the associated value x and the modified dictionary D'."},
            {"DICTREMMAXREF", "x{F49B} — DICTREMMAXREF ( D n — D' c k -1 or D 0 )."},
            {"DICTIREMMAX", "x{F49C} — DICTIREMMAX ( D n — D' x i -1 or D 0 )."},
            {"DICTIREMMAXREF", "x{F49D} — DICTIREMMAXREF ( D n — D' c i -1 or D 0 )."},
            {"DICTUREMMAX", "x{F49E} — DICTUREMMAX ( D n — D' x i -1 or D 0 )."},
            {"DICTUREMMAXREF", "x{F49F} — DICTUREMMAXREF ( D n — D' c i -1 or D 0 )."},
            {"DICTIGETJMP", "x{F4A0} — DICTIGETJMP ( i D n — )\\nSimilar to DICTIGET (cf. sp:prim.dict.get ), but with x BLESS ed into a continuation with a subsequent JMPX to it on success. On failure, does nothing. This is useful for implementing switch / case constructions."},
            {"DICTUGETJMP", "x{F4A1} — DICTUGETJMP ( i D n — )\\nSimilar to DICTIGETJMP, but performs DICTUGET instead of DICTIGET."},
            {"DICTIGETEXEC", "x{F4A2} — DICTIGETEXEC ( i D n — )\\nSimilar to DICTIGETJMP, but with EXECUTE instead of JMPX."},
            {"DICTUGETEXEC", "x{F4A3} — DICTUGETEXEC ( i D n — )\\nSimilar to DICTUGETJMP, but with EXECUTE instead of JMPX."},
            {"DICTPUSHCONST", "x{F4A6}ₙ — DICTPUSHCONST n ( — D n )\\nPushes a non-empty constant dictionary D (as a Cell^? ) along with its key length 0≤ n≤ 1023, stored as a part of the instruction. The dictionary itself is created from the first of remaining references of the current continuation. In this way, the complete DICTPUSHCONST instruction can be obtained by first serializing xF4A8_, then the non-empty dictionary itself (one 1 bit and a cell reference), and then the unsigned 10-bit integer n (as if by a STU 10 instruction). An empty dictionary can be pushed by a NEWDICT primitive (cf. sp:prim.dict.create ) instead."},
            {"PFXDICTGETQ", "x{F4A8} — PFXDICTGETQ ( s D n — s' x s” -1 or s 0 )\\nLooks up the unique prefix of Slice s present in the prefix code dictionary (cf. sp:pfx.dict.tlb ) represented by Cell^? D and 0≤ n≤ 1023. If found, the prefix of s is returned as s', and the corresponding value (also a Slice ) as x. The remainder of s is returned as a Slice s”. If no prefix of s is a key in prefix code dictionary D, returns the unchanged s and a zero flag to indicate failure."},
            {"PFXDICTGET", "x{F4A9} — PFXDICTGET ( s D n — s' x s” )\\nSimilar to PFXDICTGET, but throws a cell deserialization failure exception on failure."},
            {"PFXDICTGETJMP", "x{F4AA} — PFXDICTGETJMP ( s D n — s' s” or s )\\nSimilar to PFXDICTGETQ, but on success BLESS es the value x into a Continuation and transfers control to it as if by a JMPX. On failure, returns s unchanged and continues execution."},
            {"PFXDICTGETEXEC", "x{F4AB} — PFXDICTGETEXEC ( s D n — s' s” )\\nSimilar to PFXDICTGETJMP, but EXEC utes the continuation found instead of jumping to it. On failure, throws a cell deserialization exception."},
            {"PFXDICTCONSTGETJMP", "x{F4AE}ₙ — PFXDICTCONSTGETJMP n or PFXDICTSWITCH n ( s — s' s” or s )\\nCombines DICTPUSHCONST n for 0≤ n≤ 1023 with PFXDICTGETJMP."},
            {"PFXDICTSWITCH", "x{F4AE}ₙ — PFXDICTCONSTGETJMP n or PFXDICTSWITCH n ( s — s' s” or s )\\nCombines DICTPUSHCONST n for 0≤ n≤ 1023 with PFXDICTGETJMP."},
            {"SUBDICTGET", "x{F4B1} — SUBDICTGET ( k l D n — D' )\\nConstructs a subdictionary consisting of all keys beginning with prefix k (represented by a Slice, the first 0≤ l≤ n≤ 1023 data bits of which are used as a key) of length l in dictionary D of type HashmapE(n,X) with n -bit keys. On success, returns the new subdictionary of the same type HashmapE(n,X) as a Slice D'."},
            {"SUBDICTIGET", "x{F4B2} — SUBDICTIGET ( x l D n — D' )\\nVariant of SUBDICTGET with the prefix represented by a signed big-endian l -bit Integer x, where necessarily l≤257."},
            {"SUBDICTUGET", "x{F4B3} — SUBDICTUGET ( x l D n — D' )\\nVariant of SUBDICTGET with the prefix represented by an unsigned big-endian l -bit Integer x, where necessarily l≤256."},
            {"SUBDICTRPGET", "x{F4B5} — SUBDICTRPGET ( k l D n — D' )\\nSimilar to SUBDICTGET, but removes the common prefix k from all keys of the new dictionary D', which becomes of type HashmapE(n-l,X)."},
            {"SUBDICTIRPGET", "x{F4B6} — SUBDICTIRPGET ( x l D n — D' )\\nVariant of SUBDICTRPGET with the prefix represented by a signed big-endian l -bit Integer x, where necessarily l≤257."},
            {"SUBDICTURPGET", "x{F4B7} — SUBDICTURPGET ( x l D n — D' )\\nVariant of SUBDICTRPGET with the prefix represented by an unsigned big-endian l -bit Integer x, where necessarily l≤256."},
            {"ACCEPT", "x{F800} — ACCEPT, sets current gas limit g_l to its maximal allowed value gₘ, and resets the gas credit g_c to zero (cf. p:tvm.state )\\nDecreasing the value of g_r by g_c in the process. In other words, the current smart contract agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves."},
            {"SETGASLIMIT", "x{F801} — SETGASLIMIT ( g — )\\nSets current gas limit g_l to the minimum of g and gₘ, and resets the gas credit g_c to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of g_l, an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that SETGASLIMIT with an argument g≥ 2^{63}-1 is equivalent to ACCEPT."},
            {"BUYGAS", "x{F802} — BUYGAS ( x — )\\nComputes the amount of gas that can be bought for x nanograms, and sets g_l accordingly in the same way as SETGASLIMIT."},
            {"GRAMTOGAS", "x{F804} — GRAMTOGAS ( x — g )\\nComputes the amount of gas that can be bought for x nanograms. If x is negative, returns 0. If g exceeds 2^{63}-1, it is replaced with this value."},
            {"GASTOGRAM", "x{F805} — GASTOGRAM ( g — x )\\nComputes the price of g gas in nanograms."},
            {"COMMIT", "x{F80F} — COMMIT ( — )\\nCommits the current state of registers c4 (“persistent data”) and c5 (“actions”) so that the current execution is considered “successful” with the saved values even if an exception is thrown later."},
            {"GETPARAM", "x{F82i} — GETPARAM i ( — x )\\nReturns the i -th parameter from the Tuple provided at c7 for 0≤ i<16. Equivalent to PUSH c7; FIRST; INDEX i. If one of these internal operations fails, throws an appropriate type checking or range checking exception."},
            {"NOW", "x{F823} — NOW ( — x )\\nReturns the current Unix time as an Integer. If it is impossible to recover the requested value starting from c7, throws a type checking or range checking exception as appropriate. Equivalent to GETPARAM 3."},
            {"BLOCKLT", "x{F824} — BLOCKLT ( — x )\\nReturns the starting logical time of the current block. Equivalent to GETPARAM 4."},
            {"LTIME", "x{F825} — LTIME ( — x )\\nReturns the logical time of the current transaction. Equivalent to GETPARAM 5."},
            {"BALANCE", "x{F826} — BALANCE ( — t )\\nReturns the remaining balance of the smart contract as a Tuple consisting of an Integer (the remaining Gram balance in nanograms) and a Maybe Cell (a dictionary with 32-bit keys representing the balance of “extra currencies”). Equivalent to GETPARAM 6. Note that RAW primitives such as SENDRAWMSG do not update this field."},
            {"RANDSEED", "x{F827} — RANDSEED ( — x )\\nReturns the current random seed as an unsigned 256-bit Integer. Equivalent to GETPARAM 7."},
            {"MYADDR", "x{F828} — MYADDR ( — s )\\nReturns the internal address of the current smart contract as a Slice with a MsgAddressInt. If necessary, it can be parsed further using primitives such as PARSESTDADDR or REWRITESTDADDR. Equivalent to GETPARAM 8."},
            {"REWRITESTDADDR", "x{F828} — MYADDR ( — s )\\nReturns the internal address of the current smart contract as a Slice with a MsgAddressInt. If necessary, it can be parsed further using primitives such as PARSESTDADDR or REWRITESTDADDR. Equivalent to GETPARAM 8.\nx{FA44} — REWRITESTDADDR ( s — x y )\\nParses CellSlice s containing a valid MsgAddressInt (usually a msg_addr_std ), applies rewriting from the anycast (if present) to the same-length prefix of the address, and returns both the workchain x and the 256-bit address y as Integer s. If the address is not 256-bit, or if s is not a valid serialization of MsgAddressInt, throws a cell deserialization exception."},
            {"CONFIGROOT", "x{F829} — CONFIGROOT ( — D )\\nReturns the Maybe Cell D with the current global configuration dictionary. Equivalent to GETPARAM 9."},
            {"CONFIGDICT", "x{F830} — CONFIGDICT ( — D 32 )\\nReturns the global configuration dictionary along with its key length (32). Equivalent to CONFIGROOT; PUSHINT 32."},
            {"CONFIGPARAM", "x{F832} — CONFIGPARAM ( i — c -1 or 0 )\\nReturns the value of the global configuration parameter with integer index i as a Cell c, and a flag to indicate success. Equivalent to CONFIGDICT; DICTIGETREF."},
            {"CONFIGOPTPARAM", "x{F833} — CONFIGOPTPARAM ( i — c^? )\\nReturns the value of the global configuration parameter with integer index i as a Maybe Cell c^?. Equivalent to CONFIGDICT; DICTIGETOPTREF."},
            {"GETGLOBVAR", "x{F840} — GETGLOBVAR ( k — x )\\nReturns the k -th global variable for 0≤ k<255. Equivalent to PUSH c7; SWAP; INDEXVARQ (cf. sp:prim.tuple )."},
            {"GETGLOB", "x{F85_k} — GETGLOB k ( — x )\\nReturns the k -th global variable for 1≤ k≤ 31. Equivalent to PUSH c7; INDEXQ k."},
            {"SETGLOBVAR", "x{F860} — SETGLOBVAR ( x k — )\\nAssigns x to the k -th global variable for 0≤ k<255. Equivalent to PUSH c7; ROTREV; SETINDEXVARQ; POP c7."},
            {"SETGLOB", "x{F87_k} — SETGLOB k ( x — )\\nAssigns x to the k -th global variable for 1≤ k≤ 31. Equivalent to PUSH c7; SWAP; SETINDEXQ k; POP c7."},
            {"HASHCU", "x{F900} — HASHCU ( c — x )\\nComputes the representation hash (cf. sp:repr.hash ) of a Cell c and returns it as a 256-bit unsigned integer x. Useful for signing and checking signatures of arbitrary entities represented by a tree of cells."},
            {"HASHSU", "x{F901} — HASHSU ( s — x )\\nComputes the hash of a Slice s and returns it as a 256-bit unsigned integer x. The result is the same as if an ordinary cell containing only data and references from s had been created and its hash computed by HASHCU."},
            {"SHA256U", "x{F902} — SHA256U ( s — x )\\nComputes SHA256 of the data bits of Slice s. If the bit length of s is not divisible by eight, throws a cell underflow exception. The hash value is returned as a 256-bit unsigned integer x."},
            {"CHKSIGNU", "x{F910} — CHKSIGNU ( h s k — ? )\\nChecks the Ed25519-signature s of a hash h (a 256-bit unsigned integer, usually computed as the hash of some data) using public key k (also represented by a 256-bit unsigned integer). The signature s must be a Slice containing at least 512 data bits; only the first 512 bits are used. The result is -1 if the signature is valid, 0 otherwise. Notice that CHKSIGNU is equivalent to ROT; NEWB; STU 256; ENDB; NEWC; ROTREV; CHKSIGNS, i.e., to CHKSIGNS with the first argument d set to 256-bit Slice containing h. Therefore, if h is computed as the hash of some data, these data are hashed twice, the second hashing occurring inside CHKSIGNS."},
            {"CHKSIGNS", "x{F911} — CHKSIGNS ( d s k — ? )\\nChecks whether s is a valid Ed25519-signature of the data portion of Slice d using public key k, similarly to CHKSIGNU. If the bit length of Slice d is not divisible by eight, throws a cell underflow exception. The verification of Ed25519 signatures is the standard one, with SHA256 used to reduce d to the 256-bit number that is actually signed."},
            {"LDGRAMS", "x{FA00} — LDGRAMS or LDVARUINT16 ( s — x s' )\\nLoads (deserializes) a Gram or VarUInteger 16 amount from CellSlice s, and returns the amount as Integer x along with the remainder s' of s. The expected serialization of x consists of a 4-bit unsigned big-endian integer l, followed by an 8l -bit unsigned big-endian representation of x. The net effect is approximately equivalent to LDU 4; SWAP; LSHIFT 3; LDUX."},
            {"LDVARUINT16", "x{FA00} — LDGRAMS or LDVARUINT16 ( s — x s' )\\nLoads (deserializes) a Gram or VarUInteger 16 amount from CellSlice s, and returns the amount as Integer x along with the remainder s' of s. The expected serialization of x consists of a 4-bit unsigned big-endian integer l, followed by an 8l -bit unsigned big-endian representation of x. The net effect is approximately equivalent to LDU 4; SWAP; LSHIFT 3; LDUX."},
            {"LDVARINT16", "x{FA01} — LDVARINT16 ( s — x s' )\\nSimilar to LDVARUINT16, but loads a signed Integer x. Approximately equivalent to LDU 4; SWAP; LSHIFT 3; LDIX."},
            {"STGRAMS", "x{FA02} — STGRAMS or STVARUINT16 ( b x — b' )\\nStores (serializes) an Integer x in the range 0…2^{120}-1 into Builder b, and returns the resulting Builder b'. The serialization of x consists of a 4-bit unsigned big-endian integer l, which is the smallest integer l≥0, such that x<2^{8l}, followed by an 8l -bit unsigned big-endian representation of x. If x does not belong to the supported range, a range check exception is thrown."},
            {"STVARUINT16", "x{FA02} — STGRAMS or STVARUINT16 ( b x — b' )\\nStores (serializes) an Integer x in the range 0…2^{120}-1 into Builder b, and returns the resulting Builder b'. The serialization of x consists of a 4-bit unsigned big-endian integer l, which is the smallest integer l≥0, such that x<2^{8l}, followed by an 8l -bit unsigned big-endian representation of x. If x does not belong to the supported range, a range check exception is thrown."},
            {"STVARINT16", "x{FA03} — STVARINT16 ( b x — b' )\\nSimilar to STVARUINT16, but serializes a signed Integer x in the range -2^{119}…2^{119}-1."},
            {"LDVARUINT32", "x{FA04} — LDVARUINT32 ( s — x s' )\\nLoads (deserializes) a VarUInteger 32 from CellSlice s, and returns the deserialized value as an Integer 0≤ x<2^{248}. The expected serialization of x consists of a 5-bit unsigned big-endian integer l, followed by an 8l -bit unsigned big-endian representation of x. The net effect is approximately equivalent to LDU 5; SWAP; SHIFT 3; LDUX."},
            {"LDVARINT32", "x{FA05} — LDVARINT32 ( s — x s' )\\nDeserializes a VarInteger 32 from CellSlice s, and returns the deserialized value as an Integer -2^{247}≤ x<2^{247}."},
            {"STVARUINT32", "x{FA06} — STVARUINT32 ( b x — b' )\\nSerializes an Integer 0≤ x<2^{248} as a VarUInteger 32."},
            {"STVARINT32", "x{FA07} — STVARINT32 ( b x — b' )\\nSerializes an Integer -2^{247}≤ x<2^{247} as a VarInteger 32."},
            {"LDMSGADDR", "x{FA40} — LDMSGADDR ( s — s' s” )\\nLoads from CellSlice s the only prefix that is a valid MsgAddress, and returns both this prefix s' and the remainder s” of s as CellSlice s."},
            {"LDMSGADDRQ", "x{FA41} — LDMSGADDRQ ( s — s' s” -1 or s 0 )\\nA quiet version of LDMSGADDR: on success, pushes an extra -1; on failure, pushes the original s and a zero."},
            {"PARSEMSGADDR", "x{FA42} — PARSEMSGADDR ( s — t )\\nDecomposes CellSlice s containing a valid MsgAddress into a Tuple t with separate fields of this MsgAddress. If s is not a valid MsgAddress, a cell deserialization exception is thrown."},
            {"PARSEMSGADDRQ", "x{FA43} — PARSEMSGADDRQ ( s — t -1 or 0 )\\nA quiet version of PARSEMSGADDR: returns a zero on error instead of throwing an exception."},
            {"REWRITESTDADDRQ", "x{FA45} — REWRITESTDADDRQ ( s — x y -1 or 0 )\\nA quiet version of primitive REWRITESTDADDR."},
            {"REWRITEVARADDR", "x{FA46} — REWRITEVARADDR ( s — x s' )\\nA variant of REWRITESTDADDR that returns the (rewritten) address as a Slice s, even if it is not exactly 256 bit long (represented by a msg_addr_var )."},
            {"REWRITEVARADDRQ", "x{FA47} — REWRITEVARADDRQ ( s — x s' -1 or 0 )\\nA quiet version of primitive REWRITEVARADDR."},
            {"SENDRAWMSG", "x{FB00} — SENDRAWMSG ( c x — )\\nSends a raw message contained in Cell c, which should contain a correctly serialized object Message X, with the only exception that the source address is allowed to have dummy value addrₙone (to be automatically replaced with the current smart-contract address), and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction). Integer parameter x contains the flags. Currently x=0 is used for ordinary messages; x=128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message); x=64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount); x'=x+1 means that the sender wants to pay transfer fees separately; x'=x+2 means that any errors arising while processing this message during the action phase should be ignored."},
            {"RAWRESERVE", "x{FB02} — RAWRESERVE ( x y — )\\nCreates an output action which would reserve exactly x nanograms (if y=0 ), at most x nanograms (if y=2 ), or all but x nanograms (if y=1 or y=3 ), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying x nanograms (or b-x nanograms, where b is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit +2 in y means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Currently x must be a non-negative integer, and y must be in the range 0… 3."},
            {"RAWRESERVEX", "x{FB03} — RAWRESERVEX ( s y — )\\nSimilar to RAWRESERVE, but accepts a Slice s with a CurrencyCollection as an argument. In this way currencies other than Grams can be reserved."},
            {"SETCODE", "x{FB04} — SETCODE ( c — )\\nCreates an output action that would change this smart contract code to that given by Cell c. Notice that this change will take effect only after the successful termination of the current run of the smart contract."},
            {"DEBUG", "x{FEnn} — DEBUG nn, for 0≤ nn<240, is a two-byte NOP."},
            {"DEBUGSTR", "x{FEFnssss} — DEBUGSTR ssss, for 0≤ n<16, is an (n+3) -byte NOP, with the (n+1) -byte “contents string” ssss skipped as well."},
            {"DUMPSTK", "x{FE00} — DUMPSTK, dumps the stack (at most the top 255 values) and shows the total stack depth."},
            {"DUMPSTKTOP", "x{FE0n} — DUMPSTKTOP n, 1≤ n<15, dumps the top n values from the stack, starting from the deepest of them. If there are d<n values available, dumps only d values."},
            {"HEXDUMP", "x{FE10} — HEXDUMP, dumps s0 in hexadecimal form, be it a Slice or an Integer."},
            {"HEXPRINT", "x{FE11} — HEXPRINT, similar to HEXDUMP, except the hexadecimal representation of s0 is not immediately output, but rather concatenated to an output text buffer."},
            {"BINDUMP", "x{FE12} — BINDUMP, dumps s0 in binary form, similarly to HEXDUMP."},
            {"BINPRINT", "x{FE13} — BINPRINT, outputs the binary representation of s0 to a text buffer."},
            {"STRDUMP", "x{FE14} — STRDUMP, dumps the Slice at s0 as an UTF-8 string."},
            {"STRPRINT", "x{FE15} — STRPRINT, similar to STRDUMP, but outputs the string into a text buffer (without carriage return)."},
            {"DEBUGOFF", "x{FE1E} — DEBUGOFF, disables all debug output until it is re-enabled by a DEBUGON. More precisely, this primitive increases an internal counter, which disables all debug operations (except DEBUGOFF and DEBUGON ) when strictly positive."},
            {"DEBUGON", "x{FE1F} — DEBUGON, enables debug output (in a debug version of TVM)."},
            {"DUMP", "x{FE2n} — DUMP s(n), 0≤ n<15, dumps s (n)."},
            {"PRINT", "x{FE3n} — PRINT s(n), 0≤ n<15, concatenates the text representation of s (n) (without any leading or trailing spaces or carriage returns) to a text buffer which will be output before the output of any other debug operation."},
            {"DUMPTOSFMT", "x{FEFnssss} — DUMPTOSFMT ssss, dumps s0 formatted according to the (n+1) -byte string ssss. This string might contain (a prefix of) the name of a TL-B type supported by the debugger. If the string begins with a zero byte, simply outputs it (without the first byte) into the debug log. If the string begins with a byte equal to one, concatenates it to a buffer, which will be output before the output of any other debug operation (effectively outputs a string without a carriage return)."},
            {"LOGSTR", "x{FEFn00ssss} — LOGSTR ssss, string ssss is n bytes long."},
            {"LOGFLUSH", "x{FEF000} — LOGFLUSH, flushes all pending debug output from the buffer into the debug log."},
            {"PRINTSTR", "x{FEFn01ssss} — PRINTSTR ssss, string ssss is n bytes long."},
            {"SETCP", "x{FFnn} — SETCP nn, selects TVM codepage 0≤ nn<240. If the codepage is not supported, throws an invalid opcode exception.\nx{FFFz} — SETCP z-16, selects TVM codepage z-16 for 1≤ z≤ 15. Negative codepages -13…-1 are reserved for restricted versions of TVM needed to validate runs of TVM in other codepages as explained in sp:cp.minusone. Negative codepage -14 is reserved for experimental codepages, not necessarily compatible between different TVM implementations, and should be disabled in the production versions of TVM."},
            {"SETCP0", "x{FF00} — SETCP0, selects TVM (test) codepage zero as described in this document."},
            {"SETCPX", "x{FFF0} — SETCPX ( c — )\\nSelects codepage c with -2^{15}≤ c<2^{15} passed in the top of the stack."},
            {"c0", "c0 — Contains the next continuation or return continuation (similar to the subroutine return address in conventional designs). This value must be a Continuation."},
            {"c1", "c1 — Contains the alternative (return) continuation; this value must be a Continuation. It is used in some (experimental) control flow primitives, allowing TVM to define and call “subroutines with two exit points”."},
            {"c2", "c2 — Contains the exception handler. This value is a Continuation, invoked whenever an exception is triggered."},
            {"c3", "c3 — Contains the current dictionary, essentially a hashmap containing the code of all functions used in the program. For reasons explained later in p:func.rec.dict, this value is also a Continuation, not a Cell as one might expect."},
            {"c4", "c4 — Contains the root of persistent data, or simply the data. This value is a Cell. When the code of a smart contract is invoked, c4 points to the root cell of its persistent data kept in the blockchain state. If the smart contract needs to modify this data, it changes c4 before returning."},
            {"c5", "c5 — Contains the output actions. It is also a Cell initialized by a reference to an empty cell, but its final value is considered one of the smart contract outputs. For instance, the SENDMSG primitive, specific for the TON Blockchain, simply inserts the message into a list stored in the output actions."},
            {"c7", "c7 — Contains the root of temporary data. It is a Tuple, initialized by a reference to an empty Tuple before invoking the smart contract and discarded after its termination. In the TON Blockchain context, c7 is initialized with a singleton Tuple, the only component of which is a Tuple containing blockchain-specific data. The smart contract is free to modify c7 to store its temporary data provided the first component of this Tuple remains intact."},
        };
        
        if (!word.empty()) {
            auto docstring = docs.find(word);
            if (docstring != docs.end()) {
                return docstring->second;
            }
        }
        return std::string(); 
    }
}